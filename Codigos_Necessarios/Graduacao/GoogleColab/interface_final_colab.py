# -*- coding: utf-8 -*-
"""Interface final.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/github/TurnipPudding/Estagio-SVGrad/blob/Testando_proibir_horarios_com_eta/Interface%20final.ipynb

## Imports
"""
from google.colab import files
from IPython.display import clear_output

import pandas as pd # Biblioteca Pandas para trabalhar com dataframes e planilhas do Excel.
import subprocess # Biblioteca Subprocess para chamar a execu√ß√£o de scripts/outros c√≥digos em Python.
import os # Biblioteca OS para auxiliar na cria√ß√£o e salvamento de arquivos.
# Biblioteca Openpyxl para trabalhar com planilhas do Excel de forma mais elaborada.
import openpyxl
from openpyxl import Workbook
from openpyxl.styles import PatternFill, Alignment, Border, Side
from openpyxl.utils import get_column_letter
from openpyxl import load_workbook
from openpyxl.formatting.rule import DataBar, FormatObject, Rule
from datetime import datetime, timedelta # Fun√ß√µes para a leitura de hor√°rios de aula
import sys

"""# Teste de Interface mais Clara

## Padroniza dataframe
"""

# Fun√ß√£o que padroniza os dataframes para terem o mesmo formato.
def padroniza_dataframe(file_name, header_row, ano):
    """
    Fun√ß√£o para padronizar dataframes no Google Colab
    Par√¢metros:
    - file_name: caminho/nome do arquivo
    - header_row: linha do cabe√ßalho
    - ano: ano dos dados
    Retorna:
    - DataFrame padronizado ou None em caso de erro
    """
    try:
        # Leitura do arquivo
        # print(f"\nüìä Processando arquivo: {os.path.basename(file_name)}")
        df = pd.read_excel(file_name, header=header_row)

        # Padroniza√ß√£o de cabe√ßalhos
        # print("üîÑ Padronizando cabe√ßalhos...")
        for col in range(len(df.columns)):
            if "\n" in df.columns[col]:
                df = df.rename(columns={df.columns[col]: df.columns[col].replace("\n", " ")})
            if "Sala" in df.columns[col]:
                df = df.rename(columns={df.columns[col]: "Sala"})

        # Processamento da coluna 'Deve ser alocada no ICMC?'
        # print("üîç Filtrando disciplinas para aloca√ß√£o...")
        for idx, row in df.iterrows():
            df.loc[idx, 'Deve ser alocada no ICMC?'] = str(df.loc[idx, 'Deve ser alocada no ICMC?']).replace(' ', '')
            if df.loc[idx, 'Deve ser alocada no ICMC?'] == 'x':
                df.loc[idx, 'Deve ser alocada no ICMC?'] = 'X'

        df = df[df['Deve ser alocada no ICMC?'] == 'X']

        # Adi√ß√£o de colunas padr√£o se n√£o existirem
        # print("‚ûï Adicionando colunas padr√£o...")
        if "Hor√°rio 3" not in df.columns:
            df.insert(df.columns.get_loc("Hor√°rio 2") + 1, "Hor√°rio 3", pd.NA)

        if "Hor√°rio 4" not in df.columns:
            df.insert(df.columns.get_loc("Hor√°rio 3") + 1, "Hor√°rio 4", pd.NA)

        if "observa√ß√µes" in df.columns:
            df = df.rename(columns={"observa√ß√µes": "Observa√ß√µes"})

        if "Observa√ß√µes" not in df.columns:
            df.insert(df.columns.get_loc("Hor√°rio 4") + 1, "Observa√ß√µes", pd.NA)

        headers = df.columns

        # Preenchimento de valores padr√£o
        df['Utilizar√° laborat√≥rio? (sim ou n√£o)'] = df['Utilizar√° laborat√≥rio? (sim ou n√£o)'].fillna("N√£o")

        # Verifica√ß√£o de turmas n√£o definidas
        turmas0 = df[df['Turma'].isna()].index.tolist()
        if len(turmas0) != 0:
            print(f"\n‚ö†Ô∏è AVISO: Turmas n√£o identificadas no arquivo {os.path.basename(file_name)}")
            print(f"Linhas com problema: {[d + header_row + 2 for d in turmas0]}")
            print("Por favor, verifique qual a turma da disciplina.")
            return None

        # Adi√ß√£o de colunas adicionais
        df.insert(df.columns.get_loc(headers[-1]), "Vagas por disciplina", "")
        df.insert(df.columns.get_loc(headers[-1]), "Ano dos dados", ano)

        # Padroniza√ß√£o de hor√°rios
        # print("‚è±Ô∏è Verificando formata√ß√£o de hor√°rios...")
        for header in ['Hor√°rio 1', 'Hor√°rio 2', 'Hor√°rio 3', 'Hor√°rio 4']:
            for d in df.index:
                # Substitui√ß√£o de tra√ßos anormais
                if "‚Äì" in str(df.loc[d, header]):
                    df.loc[d, header] = df.loc[d, header].replace('‚Äì', '-')

                # Valida√ß√£o do formato dos hor√°rios
                if not pd.isna(df.loc[d, header]) and "-" not in str(df.loc[d, header]) and str(df.loc[d, header]).strip():
                    print(f"\n‚ö†Ô∏è AVISO: Hor√°rio n√£o padronizado encontrado!")
                    print(f"Arquivo: {os.path.basename(file_name)}")
                    print(f"Linha: {d + header_row + 2}")
                    print(f"Coluna: {header}")
                    print(f"Conte√∫do: '{df.loc[d, header]}'")
                    print("Padr√£o esperado: 'Segunda - 08:10/09:50'")
                    print("Provavelmente falta um '-' entre o dia da semana e o hor√°rio da aula.")
                    return None

                if not pd.isna(df.loc[d, header]) and len(str(df.loc[d, header]).split("-")) > 2:
                    print(f"\n‚ö†Ô∏è AVISO: Formato de hor√°rio inv√°lido!")
                    print(f"Arquivo: {os.path.basename(file_name)}")
                    print(f"Linha: {d + header_row + 2}")
                    print(f"Coluna: {header}")
                    print(f"Conte√∫do: '{df.loc[d, header]}'")
                    print("Padr√£o esperado: 'Segunda - 08:10/09:50'")
                    print("Provavelmente h√° mais de um '-' na c√©lula.")
                    return None

        # Adiciono 4 colunas para anotar poss√≠veis salas onde as aulas ficam PROIBIDAS de serem alocadas.
        # Cada coluna refere-se a uma coluna de hor√°rios, fazendo com que as salas listadas em uma coluna afetem apenas a aula de mesma coluna.
        # Ex: Adicionar a sala 3-009 na segunda coluna de proibi√ß√£o faz com que a aula do Hor√°rio 2 de uma disciplina n√£o possa ser na 3-009.
        df.insert(df.columns.get_loc(headers[-1]), "Proibir Hor√°rio 1", pd.NA)
        df.insert(df.columns.get_loc(headers[-1]), "Proibir Hor√°rio 2", pd.NA)
        df.insert(df.columns.get_loc(headers[-1]), "Proibir Hor√°rio 3", pd.NA)
        df.insert(df.columns.get_loc(headers[-1]), "Proibir Hor√°rio 4", pd.NA)

        print("‚úÖ Padroniza√ß√£o conclu√≠da com sucesso!")
        return df

    except Exception as e:
        print(f"\n‚ùå Erro durante a padroniza√ß√£o do dataframe:")
        print(f"Arquivo: {os.path.basename(file_name)}")
        print(f"Erro: {str(e)}")
        return None
# def padroniza_dataframe(file_name, header_row, ano):
#     # Leio o dataframe correto, com a linha do cabe√ßalho.
#     df = pd.read_excel(file_name, header=header_row)
#     # print(df['Hor√°rio 4'])
#     # Primeiramente, para cada cabe√ßalho/coluna 'col' do dataframe.
#     for col in range(len(df.columns)):
#         # Verifico se tem um "\n" no texto do dataframe.
#         if "\n" in df.columns[col]:
#             # Se houver, substituo ele por um " ".
#             df = df.rename(columns={df.columns[col] : df.columns[col].replace("\n", " ")})
#         # Verifico se estou na coluna das salas - "Sala (a definir)".
#         if "Sala" in df.columns[col]:
#             # Se estiver, substituo o nome da coluna por apenas "Sala".
#             df = df.rename(columns={df.columns[col] : "Sala"})

#     for idx, row in df.iterrows():
#         df.loc[idx, 'Deve ser alocada no ICMC?'] = str(df.loc[idx, 'Deve ser alocada no ICMC?']).replace(' ', '')
#         if df.loc[idx, 'Deve ser alocada no ICMC?'] == 'x':
#             df.loc[idx, 'Deve ser alocada no ICMC?'] = 'X'
#     # Filtro o dataframe para fazer a edi√ß√£o apenas nas disciplinas que importam.
#     # Isto √©, eu passo a trabalhar apenas com as disciplinas marcadas com um 'X' que devem ser alocadas no ICMC.
#     df = df[df['Deve ser alocada no ICMC?'] == 'X']

#     # Ap√≥s editar os cabe√ßalhos, verifico se existe um cabe√ßalho chamado "Hor√°rio 4" no dataframe.
#     if "Hor√°rio 3" not in df.columns:
#         # Se n√£o houver, eu o adiciono no dataframe. Primeiro, procuro pelo cabe√ßalho "Hor√°rio 3", e insiro a nova coluna ao lado.
#         df.insert(df.columns.get_loc("Hor√°rio 2") + 1, "Hor√°rio 3", pd.NA)

#     # Ap√≥s editar os cabe√ßalhos, verifico se existe um cabe√ßalho chamado "Hor√°rio 4" no dataframe.
#     if "Hor√°rio 4" not in df.columns:
#         # Se n√£o houver, eu o adiciono no dataframe. Primeiro, procuro pelo cabe√ßalho "Hor√°rio 3", e insiro a nova coluna ao lado.
#         df.insert(df.columns.get_loc("Hor√°rio 3") + 1, "Hor√°rio 4", pd.NA)

#     if "observa√ß√µes" in df.columns:
#         df = df.rename(columns={"observa√ß√µes" : "Observa√ß√µes"})

#     if "Observa√ß√µes" not in df.columns:
#         df.insert(df.columns.get_loc("Hor√°rio 4") + 1, "Observa√ß√µes", pd.NA)

#     # Salvo o nome dos cabe√ßalhos do dataframe ap√≥s as edi√ß√µes.
#     headers = df.columns

#     # Preencho os espa√ßos vazios da coluna de uso de laborat√≥rios com "N√£o". Dessa forma, o usu√°rio s√≥ precisa indicar qual disciplina
#     # requer um laborat√≥rio.
#     df['Utilizar√° laborat√≥rio? (sim ou n√£o)'] = df['Utilizar√° laborat√≥rio? (sim ou n√£o)'].fillna("N√£o")
#     # print(df['Utilizar√° laborat√≥rio? (sim ou n√£o)'])

#     # Busco e listo por disciplinas cuja Turma n√£o foi definida.
#     turmas0 = df[df['Turma'].isna()].index.tolist()
#     # Se existirem tais disciplinas, uma janela √© aberta para indicar as linhas do arquivo que possuem turmas vazias.
#     if len(turmas0) != 0:
#         messagebox.showwarning(f"Aviso!", 
#                                (
#                                    f"A(s) linha(s) {[d + header_row + 2 for d in turmas0]} do arquivo {file_name} "
#                                    f"possuem turmas n√£o identificadas. Verifique qual a turma da disciplina."
#                                 )
#                             )
#         return None

#     # Adiciono mais duas colunas no dataframe, uma para colocar o n√∫mero de inscritos das disciplinas, e outra para o ano dos dados.
#     df.insert(df.columns.get_loc(headers[-1]), "Vagas por disciplina", "")
#     df.insert(df.columns.get_loc(headers[-1]), "Ano dos dados", ano)

#     # Alguns hor√°rios das disciplinas podem ter sido definidos com um tra√ßo diferente do usual do teclado.
#     # Por isso, eu busco em cada coluna de hor√°rios por esses poss√≠veis tra√ßos errados, pois eles prejudicam a leitura das disciplinas.
#     # Para cada coluna de hor√°rio:
#     for header in ['Hor√°rio 1', 'Hor√°rio 2', 'Hor√°rio 3', 'Hor√°rio 4']:
#         # Para cada linha do dataframe:
#         for d in df.index:
#             # Verifico se o tra√ßo anormal est√° na c√©lula em quest√£o.
#             if "‚Äì" in str(df.loc[d, header]):
#                 # Se estiver, substituo-o pelo tra√ßo normal.
#                 df.loc[d, header] = df.loc[d, header].replace('‚Äì', '-')
#             if not pd.isna(df.loc[d, header]) \
#                 and "-" not in str(df.loc[d, header]) \
#                     and not (df.loc[d, header] == ""):
#                 # print((df.loc[d, header]) == "")
#                 messagebox.showwarning(f"Aviso! H√° um hor√°rio de aula n√£o padronizado!",
#                                    (
#                                        f"Verifique a linha {d+header_row+2} da coluna {header} do arquivo {file_name}.\n"
#                                        f"Padr√£o correto: 'Segunda - 08:10/09:50'\n"
#                                        f"Provavelmente, falta um '-' entre o dia da semana e o hor√°rio da aula."
#                                    )
#                                 )
#                 return None
#             print(len(str(df.loc[d, header]).split("-")))
#             if not pd.isna(df.loc[d, header]) and len(str(df.loc[d, header]).split("-")) > 2:
#                 messagebox.showwarning(f"Aviso! H√° um hor√°rio de aula n√£o padronizado!",
#                                    (
#                                        f"Verifique a linha {d+header_row+2} da coluna {header} do arquivo {file_name}.\n"
#                                        f"Padr√£o correto: 'Segunda - 08:10/09:50'\n"
#                                        f"Provavelmente, h√° mais de um '-' na c√©lula."
#                                    )
#                                 )
#                 return None

#     # Adiciono 4 colunas para anotar poss√≠veis salas onde as aulas ficam PROIBIDAS de serem alocadas.
#     # Cada coluna refere-se a uma coluna de hor√°rios, fazendo com que as salas listadas em uma coluna afetem apenas a aula de mesma coluna.
#     # Ex: Adicionar a sala 3-009 na segunda coluna de proibi√ß√£o faz com que a aula do Hor√°rio 2 de uma disciplina n√£o possa ser na 3-009.
#     df.insert(df.columns.get_loc(headers[-1]), "Proibir Hor√°rio 1", pd.NA)
#     df.insert(df.columns.get_loc(headers[-1]), "Proibir Hor√°rio 2", pd.NA)
#     df.insert(df.columns.get_loc(headers[-1]), "Proibir Hor√°rio 3", pd.NA)
#     df.insert(df.columns.get_loc(headers[-1]), "Proibir Hor√°rio 4", pd.NA)

#     # Retorno o dataframe com todas as padroniza√ß√µes necess√°rias.
#     return df

"""## Tooltip"""

# # Classe Tooltip utilizada para mostrar textos ao sobrevoar o mouse em alguma parte da interface.
# class Tooltip:
#     def __init__(self, widget, text):
#         self.widget = widget
#         self.text = text
#         self.tooltip_window = None

#         # Eventos para mostrar e ocultar o tooltip
#         widget.bind("<Enter>", self.show_tooltip)
#         widget.bind("<Leave>", self.hide_tooltip)

#     def show_tooltip(self, event=None):
#         # Cria a janela do tooltip
#         if self.tooltip_window is not None:
#             return

#         x = self.widget.winfo_rootx() + 20  # Posi√ß√£o X do tooltip
#         y = self.widget.winfo_rooty() + 20  # Posi√ß√£o Y do tooltip

#         self.tooltip_window = tk.Toplevel(self.widget)
#         self.tooltip_window.wm_overrideredirect(True)  # Remove bordas da janela
#         self.tooltip_window.geometry(f"+{x}+{y}")

#         label = tk.Label(
#             self.tooltip_window,
#             text=self.text,
#             background="lightyellow",
#             relief="solid",
#             borderwidth=1,
#             font=("Arial", 10)
#         )
#         label.pack(ipadx=5, ipady=3)

#     def hide_tooltip(self, event=None):
#         # Destr√≥i a janela do tooltip
#         if self.tooltip_window:
#             self.tooltip_window.destroy()
#             self.tooltip_window = None

"""## Ler planilhas dos institutos (Base de dados das aulas e do jupiter)"""

# Fun√ß√£o para criar a base de dados das aulas e a dos dados do J√∫piterWeb.
# Seu par√¢metro 'jupiter' refere-se a uma vari√°vel booleana, que recebe o valor True caso seja o momento de criar a Base de Dados do J√∫piter,
# e False caso contr√°rio.

def planilha_dep(jupiter):
    """
    Fun√ß√£o para constru√ß√£o de planilhas de dados usando upload interativo no Colab
    Par√¢metro:
    - jupiter: booleano que indica se √© para dados do J√∫piterWeb (True) ou das Aulas (False)
    """
    
    clear_output(wait=True)
    print(f"=== CONSTRUIR {'BASE DE DADOS DO J√öPITERWEB' if jupiter else 'BASE DE DADOS DAS AULAS'} ===")
    
    # Dicion√°rio para armazenar os arquivos carregados
    arquivos_carregados = {}
    
    # Fun√ß√£o auxiliar para upload com mensagem espec√≠fica
    def fazer_upload(mensagem):
        print(f"\n{mensagem}")
        print("Por favor, fa√ßa o upload do arquivo:")
        uploaded = files.upload()
        if not uploaded:
            print("Nenhum arquivo foi selecionado!")
            return None
        # Retorna o primeiro arquivo carregado
        return next(iter(uploaded))
    
    # Solicitar arquivos obrigat√≥rios
    arquivos_carregados['sme'] = fazer_upload("1. Planilha do SME (arquivo Excel)")
    arquivos_carregados['sma'] = fazer_upload("2. Planilha do SMA (arquivo Excel)")
    arquivos_carregados['scc'] = fazer_upload("3. Planilha do SCC (arquivo Excel)")
    arquivos_carregados['ssc'] = fazer_upload("4. Planilha do SSC (arquivo Excel)")
    
    if not jupiter:
        # Arquivos espec√≠ficos para dados das aulas
        arquivos_carregados['outros'] = fazer_upload("5. Planilha dos Outros Institutos (arquivo Excel)")
        arquivos_carregados['salas'] = fazer_upload("6. Planilha dos dados das salas (arquivo Excel)")
        ano_dados = input("\n7. Digite o ano dos dados: ").strip()
    else:
        # L√≥gica para m√∫ltiplos arquivos no modo J√∫piter
        lista_outros = []
        print("\n5. Arquivos dos Outros Institutos (fa√ßa upload de cada arquivo separadamente)")
        while True:
            print(f"\nArquivo {len(lista_outros)+1} (deixe vazio e pressione Enter para parar):")
            uploaded = files.upload()
            if not uploaded:
                break
            lista_outros.append(next(iter(uploaded)))
    
    nome_arquivo = input("\nDigite o nome para a base de dados (sem extens√£o): ").strip()
    
    # Valida√ß√£o dos inputs
    def validar_arquivo(arquivo, nome):
        if arquivo is None:
            print(f"Erro: Por favor, forne√ßa o {nome}")
            return False
        return True
    
    # Verifica arquivos obrigat√≥rios
    if not all([
        validar_arquivo(arquivos_carregados['sme'], "arquivo do SME"),
        validar_arquivo(arquivos_carregados['sma'], "arquivo do SMA"),
        validar_arquivo(arquivos_carregados['scc'], "arquivo do SCC"),
        validar_arquivo(arquivos_carregados['ssc'], "arquivo do SSC")
    ]):
        input("\nPressione Enter para tentar novamente...")
        return planilha_dep(jupiter)
    
    if not jupiter:
        if not all([
            validar_arquivo(arquivos_carregados['outros'], "arquivo dos Outros Institutos"),
            validar_arquivo(arquivos_carregados['salas'], "arquivo dos dados das salas"),
            ano_dados
        ]):
            input("\nPressione Enter para tentar novamente...")
            return planilha_dep(jupiter)
    else:
        if not lista_outros:
            print("Erro: Por favor, adicione pelo menos um arquivo dos Outros Institutos")
            input("\nPressione Enter para tentar novamente...")
            return planilha_dep(jupiter)
    
    if not nome_arquivo:
        print("Erro: Por favor, forne√ßa um nome para a base de dados")
        input("\nPressione Enter para tentar novamente...")
        return planilha_dep(jupiter)
    
    # Chamar a fun√ß√£o de concatena√ß√£o
    if not jupiter:
        concat_df(
            arquivos_carregados['sme'], arquivos_carregados['sma'], arquivos_carregados['scc'],
            arquivos_carregados['ssc'], arquivos_carregados['salas'], nome_arquivo, 
            ano_dados, jupiter, arquivos_carregados['outros']
        )
    else:
        concat_df(
            arquivos_carregados['sme'], arquivos_carregados['sma'], arquivos_carregados['scc'],
            arquivos_carregados['ssc'], None, nome_arquivo, 
            None, jupiter, lista_outros
        )
    
    print("\n‚úÖ Base de dados criada com sucesso!")
    input("\nPressione Enter para voltar ao menu principal...")
# def planilha_dep(jupiter):

#     # Crio uma nova janela em cima da janela principal da interface.
#     nova_janela = tk.Toplevel(root)

#     # Baseado em qual base de dados ser√° criada, defino um nome diferente para a janela.
#     if not jupiter:
#         nova_janela.title("Construir Base de Dados das Aulas")

#     else:
#         nova_janela.title("Construir Base de Dados do J√∫piterWeb")

#     # Crio o frame para armazenar os bot√µes e outros campos da nova janela.
#     frame = tk.Frame(nova_janela)
#     frame.pack(pady=10, padx=10)

#     # Defino v√°rias vari√°veis para armazenar os nomes dos arquivos para criar a base de dados.
#     arquivo_sme = tk.StringVar(value="Selecione a planilha do SME")
#     arquivo_sma = tk.StringVar(value="Selecione a planilha do SMA")
#     arquivo_scc = tk.StringVar(value="Selecione a planilha do SCC")
#     arquivo_ssc = tk.StringVar(value="Selecione a planilha do SSC")
#     arquivo_outros = tk.StringVar(value="Selecione a planilha dos Outros Institutos")
#     arquivo_salas = tk.StringVar(value="Selecione a planilha dos dados das salas")
#     # Defino uma vari√°vel para conter o ano dos dados fornecidos.
#     ano_dados = IntVar()
#     # Defino uma vari√°vel para conter o nome da nova base de dados.
#     nome_arquivo = tk.StringVar()
#     # Defino uma lista que ir√° conter os nomes de outros arquivos necess√°rios para criar uma base de dados.
#     lista_outros = []

#     # Defino as fun√ß√µes para selecionar arquivos.
#     def selecionar_sme():
#         # A classe filedialog faz com que o gerenciador de arquivos seja aberto para selecionar um arquivo.
#         # O usu√°rio seleciona o arquivo contendo a base de dados das aulas.
#         arquivo = filedialog.askopenfilename(title="Selecione a planilha do SME")

#         # Se um arquivo foi selecionado:
#         if arquivo:
#             # Salvo o caminho do arquivo.
#             arquivo_sme.set(arquivo)
#     def selecionar_sma():
#         arquivo = filedialog.askopenfilename(title="Selecione a planilha do SMA")
#         if arquivo:
#             arquivo_sma.set(arquivo)
#     def selecionar_scc():
#         arquivo = filedialog.askopenfilename(title="Selecione a planilha do SCC")
#         if arquivo:
#             arquivo_scc.set(arquivo)
#     def selecionar_ssc():
#         arquivo = filedialog.askopenfilename(title="Selecione a planilha do SSC")
#         if arquivo:
#             arquivo_ssc.set(arquivo)
#     # Se n√£o estiver criando a base de dados do J√∫piter:
#     if not jupiter:
#         # Tamb√©m defino as fun√ß√µes necess√°rias para salvar outros arquivos.
#         def selecionar_outros():
#             arquivo = filedialog.askopenfilename(title="Selecione a planilha dos Outros Institutos")
#             if arquivo:
#                 arquivo_outros.set(arquivo)
#         def selecionar_salas():
#             arquivo = filedialog.askopenfilename(title="Selecione a planilha dos dados das salas")
#             if arquivo:
#                 arquivo_salas.set(arquivo)



#     # Crio uma legenda para ficar ao lado do bot√£o.
#     lbl_sme = tk.Label(frame, text="Selecione a planilha do SME:")
#     # Defino a posi√ß√£o do texto na janela.
#     lbl_sme.grid(row=0, column=0, pady=5, sticky="w")
#     # Crio o bot√£o para salvar o arquivo do SME.
#     btn_selecionar_sme = tk.Button(frame, textvariable=arquivo_sme, command=selecionar_sme, wraplength=250, width=40)
#     # Defino a posi√ß√£o do bot√£o na janela.
#     btn_selecionar_sme.grid(row=0, column=1, padx=5, pady=5)

#     # As linhas a seguir s√£o an√°logas.
#     lbl_sma = tk.Label(frame, text="Selecione a planilha do SMA:")
#     lbl_sma.grid(row=1, column=0, pady=5, sticky="w")
#     btn_selecionar_sma = tk.Button(frame, textvariable=arquivo_sma, command=selecionar_sma, wraplength=250, width=40)
#     btn_selecionar_sma.grid(row=1, column=1, padx=5, pady=5)

#     lbl_scc = tk.Label(frame, text="Selecione a planilha do SCC:")
#     lbl_scc.grid(row=2, column=0, pady=5, sticky="w")
#     btn_selecionar_scc = tk.Button(frame, textvariable=arquivo_scc, command=selecionar_scc, wraplength=250, width=40)
#     btn_selecionar_scc.grid(row=2, column=1, padx=5, pady=5)

#     lbl_ssc = tk.Label(frame, text="Selecione a planilha do SSC:")
#     lbl_ssc.grid(row=3, column=0, pady=5, sticky="w")
#     btn_selecionar_ssc = tk.Button(frame, textvariable=arquivo_ssc, command=selecionar_ssc, wraplength=250, width=40)
#     btn_selecionar_ssc.grid(row=3, column=1, padx=5, pady=5)

#     # Como anteriormente, caso a base sendo criada n√£o √© a do J√∫piterWeb:
#     if not jupiter:
#         # Defino algumas legendas e bot√µes adicionais.
#         lbl_outros = tk.Label(frame, text="Selecione a planilha dos Outros Institutos:")
#         lbl_outros.grid(row=4, column=0, pady=5, sticky="w")
#         btn_selecionar_outros = tk.Button(frame, textvariable=arquivo_outros, command=selecionar_outros, wraplength=250, width=40)
#         btn_selecionar_outros.grid(row=4, column=1, padx=5, pady=5)

#         lbl_salas = tk.Label(frame, text="Selecione a planilha dos dados das salas:")
#         lbl_salas.grid(row=5, column=0, pady=5, sticky="w")
#         btn_selecionar_salas = tk.Button(frame, textvariable=arquivo_salas, command=selecionar_salas, wraplength=250, width=40)
#         btn_selecionar_salas.grid(row=5, column=1, padx=5, pady=5)


#         # Campo para inserir o valor
#         lbl_ano = tk.Label(frame, text="Insira o ano dos dados:")
#         lbl_ano.grid(row=6, column=0, sticky="w", pady=5)
#         campo_ano = tk.Entry(frame, textvariable=ano_dados)
#         campo_ano.grid(row=6, column=1, pady=5)

#     # Caso esteja sendo criada a base de dados do J√∫piter:
#     else:
#         # Defino um frame adicional na janela.
#         frame2 = tk.Frame(nova_janela)
#         frame2.pack(pady=10, padx=10)

#         # Defino algumas fun√ß√µes especiais para utilizar nesse novo frame.

#         # Defino uma fun√ß√£o para salvar um arquivo, da mesma forma como as fun√ß√µes anteriores.
#         def add_file():
#             file_path = filedialog.askopenfilename(title="Selecione um arquivo")
#             # A diferen√ßa, √© que se um arquivo foi selecionado, eu o salvo em uma lista, ao inv√©s de uma vari√°vel √∫nica.
#             if file_path:
#                 lista_outros.append(file_path)
#                 # E tamb√©m atualizo a lista visualizada no frame utilizando uma outra fun√ß√£o definida aqui.
#                 update_listbox()

#         # Defino uma fun√ß√£o para remover um arquivo da lista selecionado pelo usu√°rio.
#         def remove_selected():
#             # Tento executar as linhas a seguir, que s√≥ devem ser executadas se o usu√°rio escolher um arquivo da lista.
#             try:
#                 # Salvo o √≠ndice do arquivo selecionado pelo usu√°rio.
#                 selected_index = file_listbox.curselection()[0]
#                 # Removo o arquivo de mesmo √≠ndice da lista.
#                 lista_outros.pop(selected_index)
#                 # E atualizo a lista visualizada no frame.
#                 update_listbox()
#             # Se nenhum arquivo ser selecionado, a intera√ß√£o √© ignorada, e nada acontece.
#             except IndexError:
#                 pass

#         # Defino uma fun√ß√£o que atualiza a visualiza√ß√£o da lista no frame.
#         def update_listbox():
#             # Primeiro, limpo a lista que estava sendo mostrada anteriormente.
#             file_listbox.delete(0, tk.END)
#             # Depois disso, adiciono os arquivos da lista no visor.
#             for file in lista_outros:
#                 file_listbox.insert(tk.END, file)  # Adiciona os arquivos novamente

#         # Defino um bot√£o para adicionar arquivos, e sua posi√ß√£o na janela.
#         add_file_button = tk.Button(frame2, text="Adicionar Arquivo", command=add_file)
#         add_file_button.grid(row=0, column=0, pady=5, sticky="w")

#         # Defino uma lista para aparecer no visor do frame.
#         file_listbox = tk.Listbox(frame2, width=100, height=10)
#         file_listbox.grid(row=1, column=0, pady=5)

#         # Defino um bot√£o para remover arquivos, e sua posi√ß√£o na janela.
#         remove_file_button = tk.Button(frame2, text="Remover Selecionado", command=remove_selected)
#         remove_file_button.grid(row=0, column=0, pady=5, sticky="e")


#     # Defino uma legenda e sua posi√ß√£o na janela, que indicar√° o campo onde o usu√°rio digitar√° o nome do arquivo da base de dados.
#     lbl_arq = tk.Label(frame, text="Insira o nome para a base de dados:")
#     lbl_arq.grid(row=7, column=0, sticky="w", pady=5)
#     campo_arq = tk.Entry(frame, textvariable=nome_arquivo)
#     campo_arq.grid(row=7, column=1, pady=5)


#     # Defino uma fun√ß√£o que salva os valores das vari√°veis contendo o nome dos arquivos escolhidos.
#     def salvar_valores():
#         # Todas as condi√ß√µes a seguir seguem a l√≥gica de que, se um arquivo n√£o foi selecionado, uma janela avisando o ocorrido
#         # aparece, pedindo para o usu√°rio selecionar um arquivo no campo requerido.

#         if not arquivo_sme.get() or arquivo_sme.get() == "Selecione a planilha do SME":
#             messagebox.showwarning("Aviso", "Por favor, selecione a planilha do SME.")
#             return
#         if not arquivo_sma.get() or arquivo_sma.get() == "Selecione a planilha do SMA":
#             messagebox.showwarning("Aviso", "Por favor, selecione a planilha do SMA.")
#             return
#         if not arquivo_scc.get() or arquivo_scc.get() == "Selecione a planilha do SCC":
#             messagebox.showwarning("Aviso", "Por favor, selecione a planilha do SCC.")
#             return
#         if not arquivo_ssc.get() or arquivo_ssc.get() == "Selecione a planilha do SSC":
#             messagebox.showwarning("Aviso", "Por favor, selecione a planilha do SSC.")
#             return

#         # Caso n√£o seja a base dos dados do J√∫piter que est√° sendo feita:
#         if not jupiter:
#             # Verifico se os arquivos foram selecionados, e os campos preenchidos, novamente alertando se algo estiver faltando.
#             if not arquivo_outros.get() or arquivo_outros.get() == "Selecione a planilha dos Outros Institutos":
#                 messagebox.showwarning("Aviso", "Por favor, selecione a planilha dos Outros Institutos.")
#                 return
#             if not arquivo_salas.get() or arquivo_salas.get() == "Selecione a planilha dos dados das salas":
#                 messagebox.showwarning("Aviso", "Por favor, selecione a planilha dos dados das salas.")
#                 return
#             if not ano_dados.get():
#                 messagebox.showwarning("Aviso", "Por favor, insira o ano dos dados.")
#                 return
#         # Caso seja a base dos dados do J√∫piter que est√° sendo feita:
#         else:
#             # Verifico se foram adicionados arquivos com os dados dos outros institutos, alertando a aus√™ncia deles.
#             if len(lista_outros) == 0:
#                 messagebox.showwarning("Aviso", "Por favor, selecione a(s) planilha(s) dos Outros Institutos.")
#                 return

#         # Fa√ßo o mesmo alerta de antes caso o usu√°rio n√£o tenha fornecido o nome para a nova base de dados.
#         if not nome_arquivo.get():
#             messagebox.showwarning("Aviso", "Por favor, insira o nome da base de dados.")
#             return


#         # Baseando-se em qual base de dados est√° sendo criada, chamo uma fun√ß√£o para concatenar os dados dos arquivos fornecidos.
#         if not jupiter:
#             concat_df(arquivo_sme.get(), arquivo_sma.get(), arquivo_scc.get(),
#                       arquivo_ssc.get(), arquivo_salas.get(), nome_arquivo.get(), ano_dados.get(), jupiter, arquivo_outros.get())
#         else:
#             concat_df(arquivo_sme.get(), arquivo_sma.get(), arquivo_scc.get(),
#                       arquivo_ssc.get(), None, nome_arquivo.get(), None, jupiter, lista_outros)
#         # messagebox.showinfo("Sucesso", "Valores salvos com sucesso!")

#         # Terminada a concatena√ß√£o, destruo a janela de sele√ß√£o.
#         nova_janela.destroy()

#     # Defino um bot√£o e seu espa√ßo na janela para chamar a fun√ß√£o que salva os nomes dos arquivos.
#     btn_salvar = tk.Button(nova_janela, text="Criar base de dados", command=salvar_valores)
#     btn_salvar.pack(pady=10)

    # Uma importante ressalva. Por conta da maneira que os bot√µes, textos e campos podem ser colocados na janela,
    # √© poss√≠vel deixar certos bot√µes com uma ordem, mesmo que "o espa√ßo entre eles deveria estar vazio".
    # Por exemplo: no caso de estar fazendo a base de dados do J√∫piter, algumas posi√ß√µes podem estar denotadas como
    # linha 7 depois de linha 5, mas o espa√ßo onde estaria a linha 6 n√£o possui nada. Neste caso, a linha 7 √© jogada para cima,
    # preenchendo o lugar da linha 6.
    # Em outras palavras, enquanto a ordem for mantida de menor para maior, mesmo que possa "faltar" defini√ß√µes em determinadas linhas,
    # a ordem e espa√ßo dos objetos e widgets ser√° mantida.

"""### Ler Dataframe"""

# Fun√ß√£o que l√™ um dado arquivo.
def ler_df(caminho_arquivo):
    """
    Fun√ß√£o para ler arquivos de dados (Excel ou CSV) no Google Colab
    Retorna um DataFrame pandas ou None em caso de erro
    """
    try:
        if caminho_arquivo.endswith(('.xlsx', '.xls')):
            df = pd.read_excel(caminho_arquivo)
            return df
        elif caminho_arquivo.endswith('.csv'):
            df = pd.read_csv(caminho_arquivo, on_bad_lines='skip', sep=';', encoding='latin-1')
            return df
        else:
            print("‚ùå Erro: Formato de arquivo n√£o suportado!")
            print("Por favor, use arquivos .xlsx, .xls ou .csv")
            return None
            
    except Exception as e:
        print(f"‚ùå Erro ao carregar o arquivo {caminho_arquivo}:\n\n{e}")
        return None
    
# def ler_df(caminho_arquivo):
#     # Tento ler um arquivo.
#     try:
#         # Dependendo do tipo de arquivo, precisa utilizar leituras de dados diferentes. Vale ressaltar que essa fun√ß√£o l√™ apenas arquivos
#         # de planilha, como '.xlsx', '.xls' e '.csv'. Com o arquivo lido, retorno o dataframe correspondente.
#         if caminho_arquivo.endswith(('.xlsx', '.xls')):
#             df = pd.read_excel(caminho_arquivo)
#             return df
#         elif caminho_arquivo.endswith('.csv'):
#             df = pd.read_csv(caminho_arquivo, on_bad_lines='skip', sep=';', encoding='latin-1')
#             return df
#         else:
#             # Caso o arquivo fornecido seja incompat√≠vel, alerto o usu√°rio.
#             raise ValueError("Formato de arquivo n√£o suportado!")

#     # No caso de algum erro inesperado ocorrer, alerto o usu√°rio com uma mensagem e o nome do erro.
#     except Exception as e:
#             messagebox.showerror("Erro", f"Erro ao carregar o arquivo:\n{e}")
#     # return df

"""### Concatenar"""

# Fun√ß√£o que concatena as planilhas em um √∫nico arquivo.
# import os

def concat_df(SME, SMA, SCC, SSC, salas, nome_arquivo, ano, jupiter, outros):
    """
    Fun√ß√£o para concatenar planilhas em um √∫nico arquivo no Google Colab
    """
    files = []
    
    if not jupiter:
        # L√™ a planilha de salas
        print("\nüìÇ Lendo dados das salas...")
        df_salas = ler_df(salas)
        if df_salas is None:
            print("‚ùå Erro na leitura do arquivo de salas. Opera√ß√£o cancelada.")
            return

        name_files = [SME, SMA, SCC, SSC, outros]
        sheets = ["SME", "SMA", "SCC", "SSC", "Outros"]
    else:
        name_files = [SME, SMA, SCC, SSC]
        name_files.extend(outros)
        sheets = []

    # Processa cada arquivo
    for i, name in enumerate(name_files):
        # print(f"\nüìÇ Processando arquivo {i+1}/{len(name_files)}...")
        df = ler_df(name)
        if df is None:
            print(f"‚ùå Erro no arquivo {name}. Opera√ß√£o cancelada.")
            return

        if not jupiter:
            header_name = 'Disciplina (c√≥digo)'
            header_found = False
            
            for i, valor in enumerate(df.loc[:,df.columns[0]]):
                if valor == header_name:
                    header_row = i+1
                    df_padronizado = padroniza_dataframe(name, header_row, ano)
                    
                    if df_padronizado.empty:
                        print(f"‚ùå O arquivo '{os.path.basename(name)}' n√£o pode ser lido ou est√° vazio.")
                        print("Verifique se as disciplinas a serem alocadas est√£o marcadas.")
                        return
                        
                    files.append(df_padronizado)
                    header_found = True
                    break
                    
            if not header_found:
                print(f"‚ùå A coluna '{header_name}' n√£o foi encontrada no arquivo {os.path.basename(name)}")
                print("Verifique o cabe√ßalho do arquivo de entrada.")
                return
        else:
            try:
                new_name = str(df.loc[0, 'Disciplina'])[:3]
                sheets.append(new_name)
                files.append(df)
            except KeyError:
                print(f"‚ùå A coluna 'Disciplina' n√£o foi encontrada no arquivo {os.path.basename(name)}")
                print("Verifique o cabe√ßalho do arquivo de entrada.")
                return
            except Exception as e:
                print(f"‚ùå Ocorreu um erro inesperado:\n{e}")
                return

    # Garante a extens√£o .xlsx
    if not nome_arquivo.endswith(".xlsx"):
        nome_arquivo += ".xlsx"

    # Caminho de sa√≠da no Google Drive
    
    output_path = os.path.join('/content/drive/MyDrive/Estagio-SVGrad/Sa√≠das da Interface/Planilhas de Dados', nome_arquivo)
    
    try:
        # print("\nüîÑ Salvando arquivo concatenado...")
        with pd.ExcelWriter(output_path, engine="openpyxl") as writer:
            if not jupiter:
                df_salas.to_excel(writer, sheet_name="Salas", index=False)
            
            for sh in range(len(files)):
                files[sh].to_excel(writer, sheet_name=sheets[sh], index=False)
        
        print(f"\n‚úÖ Arquivo {nome_arquivo} criado com sucesso!")
        print(f"Local: {output_path}")
        
    except PermissionError:
        print(f"‚ùå N√£o foi poss√≠vel salvar o arquivo {nome_arquivo}")
        print("Verifique se ele est√° aberto em outro programa e tente novamente.")
    except Exception as e:
        print(f"‚ùå Ocorreu um erro inesperado:\n{e}")
# def concat_df(SME, SMA, SCC, SSC, salas, nome_arquivo, ano, jupiter, outros):
#     # Crio uma vari√°vel para listar os arquivos que ser√£o concatenados.
#     files = []
#     # Caso eu n√£o esteja concatenando os arquivos para a base do J√∫piterWeb:
#     if not jupiter:
#         # Leio a planilha com os dados das salas e salvo em um dataframe separado.
#         df_salas = ler_df(salas)

#         # Defino uma lista com os nomes dos arquivos a serem concatenados.
#         name_files = [SME, SMA, SCC, SSC, outros]

#         # Para cada nome de arquivo:
#         for name in name_files:
#             # Leio e salvo o arquivo em uma vari√°vel.
#             df = ler_df(name)

#             # Defino uma vari√°vel com o nome de um cabe√ßalho para ser encontrado, caso o cabe√ßalho n√£o seja a primeira linha da planilha.
#             header_name = 'Disciplina (c√≥digo)'

#             header_found = False
#             # Para cada linha e c√©lula da primeira coluna do dataframe:
#             for i, valor in enumerate(df.loc[:,df.columns[0]]):
#                 # Se o valor da c√©lula for o nome do cabe√ßalho que estou procurando:
#                 if valor == header_name:
#                     # Salvo o n√∫mero da linha do cabe√ßalho.
#                     header_row = i+1

#                     # Chamo a fun√ß√£o que ler√° o dataframe da forma correta e o deixar√° no formato padronizado.
#                     df_padronizado = padroniza_dataframe(name, header_row, ano)

#                     # Caso o dataframe n√£o esteja vazio, isto √©, se o arquivo foi lido corretamente e n√£o tinha nenhum erro aparente:
#                     if not df_padronizado.empty:
#                         # Adiciono o dataframe na lista dos que ser√£o concatenados.
#                         files.append(df_padronizado)
#                     # Caso tenha ocorrido um erro, retorno para a fun√ß√£o anterior, onde o usu√°rio verificar√° os arquivos selecionados.
#                     else:
#                         messagebox.showerror(f"Erro no arquivo",
#                                                 (
#                                                     f"O arquivo '{name}' n√£o pode ser lido, est√° vazio, ou n√£o foram marcadas as "
#                                                     f"disciplinas a serem alocadas. Verifique-o."
#                                                 )
#                                              )
#                         return

#                     # Se o cabe√ßalho foi encontrado, n√£o h√° motivo para continuar buscando, ent√£o encerro o loop dessa busca.
#                     header_found = True
#                     break

#             if not header_found:
#                 messagebox.showerror("Erro de Cabe√ßalho", 
#                                         (
#                                             f"A coluna '{header_name}' n√£o foi encontrada no arquivo {os.path.basename(name)}. "
#                                             "Verifique o cabe√ßalho do arquivo de entrada."
#                                         )
#                                     )
#                 return
#         # Com os arquivos lidos, salvo os nomes predeterminados das planilhas.
#         sheets = ["SME", "SMA", "SCC", "SSC", "Outros"]

#     # Para o caso de concatenando os arquivos para a base do J√∫piter:
#     else:
#         # Defino uma lista com os nomes dos arquivos a serem concatenados.
#         name_files = [SME, SMA, SCC, SSC]

#         # Adiciono os nomes dos arquivos dos outros institutos a essa lista de nomes.
#         name_files.extend(outros)

#         sheets = []

        
#     # Para cada nome de arquivo de outros institutos:
#         for name in name_files:
#             # Leio e salvo o arquivo em uma vari√°vel.
#             df = ler_df(name)

#             try:
#                 # Salvo a sigla das disciplinas daquele instituto. Eu considerei como sigla os 3 primeiros caracteres do nome de uma disciplina.
#                 # Ex: SME0230 pertence ao departamento do SME, 7600005 pertence ao departamento 760, e assim por diante.
#                 new_name = str(df.loc[0, 'Disciplina'])[:3]

#             except KeyError as e:
#                 coluna_faltando = str(e).strip("'")
#                 messagebox.showerror("Erro de Cabe√ßalho", 
#                                         (
#                                             f"A coluna 'Disciplina' n√£o foi encontrada no arquivo {os.path.basename(name)}. "
#                                             "Verifique o cabe√ßalho do arquivo de entrada."
#                                         )
#                                     )
#                 return

#             except Exception as e:
#                 # Caso ocorra algum erro, alerto o usu√°rio.
#                 messagebox.showerror("Erro inesperado", f"Ocorreu um erro inesperado:\n\n{e}")
#                 return
        
#             # Com o arquivo lido, salvo a sigla do instituto na lista de siglas.
#             sheets.append(new_name)

#             # Salvo o dataframe em na lista dos arquivos que ser√£o concatenados.
#             files.append(df)


#     # Com todos os dados obtidos e padronizados, verifico se o nome da base de dados termina com '.xlsx':
#     if not nome_arquivo.endswith(".xlsx"):
#         # Em caso negativo, adiciono essa terminologia.
#         nome_arquivo = nome_arquivo + ".xlsx"


#     # Com todos os dados obtidos e padronizados, verifico se o nome da base de dados termina com '.xlsx':
#     if not nome_arquivo.endswith(".xlsx"):
#         # Em caso negativo, adiciono essa terminologia.
#         nome_arquivo = nome_arquivo + ".xlsx"

#     try:
#         # Para finalmente concatenar os arquivos lidos, defino o nome da base de dados com o nome dispon√≠vel.
#         with pd.ExcelWriter(os.path.join(saidas, nome_arquivo), engine="openpyxl") as writer:
#             # Caso a base sendo definida n√£o for a do J√∫piter, preciso incluir a planilha de salas no arquivo.
#             if not jupiter:
#                 df_salas.to_excel(writer, sheet_name="Salas", index=False)
    
#             # Incluo todas as planilhas com as aulas dos departamentos no arquivo.
#             for sh in range(len(files)):
#                 files[sh].to_excel(writer, sheet_name=sheets[sh], index=False)
    
#         # Com o processo terminado, mostro uma mensagem confirmando que o arquivo foi criado com sucesso.
#         messagebox.showinfo("Sucesso!", f"Arquivo {nome_arquivo} criado com sucesso!\nVerifique a pasta {saidas} para encontr√°-lo.")

#     except PermissionError as e:
#         if e.errno == 13:  # Erro de permiss√£o (arquivo aberto ou bloqueado)
#             messagebox.showerror("Erro de Permiss√£o", 
#                                     (
#                                         f"N√£o foi poss√≠vel salvar o arquivo {nome_arquivo}. "
#                                         "Verifique se ele est√° aberto em outro programa (como o Excel) e tente novamente."
#                                     )
#                                 )
#             return
#         else:
#             messagebox.showerror("Erro", f"Erro de permiss√£o:\n\n{str(e)}")
#             return

#     except KeyError as e:
#         coluna_faltando = str(e).strip("'")
#         messagebox.showerror("Erro de Cabe√ßalho", 
#                                         (
#                                             f"A coluna 'Disciplina' n√£o foi encontrada no arquivo {os.path.basename(name)}. "
#                                             "Verifique o cabe√ßalho do arquivo de entrada."
#                                         )
#                                     )
#         return
    
#     except Exception as e:
#         # Para qualquer outro erro
#         messagebox.showerror("Erro inesperado!", f"Ocorreu um erro inesperado:\n\n{str(e)}")
#         return

"""## Construir base de dados completa"""

# Fun√ß√£o que cria a base de dados completa, isto √©, a que faz o cruzamento dos dados das aulas com os dados do J√∫piterWeb.
# Seu par√¢metro 'pior_caso' refere-se a uma vari√°vel booleana, que recebe o valor False caso seja o momento de criar a Base de Dados Completa,
# cruzando os dados das aulas com os dados do J√∫piterWeb, e True caso seja o momento de criar a Base de Dados de Pior Caso.
# A Base de Dados de Pior Caso faz uma simples compara√ß√£o entre os dados de dois anos distintos, misturando dados dos dois anos para
# montar uma an√°lise com os maiores n√∫meros de inscritos desses anos.

import pandas as pd
import os
import subprocess
import sys
from google.colab import files
from IPython.display import clear_output

def base_dados(pior_caso):
    """
    Fun√ß√£o para constru√ß√£o de base de dados no Google Colab
    Par√¢metro:
    - pior_caso: booleano que indica se √© para criar base de pior caso (True) ou base normal (False)
    """

    clear_output(wait=True)
    print(f"=== CONSTRUIR {'BASE DE DADOS DE PIOR CASO' if pior_caso else 'BASE DE DADOS DO MODELO'} ===")

    # Fun√ß√£o auxiliar para upload com mensagem espec√≠fica
    def fazer_upload(mensagem):
        print(f"\n{mensagem}")
        print("Por favor, fa√ßa o upload do arquivo:")
        uploaded = files.upload()
        if not uploaded:
            print("‚ùå Nenhum arquivo foi selecionado!")
            return None
        # Retorna o primeiro arquivo carregado
        return next(iter(uploaded))

    # Dicion√°rio para armazenar os arquivos carregados
    arquivos = {}

    if not pior_caso:
        # Caso normal: pede 4 arquivos
        print("\nüìÇ Selecione os arquivos necess√°rios:")
        arquivos['base'] = fazer_upload("1. Planilha dos dados das aulas")
        arquivos['jptr'] = fazer_upload("2. Planilha dos dados do J√∫piter")
        arquivos['ing'] = fazer_upload("3. Planilha dos dados dos ingressantes")
        arquivos['esp'] = fazer_upload("4. Planilha com os inscritos das disciplinas com espelho")
    else:
        # Caso pior caso: pede 2 arquivos
        print("\nüìÇ Selecione as bases para compara√ß√£o:")
        arquivos['base1'] = fazer_upload("1. Base de dados mais recente")
        arquivos['base2'] = fazer_upload("2. Base de dados mais antiga")

    # Solicitar nome do arquivo de sa√≠da
    nome_arquivo = input("\nDigite o nome para a nova base de dados (sem extens√£o): ").strip()

    # Valida√ß√£o dos inputs
    def validar_arquivo(arquivo, nome):
        if arquivo is None:
            print(f"‚ùå Por favor, forne√ßa o {nome}")
            return False
        return True

    if not pior_caso:
        if not all([
            validar_arquivo(arquivos['base'], "arquivo dos dados das aulas"),
            validar_arquivo(arquivos['jptr'], "arquivo dos dados do J√∫piter"),
            validar_arquivo(arquivos['ing'], "arquivo dos dados dos ingressantes"),
            validar_arquivo(arquivos['esp'], "arquivo dos inscritos em disciplinas com espelho"),
            nome_arquivo
        ]):
            input("\nPressione Enter para tentar novamente...")
            return base_dados(pior_caso)
    else:
        if not all([
            validar_arquivo(arquivos['base1'], "base de dados mais recente"),
            validar_arquivo(arquivos['base2'], "base de dados mais antiga"),
            nome_arquivo
        ]):
            input("\nPressione Enter para tentar novamente...")
            return base_dados(pior_caso)

    # Garante a extens√£o .xlsx
    if not nome_arquivo.endswith(".xlsx"):
        nome_arquivo += ".xlsx"

    # Caminho de sa√≠da no Google Drive
    output_path = os.path.join('/content/drive/MyDrive/Estagio-SVGrad/Sa√≠das da Interface/Planilhas de Dados', nome_arquivo)

    try:
        if not pior_caso:
            print("\nüîÑ Processando dados para criar base do modelo...")
            # Executa o script de processamento
            result = subprocess.run(
                [sys.executable, "jupiter sheet maker.py",
                 arquivos['base'], arquivos['jptr'], arquivos['ing'], arquivos['esp'], output_path],
                check=True,
                capture_output=True,
                text=True
            )

            if result.returncode == 0:
                print(f"\n‚úÖ Base de dados criada com sucesso em:\n{output_path}")
            else:
                print(f"\n‚ùå Erro ao executar o script:\n{result.stderr}")
        else:
            print("\nüîÑ Criando base de pior caso...")
            # L√™ as bases de dados
            df1 = pd.read_excel(arquivos['base1'], sheet_name=["Salas", "SME", "SMA", "SCC", "SSC", "Outros"])
            df2 = pd.read_excel(arquivos['base2'], sheet_name=["Salas", "SME", "SMA", "SCC", "SSC", "Outros"])

            # Chama a fun√ß√£o para criar base de pior caso
            df_pior_caso = base_pior_caso(df1, df2, ["Salas", "SME", "SMA", "SCC", "SSC", "Outros"])

            # Salva o resultado
            with pd.ExcelWriter(output_path, engine="openpyxl") as writer:
                for sh, df_sh in df_pior_caso.items():
                    df_sh.to_excel(writer, sheet_name=sh, index=False)

            print(f"\n‚úÖ Base de pior caso criada com sucesso em:\n{output_path}")

    except PermissionError:
        print(f"\n‚ùå N√£o foi poss√≠vel salvar o arquivo {nome_arquivo}")
        print("Verifique se ele est√° aberto em outro programa e tente novamente.")
    except subprocess.CalledProcessError as e:
        print(f"\n‚ùå Erro ao executar o script:")
        print(e.stderr if e.stderr else "Erro desconhecido")
    except Exception as e:
        print(f"\n‚ùå Ocorreu um erro inesperado:")
        print(str(e))
    finally:
        input("\nPressione Enter para voltar ao menu principal...")
# def base_dados(pior_caso):

#     # Crio uma nova janela em cima da janela principal da interface.
#     nova_janela = tk.Toplevel(root)

#     # Baseado em qual base de dados ser√° criada, defino um nome diferente para a janela.
#     if not pior_caso:
#         nova_janela.title("Construir Base de Dados do Modelo")

#     else:
#         nova_janela.title("Construir Base de Dados de Pior Caso")

#     # Crio o frame para armazenar os bot√µes e outros campos da nova janela.
#     frame = tk.Frame(nova_janela)
#     frame.pack(pady=10, padx=10)

#     # Caso n√£o esteja fazendo a base de pior caso:
#     if not pior_caso:
#         # Defino algumas vari√°veis para salvar o arquivo com a base de dados das aulas,
#         # a base de dados do J√∫piterWeb, e a base de dados dos ingressantes.
#         arquivo_base = tk.StringVar(value="Selecione a planilha dos dados das aulas")
#         arquivo_jptr = tk.StringVar(value="Selecione a planilha dos dados do j√∫piter")
#         arquivo_ing = tk.StringVar(value="Selecione a planilha dos dados dos ingressantes")
#         arquivo_esp = tk.StringVar(value="Selecione a planilha com os inscritos das disciplinas com espelho")
#     # Caso esteja fazendo a base de pior caso:
#     else:
#         # Defino as vari√°veis para salvar os arquivos das bases de dados.
#         arquivo_base1 = tk.StringVar(value="Selecione a base de dados mais recente")
#         arquivo_base2 = tk.StringVar(value="Selecione a base de dados mais antiga")

#     # Defino uma vari√°vel para salvar o nome da nova base de dados, seja ela a de pior caso ou n√£o.
#     nome_arquivo = tk.StringVar()

#     # Fun√ß√µes para selecionar um arquivo. Como a fun√ß√£o 'm√£e' (base_dados) pode ser utilizada em duas ocasi√µes diferentes,
#     # essas fun√ß√µes para selecionar arquivos tamb√©m s√£o diferentes dependendo da ocasi√£o.
#     def selecionar_um():
#         # Caso n√£o esteja fazendo a base de pior caso:
#         if not pior_caso:
#             # O usu√°rio seleciona o arquivo contendo a base de dados das aulas.
#             arquivo = filedialog.askopenfilename(title="Selecione a planilha dos dados das aulas")

#             # Se um arquivo foi selecionado:
#             if arquivo:
#                 # Salvo o caminho do arquivo.
#                 arquivo_base.set(arquivo)
#         # Caso esteja fazendo a base de pior caso:
#         else:
#             # O usu√°rio seleciona o arquivo contendo a base de dados mais recente.
#             arquivo = filedialog.askopenfilename(title="Selecione a base de dados mais recente")

#             # Se um arquivo foi selecionado:
#             if arquivo:
#             # Salvo o caminho do arquivo.
#                 arquivo_base1.set(arquivo)
#     def selecionar_dois():
#         if not pior_caso:
#             arquivo = filedialog.askopenfilename(title="Selecione a planilha dos dados do j√∫piter")
#             if arquivo:
#                 arquivo_jptr.set(arquivo)
#         else:
#             arquivo = filedialog.askopenfilename(title="Selecione a base de dados mais antiga")
#             if arquivo:
#                 arquivo_base2.set(arquivo)

#     # Caso n√£o esteja fazendo a base de pior caso:
#     if not pior_caso:
#         # Defino uma outra fun√ß√£o para selecionar o arquivo com a base de dados dos ingressantes, com o mesmo funcionamento das demais.
#         def selecionar_tres():
#             arquivo = filedialog.askopenfilename(title="Selecione a planilha dos dados dos ingressantes")
#             if arquivo:
#                 arquivo_ing.set(arquivo)
#         # Defino uma fun√ß√£o para selecionar o arquivo com os inscritos das disciplinas com espelho.
#         def selecionar_quatro():
#             arquivo = filedialog.askopenfilename(title="Selecione a planilha com os inscritos das disciplinas com espelho")
#             if arquivo:
#                 arquivo_esp.set(arquivo)

#     # Caso n√£o esteja fazendo a base de pior caso:
#     if not pior_caso:
#         # Defino legendas e bot√µes na janela para o usu√°rio definir os arquivos necess√°rios.
#         lbl_base = tk.Label(frame, text="Selecione a planilha dos dados das aulas")
#         lbl_base.grid(row=0, column=0, pady=5, sticky="w")
#         btn_selecionar_base = tk.Button(frame, textvariable=arquivo_base, command=selecionar_um, wraplength=250, width=40)
#         btn_selecionar_base.grid(row=0, column=1, padx=5, pady=5)

#         lbl_jptr = tk.Label(frame, text="Selecione a planilha dos dados do j√∫piter")
#         lbl_jptr.grid(row=1, column=0, pady=5, sticky="w")
#         btn_selecionar_jptr = tk.Button(frame, textvariable=arquivo_jptr, command=selecionar_dois, wraplength=250, width=40)
#         btn_selecionar_jptr.grid(row=1, column=1, padx=5, pady=5)

#         lbl_ing = tk.Label(frame, text="Selecione a planilha dos dados dos ingressantes")
#         lbl_ing.grid(row=2, column=0, pady=5, sticky="w")
#         btn_selecionar_ing = tk.Button(frame, textvariable=arquivo_ing, command=selecionar_tres, wraplength=250, width=40)
#         btn_selecionar_ing.grid(row=2, column=1, padx=5, pady=5)

#         lbl_esp = tk.Label(frame, text="Selecione a planilha com os inscritos das disciplinas com espelho")
#         lbl_esp.grid(row=3, column=0, pady=5, sticky="w")
#         btn_selecionar_esp = tk.Button(frame, textvariable=arquivo_esp, command=selecionar_quatro, wraplength=250, width=40)
#         btn_selecionar_esp.grid(row=3, column=1, padx=5, pady=5)

#     # Caso esteja fazendo a base de pior caso:
#     else:
#         # Defino legendas e bot√µes na janela para o usu√°rio definir os arquivos necess√°rios.
#         lbl_base1 = tk.Label(frame, text="Selecione a base de dados mais recente")
#         lbl_base1.grid(row=0, column=0, pady=5, sticky="w")
#         btn_selecionar_base1 = tk.Button(frame, textvariable=arquivo_base1, command=selecionar_um, wraplength=250, width=40)
#         btn_selecionar_base1.grid(row=0, column=1, padx=5, pady=5)

#         lbl_base2 = tk.Label(frame, text="Selecione a base de dados mais antiga")
#         lbl_base2.grid(row=1, column=0, pady=5, sticky="w")
#         btn_selecionar_base2 = tk.Button(frame, textvariable=arquivo_base2, command=selecionar_dois, wraplength=250, width=40)
#         btn_selecionar_base2.grid(row=1, column=1, padx=5, pady=5)

#     # Defino a legenda e o campo na janela para o usu√°rio inserir o nome da nova base de dados.
#     lbl_arq = tk.Label(frame, text="Insira o nome para a nova base de dados:")
#     lbl_arq.grid(row=4, column=0, sticky="w", pady=5)
#     campo_arq = tk.Entry(frame, textvariable=nome_arquivo)
#     campo_arq.grid(row=4, column=1, pady=5)


#     # Defino uma fun√ß√£o que salva os valores das vari√°veis contendo o nome dos arquivos escolhidos.
#     def salvar_valores():
#         # Caso n√£o esteja fazendo a base de pior caso:
#         if not pior_caso:
#             # Todas as condi√ß√µes a seguir seguem a l√≥gica de que, se um arquivo n√£o foi selecionado, uma janela avisando o ocorrido
#             # aparece, pedindo para o usu√°rio selecionar um arquivo no campo requerido.

#             if not arquivo_base.get() or arquivo_base.get() == "Selecione a planilha dos dados das aulas":
#                 messagebox.showwarning("Aviso", "Por favor, selecione a planilha dos dados das aulas.")
#                 return
#             if not arquivo_jptr.get() or arquivo_jptr.get() == "Selecione a planilha dos dados do j√∫piter":
#                 messagebox.showwarning("Aviso", "Por favor, selecione a planilha dos dados do j√∫piter.")
#                 return
#             if not arquivo_ing.get() or arquivo_ing.get() == "Selecione a planilha dos dados dos ingressantes":
#                 messagebox.showwarning("Aviso", "Por favor, selecione a planilha dos dados dos ingressantes.")
#                 return
#             if not arquivo_esp.get() or arquivo_esp.get() == "Selecione a planilha com os inscritos das disciplinas com espelho":
#                 messagebox.showwarning("Aviso", "Por favor, selecione a planilha com os inscritos das disciplinas com espelho.")
#                 return

#         # Caso esteja fazendo a base de pior caso:
#         else:
#             # Todas as condi√ß√µes a seguir seguem a l√≥gica de que, se um arquivo n√£o foi selecionado, uma janela avisando o ocorrido
#             # aparece, pedindo para o usu√°rio selecionar um arquivo no campo requerido.
#             if not arquivo_base1.get() or arquivo_base1.get() == "Selecione a base de dados mais recente":
#                 messagebox.showwarning("Aviso", "Por favor, selecione a primeira base de dados.")
#                 return
#             if not arquivo_base2.get() or arquivo_base2.get() == "Selecione a base de dados mais antiga":
#                 messagebox.showwarning("Aviso", "Por favor, selecione a segunda base de dados.")
#                 return

#         # Crio uma vari√°vel auxiliar para salvar o nome da nova base de dados dada pelo usu√°rio.
#         nome = nome_arquivo.get()

#         # Se o usu√°rio n√£o forneceu um nome para a nova base de dados:
#         if not nome:
#             # Uma janela alertando o ocorrido √© aberta.
#             messagebox.showwarning("Aviso", "Por favor, insira o nome da nova base de dados.")
#             return

#         # Verifico se o nome da nova base de dados termina com '.xlsx':
#         if not nome.endswith(".xlsx"):
#             # Em caso negativo, adiciono essa terminologia.
#             nome = nome + ".xlsx"


#         # Caso n√£o esteja fazendo a base de pior caso:
#         if not pior_caso:
#             # Tento executar o script do c√≥digo respons√°vel em cruzar os dados das aulas com os do J√∫piter.
#             try:
#                 file1 = arquivo_base.get()
#                 file2 = arquivo_jptr.get()
#                 file3 = arquivo_ing.get()
#                 file4 = arquivo_esp.get()
#                 # subprocess(["python", "jupiter sheet maker.py", [df_filename1, df_filename2, df_filename3]])
#                 subprocess.run(
#                     # ["python", "jupiter sheet maker.py", file1, file2, file3, file4, nome],
#                     [sys.executable, "jupiter sheet maker.py", file1, file2, file3, file4, nome],
#                     check=True,
#                     capture_output=True,
#                     text=True
#                     )
                
#                 # Com o processo terminado, mostro uma mensagem confirmando que o arquivo foi criado com sucesso.
#                 messagebox.showinfo("Sucesso!", f"Base de dados para o modelo criada com sucesso. Verifique o arquivo {nome}.")
                

#             # Caso ocorra algum erro durante a execu√ß√£o do script, uma janela alertando o erro √© apresentada para o usu√°rio.
#             except subprocess.CalledProcessError as e:
#                 if e.returncode == 1:
#                     msg = e.stderr.strip() if e.stderr else "Erro desconhecido."
#                     messagebox.showerror("Erro", f"Erro ao executar o script. Verifique os arquivos de entrada.\n\n{msg}")
#                 elif e.returncode == 2:
#                     msg = e.stderr.strip() if e.stderr else "Erro desconhecido."
#                     messagebox.showerror("Erro", f"Erro de permiss√£o. Verifique se o arquivo {nome} est√° aberto em outro programa.\n\n{msg}")
#                 elif e.returncode == 4:
#                     msg = e.stderr.strip() if e.stderr else "Erro desconhecido."
#                     messagebox.showerror("Erro", f"Erro ao executar o script:\n\n{msg}")
#                 else:
#                     messagebox.showerror("Erro", f"Erro inesperado: {e}")
#                 return
            
#             # Caso um erro inesperado ocorra, uma janela alertando o erro √© apresentada para o usu√°rio.
#             except Exception as e:
#                 messagebox.showerror("Erro", f"Erro inesperado: {e}")
#                 return
            
            
#         # Caso esteja fazendo a base de pior caso:
#         else:
#             # Leio os dois dataframes fornecidos pelo usu√°rio.
#             df1 = pd.read_excel(arquivo_base1.get(), sheet_name=["Salas", "SME", "SMA", "SCC", "SSC", "Outros"])
#             df2 = pd.read_excel(arquivo_base2.get(), sheet_name=["Salas", "SME", "SMA", "SCC", "SSC", "Outros"])

#             # Chamo a fun√ß√£o que faz um dataframe com o maior n√∫mero de inscritos de cada ano.
#             df_pior_caso = base_pior_caso(df1, df2, ["Salas", "SME", "SMA", "SCC", "SSC", "Outros"])
#             try:
#                 # Com a base de pior caso feita, salvo-a em um arquivo de Excel com o nome fornecido pelo usu√°rio.
#                 with pd.ExcelWriter(os.path.join(saidas, nome), engine="openpyxl") as writer:
#                     for sh, df_sh in df_pior_caso.items():
#                         df_sh.to_excel(writer, sheet_name=sh, index=False)
#                 # Com o processo terminado, mostro uma mensagem confirmando que o arquivo foi criado com sucesso.
#                 messagebox.showinfo("Sucesso!", f"Arquivo {nome} criado com sucesso!\nVerifique a pasta {saidas} para encontr√°-lo.")

#             except PermissionError as e:
#                 if e.errno == 13:  # Erro de permiss√£o (arquivo aberto ou bloqueado)
#                     messagebox.showerror("Erro de Permiss√£o", 
#                                             (
#                                                 f"N√£o foi poss√≠vel salvar o arquivo {nome_arquivo}. "
#                                                 "Verifique se ele est√° aberto em outro programa (como o Excel) e tente novamente."
#                                             )
#                                         )
#                     return
#                 else:
#                     messagebox.showerror("Erro", f"Erro de permiss√£o:\n\n{str(e)}")
#                     return
#             except Exception as e:
#                 # Para qualquer outro erro
#                 messagebox.showerror("Erro inesperado!", f"Ocorreu um erro inesperado:\n\n{str(e)}")
#                 return
    
            

#         # messagebox.showinfo("Sucesso", "Valores salvos com sucesso!")
#         # Terminada a cria√ß√£o da base de dados, destruo a janela de sele√ß√£o.
#         nova_janela.destroy()

#     # Defino um bot√£o e seu espa√ßo na janela para chamar a fun√ß√£o que salva os nomes dos arquivos.
#     btn_salvar = tk.Button(nova_janela, text="Criar base de dados", command=salvar_valores)
#     btn_salvar.pack(pady=10)

"""### Pior caso"""

# Fun√ß√£o que faz a an√°lise de pior caso.
# Note que df1 deve sempre ser a base de dados mais recente, enquanto df2 deve sempre ser a base de dados mais antiga.
def base_pior_caso(df1, df2, sheets):
    """
    Fun√ß√£o para criar base de dados de pior caso comparando duas bases
    Par√¢metros:
    - df1: DataFrame da base mais recente (dicion√°rio de DataFrames por sheet)
    - df2: DataFrame da base mais antiga (dicion√°rio de DataFrames por sheet)
    - sheets: Lista de nomes das planilhas a serem processadas
    Retorna:
    - Dicion√°rio de DataFrames com os valores de pior caso ou None em caso de erro
    """

    print("\nüîç Analisando bases para determinar pior caso...")

    try:
        # Processa cada planilha (exceto a primeira que √© 'Salas')
        for sh in sheets[1:]:
            # print(f"üìä Processando planilha: {sh}...")

            # Obt√©m as planilhas correspondentes de ambas as bases
            df1_sh = df1[sh]
            df2_sh = df2[sh]

            # Converte colunas de disciplinas para listas
            l1 = df1_sh['Disciplina (c√≥digo)'].tolist()
            l2 = df2_sh['Disciplina (c√≥digo)'].tolist()

            # Para cada disciplina na base mais recente
            for d in l1:
                if d in l2:
                    # Compara n√∫mero de vagas
                    vagas_df1 = df1_sh.loc[l1.index(d), 'Vagas por disciplina']
                    vagas_df2 = df2_sh.loc[l2.index(d), 'Vagas por disciplina']

                    if vagas_df1 < vagas_df2:
                        # Atualiza para o pior caso
                        df1_sh.loc[l1.index(d), 'Vagas por disciplina'] = vagas_df2
                        df1_sh.loc[l1.index(d), 'Ano dos dados'] = df2_sh.loc[l2.index(d), 'Ano dos dados']
                        # print(f"  ‚ö†Ô∏è Atualizada disciplina {d} para pior caso: {vagas_df2} vagas")

        # print("‚úÖ An√°lise de pior caso conclu√≠da com sucesso!")
        return df1

    except KeyError as e:
        coluna_faltando = str(e).strip("'")
        print(f"\n‚ùå Erro: Coluna '{coluna_faltando}' n√£o encontrada")
        print("Verifique se os arquivos possuem a estrutura esperada:")
        print("- Coluna 'Disciplina (c√≥digo)' para identificar as disciplinas")
        print("- Coluna 'Vagas por disciplina' com os n√∫meros de inscritos")
        print("- Coluna 'Ano dos dados' com o ano de refer√™ncia")
        return None

    except Exception as e:
        print(f"\n‚ùå Ocorreu um erro inesperado durante a an√°lise:")
        print(str(e))
        return None
# def base_pior_caso(df1, df2, sheets):

#     # df1 = pd.read_excel(df1_name, sheet_name=sheets)
#     # df2 = pd.read_excel(df1_name, sheet_name=sheets)
#     try:
#     # Para cada planilha na base de dados mais recente:
#         # for sh in df1.sheet_names[1:]:
#         for sh in sheets[1:]:
#             # Considerando que df1 e df2 possuem as mesmas planilhas (ou, pelo menos, deveriam), crio duas vari√°veis auxiliares
#             # para salvar os dados a mesma planilha de ambas as bases.
#             df1_sh = df1[sh]
#             df2_sh = df2[sh]

#             # Crio tamb√©m duas vari√°veis para salvar as colunas de disciplinas das bases como listas.
#             l1 = df1_sh['Disciplina (c√≥digo)'].tolist()
#             l2 = df2_sh['Disciplina (c√≥digo)'].tolist()

#             # Para cada disciplina 'd' na lista de disciplinas da base de dados mais recente:
#             for d in l1:
#                 # Verifico se 'd' est√° na lista de disciplinas da base de dados mais antiga:
#                 if d in l2:
#                     # Em caso positivo, verifico se o n√∫mero de inscritos do ano mais recente da disciplina √© menor
#                     # que o n√∫mero de inscritos do ano mais antigo da disciplina.
#                     if df1[sh].loc[l1.index(d), 'Vagas por disciplina'] < df2[sh].loc[l2.index(d), 'Vagas por disciplina']:
#                         # Se for o caso, ent√£o no ano anterior houveram mais inscritos, isto √©, no ano mais recente, pode ser que
#                         # o n√∫mero de inscritos chegue at√© esse valor ou o ultrapasse.
#                         # Por conta disso, atualizo o n√∫mero de inscritos e o ano dos dados da disciplina 'd' na base mais recente.
#                         df1[sh].loc[l1.index(d), 'Vagas por disciplina'] = df2[sh].loc[l2.index(d), 'Vagas por disciplina']
#                         df1[sh].loc[l1.index(d), 'Ano dos dados'] = df2[sh].loc[l2.index(d), 'Ano dos dados']

#     except KeyError as e:
#         coluna_faltando = str(e).strip("'")
#         messagebox.showerror("Erro de Cabe√ßalho", 
#                                 (
#                                     f"A coluna '{coluna_faltando}' n√£o foi encontrada em um dos arquivos. "
#                                     "Verifique o cabe√ßalho dos arquivos de entrada."
#                                 )
#                             )
#         return
    
#     except Exception as e:
#         # Caso ocorra algum erro, alerto o usu√°rio.
#         messagebox.showerror("Erro inesperado", f"Ocorreu um erro inesperado:\n\n{e}")
#         return
#     # Ap√≥s concluir a an√°lise, retorno a base de dados atualizada.
#     return df1

"""## Executar"""

# Fun√ß√£o que faz a verifica√ß√£o de dados e execu√ß√£o do modelo.
def execute():
    """
    Fun√ß√£o para verificar dados e executar modelo no Google Colab
    Oferece op√ß√µes para:
    1. Verificar dados
    2. Executar modelo
    """
    
    clear_output(wait=True)
    print("=== VERIFICAR DADOS E EXECUTAR MODELO ===")
    
    # Fun√ß√£o auxiliar para upload
    def fazer_upload():
        print("\nüìÇ Por favor, fa√ßa o upload da base de dados:")
        uploaded = files.upload()
        if not uploaded:
            print("‚ùå Nenhum arquivo foi selecionado!")
            return None
        return next(iter(uploaded))
    
    # Solicitar arquivo de base de dados
    arquivo = fazer_upload()
    if arquivo is None:
        input("\nPressione Enter para tentar novamente...")
        return execute()
    
    print(f"\nüìÑ Arquivo selecionado: {arquivo}")
    
    while True:
        clear_output(wait=True)
        print(f"=== MENU - ARQUIVO: {arquivo} ===")
        print("1. Verificar dados")
        print("2. Executar modelo")
        print("3. Selecionar outro arquivo")
        print("4. Voltar ao menu principal")
        print("===============================")
        
        opcao = input("\nSelecione uma op√ß√£o: ").strip()
        
        if opcao == "1":
            # Verifica√ß√£o de dados
            print("\nüîç Iniciando verifica√ß√£o de dados...")
            try:
                result = subprocess.run(
                    [sys.executable, "verificar_dados.py", arquivo],
                    check=True,
                    capture_output=True,
                    text=True
                )
                print("\n‚úÖ Verifica√ß√£o conclu√≠da!")
                print(result.stdout)
            except subprocess.CalledProcessError as e:
                print("\n‚ùå Erro durante a verifica√ß√£o:")
                print(e.stderr if e.stderr else "Erro desconhecido")
            input("\nPressione Enter para continuar...")
            
        elif opcao == "2":
            # Execu√ß√£o do modelo
            print("\n‚öôÔ∏è Preparando para executar o modelo...")
            Novo_edit_config(file_name=arquivo)  # Supondo que esta fun√ß√£o tamb√©m foi adaptada
            return
            
        elif opcao == "3":
            # Selecionar novo arquivo
            arquivo = fazer_upload()
            if arquivo is None:
                input("\nPressione Enter para tentar novamente...")
            
        elif opcao == "4":
            # Voltar ao menu principal
            return
            
        else:
            print("‚ùå Op√ß√£o inv√°lida! Tente novamente.")
            input("\nPressione Enter para continuar...")

# def execute():
#     # Crio uma nova janela em cima da janela principal da interface.
#     nova_janela = tk.Toplevel(root)
#     nova_janela.geometry("+200+200")
#     nova_janela.title("Verificar Dados e Executar Modelo")

#     # Crio o frame para armazenar os bot√µes e outros campos da nova janela.
#     frame = tk.Frame(nova_janela)
#     frame.pack(pady=10, padx=10)

#     # Defino uma vari√°vel para salvar o arquivo com a base de dados para o modelo, seja ela a completa ou a de pior caso.
#     arquivo_selecionado1 = tk.StringVar(value="Selecione uma base de dados")

#     # Defino a fun√ß√£o para selecionar a base de dados.
#     def selecionar_arquivo1():
#         # O usu√°rio seleciona o arquivo contendo a base de dados das aulas.
#         arquivo = filedialog.askopenfilename(title="Selecione uma base de dados")

#         # Se um arquivo foi selecionado:
#         if arquivo:
#             # Salvo o caminho do arquivo.
#             arquivo_selecionado1.set(arquivo)



#     # Defino um bot√£o, e sua posi√ß√£o na janela, para o usu√°rio escolher a base de dados.
#     btn_selecionar1 = tk.Button(frame, textvariable=arquivo_selecionado1,
#                                 command=selecionar_arquivo1, wraplength=250, width=40)
#     btn_selecionar1.grid(row=0, column=0, padx=5, pady=5)


#     # Defino uma linha de separa√ß√£o horizontal na janela, separando o bot√£o de sele√ß√£o de arquivo do bot√£o de verifica√ß√£o de dados.
#     vd_separator = ttk.Separator(frame, orient="horizontal")
#     vd_separator.grid(row=2, column=0, sticky="ew", pady=(0, 10))

#     # Defino um bot√£o, e sua posi√ß√£o na janela, para o usu√°rio abrir o menu de verifica√ß√£o de dados.
#     vd1 = ttk.Button(frame, text="Selecionar Verifica√ß√£o de Dados",
#                      command=lambda: roda_script("verificar_dados.py", arquivo_selecionado1.get(), "", "", "", "", "", ""))
#     vd1.grid(row=4, column=0, pady=5)

#     # Defino uma linha de separa√ß√£o horizontal na janela, separando o bot√£o de verifica√ß√£o de dados do bot√£o de execu√ß√£o do modelo.
#     em_separator = ttk.Separator(frame, orient="horizontal")
#     em_separator.grid(row=5, column=0, sticky="ew", pady=(0,10))

#     # Defino um bot√£o, e sua posi√ß√£o na janela, para o usu√°rio abrir o menu de execu√ß√£o do modelo.
#     em = ttk.Button(frame, text="Selecionar Modelo", command=lambda: Novo_edit_config(file_name=arquivo_selecionado1.get()))
#     em.grid(row=6, column=0, pady=5)

"""### Roda Script"""

# Fun√ß√£o que roda um script em Python. Seus par√¢metros s√£o vari√°veis fornecidas pelo usu√°rio, como qual script
# o nome da base de dados que ser√° lida, e o peso das vari√°veis do modelo.
def roda_script(script, nome, peso_x, peso_y, peso_v, peso_z, alpha, pref):
    """
    Executa um script Python e exibe sua sa√≠da no Google Colab
    
    Par√¢metros:
    - script: Nome do script a ser executado
    - nome: Nome do arquivo de entrada principal
    - peso_x, peso_y, peso_v, peso_z, alpha, pref: Par√¢metros adicionais para o script
    """
    
    clear_output(wait=True)
    print(f"=== EXECUTANDO SCRIPT: {script} ===")
    print(f"Arquivo de entrada: {nome}")
    print("Par√¢metros:")
    print(f"- peso_x: {peso_x}")
    print(f"- peso_y: {peso_y}")
    print(f"- peso_v: {peso_v}")
    print(f"- peso_z: {peso_z}")
    print(f"- alpha: {alpha}")
    print(f"- pref: {pref}")
    print("\n" + "="*40 + "\n")
    
    try:
        # Configura o processo
        process = subprocess.Popen(
            [sys.executable, script, nome, str(peso_x), str(peso_y), 
             str(peso_v), str(peso_z), str(alpha), str(pref)],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
            bufsize=1,  # Buffer de linha
            universal_newlines=True
        )
        
        # Exibe a sa√≠da em tempo real
        print("üöÄ Iniciando execu√ß√£o...\n")
        print("-"*40)
        
        while True:
            output = process.stdout.readline()
            if output == '' and process.poll() is not None:
                break
            if output:
                print(output.strip())
        
        print("-"*40)
        
        # Verifica erros
        stderr = process.communicate()[1]
        return_code = process.returncode
        
        if return_code != 0:
            print("\n‚ùå ERRO DURANTE EXECU√á√ÉO:")
            print(stderr)
            
            if return_code == 1:
                print("\nüí° Dica: Verifique os arquivos de entrada e par√¢metros")
            elif return_code == 2:
                print(f"\nüí° Dica: Verifique se o arquivo {nome} est√° acess√≠vel")
        # else:
            # print("\n‚úÖ Script executado com sucesso!")
            
    except subprocess.CalledProcessError as e:
        print(f"\n‚ùå Erro ao executar o script (c√≥digo {e.returncode}):")
        print(e.stderr if e.stderr else "Erro desconhecido")
    except Exception as e:
        print(f"\n‚ùå Erro inesperado: {str(e)}")
    finally:
        input("\nPressione Enter para continuar...")
# def roda_script(script, nome, peso_x, peso_y, peso_v, peso_z, alpha, pref):

#     # Crio uma janela para mostrar a sa√≠da do script, como prints importantes e at√© sa√≠das de erros.
#     output_window = tk.Toplevel(root)
#     output_window.title("Sa√≠da do Script")
#     output_text = scrolledtext.ScrolledText(output_window, width=120, height=40)
#     output_text.pack()

#     # Tento executar o script escolhido pelo usu√°rio.
#     try:
#         # Executo o script utilizando subprocess.
#         process = subprocess.Popen(
#             # ["python", script, nome, peso_x, peso_y, peso_v, peso_z, alpha, pref],
#             [sys.executable, script, nome, peso_x, peso_y, peso_v, peso_z, alpha, pref],
#             stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True
#         )

#         # Capturo e exibo a sa√≠da linha por linha do script.
#         # Para cada linha da sa√≠da:
#         for line in iter(process.stdout.readline, ""):
#             # Verifico se a linha est√° vazia, isto √©, se cheguei no final da sa√≠da do script.
#             if line.strip():
#                 # Se n√£o cheguei, insiro a linha no final da janela.
#                 output_text.insert(tk.END, line)

#                 # Tamb√©m coloco para o rodap√© rolar automaticamente at√© o final da janela.
#                 output_text.see(tk.END)

#                 # Por fim, atualizo a interface para que o usu√°rio veja a linha mais recente da sa√≠da.
#                 root.update()

#         # Se algum erro ocorrer durante a execu√ß√£o do script, ele √© enviado para a vari√°vel stderr, e n√£o √© mostrado pela se√ß√£o anterior.
#         # Assim, salvo o poss√≠vel erro do script na vari√°vel stderr.
#         stderr = process.communicate()[1]

#         # Se ocorreu um erro, isto √©, se stderr n√£o √© uma vari√°vel vazia:
#         if stderr:
#             # Insiro a linha de erro no final da janela.
#             output_text.insert(tk.END, "\n[ERRO]:\n" + stderr)

#             # E rolo automaticamente at√© o final da janela.
#             output_text.see(tk.END)

#     # Caso ocorra algum erro durante a execu√ß√£o do script, uma janela alertando o erro √© apresentada para o usu√°rio.
#     except subprocess.CalledProcessError as e:
#         if e.returncode == 1:
#             messagebox.showerror("Erro", f"Erro ao executar o script. Verifique os arquivos de entrada.\n\nErro: {e}")
#         elif e.returncode == 2:
#             messagebox.showerror("Erro", f"Erro de permiss√£o. Verifique se o arquivo {nome} est√° aberto em outro programa.\n\nErro: {e}")
#         else:
#             messagebox.showerror("Erro", f"Erro inesperado: {e}")
#         return
    
#     # Caso um erro inesperado ocorra, uma janela alertando o erro √© apresentada para o usu√°rio.
#     except Exception as e:
#         messagebox.showerror("Erro", f"Erro inesperado: {e}")
#         return

#     # # Caso algum erro ocorra ao executar o script, alerto o usu√°rio inserindo o erro na janela de sa√≠da.
#     # except Exception as e:
#     #     output_text.insert(tk.END, f"\nErro ao executar o script: {e}")

"""### Novo Edit Configs"""

# Fun√ß√£o que cria uma nova janela para configurar os par√¢metros da verifica√ß√£o ou do modelo antes de chamar o script.
# Seus par√¢metros s√£o o nome da base de dados (file_name) e uma vari√°vel booleana 'verify', que recebe o valor True quando
# o menu √© de configura√ß√µes da Verifica√ß√£o dos Dados, e False quando o menu √© de configura√ß√µes para Executar o Modelo

def Novo_edit_config(file_name):
    """
    Menu para configurar par√¢metros do modelo no Google Colab
    Oferece op√ß√µes para usar configura√ß√µes recomendadas ou personalizadas
    """
    
    # Verifica√ß√£o do arquivo de entrada
    if not file_name or file_name == "Selecione uma base de dados":
        print("‚ùå Por favor, selecione uma base de dados v√°lida.")
        input("\nPressione Enter para voltar...")
        return
    
    # Par√¢metros recomendados
    PARAMS_RECOMENDADOS = {
        'peso_x': '1',
        'peso_y': '500',
        'peso_v': '1',
        'peso_z': '10',
        'alpha': '0.85',
        'pref': '500'
    }
    
    # Descri√ß√µes dos par√¢metros
    DESCRICOES = {
        'peso_x': "Peso de aloca√ß√£o (import√¢ncia da vari√°vel x_as no modelo)",
        'peso_y': "Peso de troca de sala (import√¢ncia de manter aulas na mesma sala)",
        'peso_v': "Peso de agrupamento (import√¢ncia de agrupar aulas do mesmo curso)",
        'peso_z': "Peso de superlota√ß√£o (import√¢ncia de evitar salas superlotadas)",
        'alpha': "√çndice de superlota√ß√£o (0-1, porcentagem de ocupa√ß√£o ideal)",
        'pref': "Peso para salas preferencialmente vazias"
    }
    
    # Dicas dos par√¢metros
    DICAS = {
        'peso_x': "Valor recomendado: 1\nQuanto maior, mais o modelo prioriza alocar todas as aulas",
        'peso_y': "Valor recomendado: 500\nQuanto maior, mais o modelo evita trocar salas para a mesma turma",
        'peso_v': "Valor recomendado: 1\nQuanto maior, mais o modelo tenta agrupar aulas do mesmo curso",
        'peso_z': "Valor recomendado: 10\nQuanto maior, mais o modelo evita superlota√ß√£o",
        'alpha': "Valor recomendado: 0.85\n(0.85 = 85% de ocupa√ß√£o ideal)\nValores mais altos permitem mais lota√ß√£o",
        'pref': "Valor recomendado: 500\nQuanto maior, mais o modelo evita usar salas preferenciais"
    }
    
    while True:
        clear_output(wait=True)
        print(f"=== CONFIGURA√á√ÉO DE PAR√ÇMETROS ===")
        print(f"Arquivo de entrada: {file_name}")
        print("\n1. Usar configura√ß√µes recomendadas")
        print("2. Personalizar configura√ß√µes")
        print("3. Voltar ao menu anterior")
        print("================================")
        
        opcao = input("\nSelecione uma op√ß√£o: ").strip()
        
        if opcao == "1":
            # Executar com par√¢metros recomendados
            print("\n‚öôÔ∏è Usando par√¢metros recomendados:")
            for param, valor in PARAMS_RECOMENDADOS.items():
                print(f"- {param}: {valor} ({DICAS[param].splitlines()[0]})")
            
            confirmar = input("\nConfirmar execu√ß√£o com estes par√¢metros? (s/n): ").lower()
            if confirmar == 's':
                roda_script(
                    script="Modelo Universal-Copy1.py",
                    nome=file_name,
                    peso_x=PARAMS_RECOMENDADOS['peso_x'],
                    peso_y=PARAMS_RECOMENDADOS['peso_y'],
                    peso_v=PARAMS_RECOMENDADOS['peso_v'],
                    peso_z=PARAMS_RECOMENDADOS['peso_z'],
                    alpha=PARAMS_RECOMENDADOS['alpha'],
                    pref=PARAMS_RECOMENDADOS['pref']
                )
                return
            else:
                input("\nOpera√ß√£o cancelada. Pressione Enter para continuar...")
                
        elif opcao == "2":
            # Menu de personaliza√ß√£o
            params_personalizados = PARAMS_RECOMENDADOS.copy()
            
            for param in PARAMS_RECOMENDADOS.keys():
                clear_output(wait=True)
                print(f"=== PERSONALIZAR PAR√ÇMETRO: {param.upper()} ===")
                print(f"\n{DESCRICOES[param]}")
                print(f"\nüí° {DICAS[param]}")
                
                while True:
                    novo_valor = input(f"\nDigite o valor para {param} (atual: {params_personalizados[param]}) ou 'padrao' para usar o recomendado: ").strip()
                    
                    if novo_valor.lower() == 'padrao':
                        params_personalizados[param] = PARAMS_RECOMENDADOS[param]
                        break
                    elif novo_valor:
                        # Valida√ß√£o b√°sica para valores num√©ricos
                        try:
                            if param == 'alpha':
                                valor = float(novo_valor)
                                if 0 <= valor <= 1:
                                    params_personalizados[param] = novo_valor
                                    break
                                else:
                                    print("‚ùå O valor deve estar entre 0 e 1")
                            else:
                                valor = float(novo_valor)  # Testa se √© n√∫mero
                                params_personalizados[param] = novo_valor
                                break
                        except ValueError:
                            print("‚ùå Por favor, digite um valor num√©rico v√°lido")
            
            # Mostrar resumo antes de executar
            clear_output(wait=True)
            print("=== PAR√ÇMETROS PERSONALIZADOS ===")
            for param, valor in params_personalizados.items():
                print(f"- {param}: {valor}")
            
            confirmar = input("\nConfirmar execu√ß√£o com estes par√¢metros? (s/n): ").lower()
            if confirmar == 's':
                roda_script(
                    script="Modelo Universal-Copy1.py",
                    nome=file_name,
                    peso_x=params_personalizados['peso_x'],
                    peso_y=params_personalizados['peso_y'],
                    peso_v=params_personalizados['peso_v'],
                    peso_z=params_personalizados['peso_z'],
                    alpha=params_personalizados['alpha'],
                    pref=params_personalizados['pref']
                )
                return
            else:
                input("\nOpera√ß√£o cancelada. Pressione Enter para continuar...")
                
        elif opcao == "3":
            return
        else:
            print("‚ùå Op√ß√£o inv√°lida!")
            input("\nPressione Enter para continuar...")
# def Novo_edit_config(file_name):

#     # Fa√ßo uma breve verifica√ß√£o para saber se foi fornecida uma base de dados.
#     if file_name == "Selecione uma base de dados":
#         # Se nenhum arquivo foi selecionado, uma janela avisando o ocorrido
#         # aparece, pedindo para o usu√°rio fornecer uma base de dados.
#         messagebox.showwarning("Aviso", "Por favor, selecione uma base de dados.")
#         return


#     # Crio uma nova janela em cima da janela principal da interface.
#     configs = tk.Toplevel(root)
#     configs.geometry("+360+150")
#     configs.title("Personalizar par√¢metros")

#     # Crio o frame para armazenar os bot√µes e outros campos da nova janela.
#     frame2 = tk.Frame(configs)
#     frame2.pack(pady=10, padx=10)

#     # Defino 'casais' de vari√°veis. Cada vari√°vel refere-se a um valor de um checkbox de uma linha.
#     # Ex: var11 refere-se ao valor do checkbox da primeira linha e da primeira coluna, enquanto
#     # var22 refere-se ao valor do checkbox da primeira linha e da segunda coluna.
#     var11 = IntVar()
#     var12 = IntVar()
#     var21 = IntVar()
#     var22 = IntVar()
#     var31 = IntVar()
#     var32 = IntVar()
#     var41 = IntVar()
#     var42 = IntVar()
#     var51 = IntVar()
#     var52 = IntVar()
#     var61 = IntVar()
#     var62 = IntVar()
#     # var71 = IntVar()
#     # var72 = IntVar()

#     # Defino uma fun√ß√£o que atualiza o estado de cada checkbox ap√≥s marcar, ou desmarcar, um deles.
#     def atualizar_estado():
#         # Se o checkbox da primeira linha e primeira coluna estiver marcado:
#         if var11.get():
#             # Desabilito o checkbox da primeira linha e segunda coluna.
#             checkbox12.config(state=DISABLED)
#         # Se ele n√£o estiver mais marcado:
#         else:
#             # Retorno o checkbox da primeira linha e segunda coluna ao normal.
#             checkbox12.config(state=NORMAL)
#         # Se o checkbox da primeira linha e segunda coluna estiver marcado:
#         if var12.get():
#             # Desabilito o checkbox da primeira linha e segunda coluna.
#             checkbox11.config(state=DISABLED)
#             # E habilito o campo correspondente para o usu√°rio inserir um valor.
#             peso_x.config(state=NORMAL)
#         # Se ele n√£o estiver mais marcado:
#         else:
#             # Retorno o checkbox da primeira linha e primeira coluna ao normal.
#             checkbox11.config(state=NORMAL)
#             # E deleto o conte√∫do inserido no campo, al√©m de desabilit√°-lo novamente.
#             peso_x.delete(0, "end")
#             peso_x.config(state=DISABLED)

#         # As demais condi√ß√µes s√£o an√°logas √†s anteriores.

#         if var21.get():
#             checkbox22.config(state=DISABLED)
#         else:
#             checkbox22.config(state=NORMAL)
#         if var22.get():
#             checkbox21.config(state=DISABLED)
#             peso_y.config(state=NORMAL)
#         else:
#             checkbox21.config(state=NORMAL)
#             peso_y.delete(0, "end")
#             peso_y.config(state=DISABLED)

#         if var31.get():
#             checkbox32.config(state=DISABLED)
#         else:
#             checkbox32.config(state=NORMAL)
#         if var32.get():
#             checkbox31.config(state=DISABLED)
#             peso_v.config(state=NORMAL)
#         else:
#             checkbox31.config(state=NORMAL)
#             peso_v.delete(0, "end")
#             peso_v.config(state=DISABLED)

#         if var41.get():
#             checkbox42.config(state=DISABLED)
#         else:
#             checkbox42.config(state=NORMAL)
#         if var42.get():
#             checkbox41.config(state=DISABLED)
#             peso_z.config(state=NORMAL)
#         else:
#             checkbox41.config(state=NORMAL)
#             peso_z.delete(0, "end")
#             peso_z.config(state=DISABLED)

#         if var51.get():
#             checkbox52.config(state=DISABLED)
#         else:
#             checkbox52.config(state=NORMAL)
#         if var52.get():
#             checkbox51.config(state=DISABLED)
#             alpha.config(state=NORMAL)
#         else:
#             checkbox51.config(state=NORMAL)
#             alpha.delete(0, "end")
#             alpha.config(state=DISABLED)

#         if var61.get():
#             checkbox62.config(state=DISABLED)
#         else:
#             checkbox62.config(state=NORMAL)
#         if var62.get():
#             checkbox61.config(state=DISABLED)
#             pref.config(state=NORMAL)
#         else:
#             checkbox61.config(state=NORMAL)
#             pref.delete(0, "end")
#             pref.config(state=DISABLED)

#         # Esse par de vari√°veis n√£o est√° separado com as demais por elas serem associadas com os √∫nicos valores necess√°rios
#         # tanto para a verifica√ß√£o dos dados, quanto para a execu√ß√£o do modelo, que s√£o o n√∫mero de alunos da p√≥s a serem
#         # considerados em disciplinas com espelho.
#         # if var71.get():
#         #     checkbox72.config(state=DISABLED)
#         # else:
#         #     checkbox72.config(state=NORMAL)
#         # if var72.get():
#         #     checkbox71.config(state=DISABLED)
#         #     qtd_pos.config(state=NORMAL)
#         # else:
#         #     checkbox71.config(state=NORMAL)
#         #     qtd_pos.delete(0, "end")
#         #     qtd_pos.config(state=DISABLED)

    
#     # Defino uma linha puramente est√©tica no topo da janela.
#     # Em seguida, defino uma legenda e um bot√£o ao lado, ambos desabilitados, apenas para servir como
#     # instru√ß√µes e mostrar as configura√ß√µes recomendadas dos par√¢metros.
#     ttk.Separator(frame2, orient="horizontal").grid(row=0, column=0, columnspan=3, sticky="ew", pady=(0, 10))
#     lbl = tk.Label(frame2, text="Selecione e/ou digite os valores que deseja para os par√¢metros.", state=DISABLED)
#     lbl.grid(row=1,column=0,sticky='w')
#     btnl = ttk.Button(frame2, text="Recomenda√ß√µes - Configura√ß√µes Recomendadas", state=DISABLED)
#     btnl.grid(row=1,column=1,sticky='e')
#     Tooltip(btnl, "Recomendado:\n\
#     Peso de aloca√ß√£o: 1\n\
#     Peso de troca de sala: 500\n\
#     Peso de agrupamento: 1\n\
#     Peso de superlota√ß√£o: 10\n\
#     √çndice de superlota√ß√£o: 0.85\n\
#     Peso de salas preferencialmente vazias: 1\n\
#     Quantidade de alunos da p√≥s: 20")

#     # Semelhantemente, os pr√≥ximos 'blocos de c√≥digo' seguem a mesma l√≥gica.
#     # Crio uma linha para separar o espa√ßo de cada par√¢metro.
#     # Incluo uma legenda com uma Tooltip para explicar o prop√≥sito do par√¢metro.
#     # Crio uma checkbox para marcar a configura√ß√£o padr√£o daquele par√¢metro sempre primeiro.
#     # Crio, ap√≥s ele, um checkbox para marcar a configura√ß√£o personalizada com um campo desabilitado ao lado dele.
#     # Ele precisa estar desabilitado inicialmente, ou √© poss√≠vel inserir um valor mesmo sem marcar um checkbox.
#     ttk.Separator(frame2, orient="horizontal").grid(row=2, column=0, columnspan=3, sticky="ew", pady=(0, 10))
#     lblx = tk.Label(frame2, text="Defina um peso de aloca√ß√£o:")
#     lblx.grid(row=3, column=0, sticky='w', pady=5)
#     # checkbox1 = Checkbutton(frame1, text="Modelo 1", variable=var1, command=atualizar_estado)
#     checkbox11 = Checkbutton(frame2, text="Recomendado: 1", variable=var11, command=atualizar_estado)
#     checkbox11.grid(row=3, column=1, sticky='w', pady=5)
#     checkbox12 = Checkbutton(frame2, text="Personalizado: ", variable=var12, command=atualizar_estado)
#     checkbox12.grid(row=3, column=2, sticky='w', pady=5)
#     peso_x = Entry(frame2, state=DISABLED)
#     peso_x.grid(row=4, column=2, sticky='e', pady=5)
#     Tooltip(lblx, "O peso de aloca√ß√£o refere-se ao peso da vari√°vel x_as no modelo. \n\
#     Quanto mais alto, mais importante ser√° essa vari√°vel,\n\
#     logo, o modelo pode deixar de alocar de forma √≥tima se o peso for baixo.\n\
#     Por exemplo, ele pode entender que √© mais importante agrupar \n\
#     os cursos, do que usar o maior espa√ßo poss√≠vel.")

#     ttk.Separator(frame2, orient="horizontal").grid(row=5, column=0, columnspan=3, sticky="ew", pady=(0, 10))
#     lbly = tk.Label(frame2, text="Defina um peso de troca de sala:")
#     lbly.grid(row=6,column=0,sticky='w',pady=5)
#     checkbox21 = Checkbutton(frame2, text="Recomendado: 500", variable=var21, command=atualizar_estado)
#     checkbox21.grid(row=6, column=1, sticky='w', pady=5)
#     checkbox22 = Checkbutton(frame2, text="Personalizado: ", variable=var22, command=atualizar_estado)
#     checkbox22.grid(row=6, column=2, sticky='w', pady=5)
#     peso_y = Entry(frame2, state=DISABLED)
#     peso_y.grid(row=7,column=2,sticky='e',pady=5)
#     Tooltip(lbly, "O peso de troca de sala refere-se ao peso da vari√°vel y_t no modelo. \n\
#     Quanto mais alto, mais importante ser√° essa vari√°vel,\n\
#     logo, o modelo pode deixar de manter aulas de uma \n\
#     turma/disciplina alocadas na mesma sala se o peso for baixo.\n\
#     Por exemplo, ele pode entender que √© mais importante preencher \n\
#     uma sala o m√°ximo poss√≠vel sem verificar quais s√£o elas.")


#     ttk.Separator(frame2, orient="horizontal").grid(row=8, column=0, columnspan=3, sticky="ew", pady=(0, 10))
#     lblv = tk.Label(frame2, text="Defina um peso de agrupamento:")
#     lblv.grid(row=9,column=0,sticky='w',pady=5)
#     checkbox31 = Checkbutton(frame2, text="Recomendado: 1", variable=var31, command=atualizar_estado)
#     checkbox31.grid(row=9, column=1, sticky='w', pady=5)
#     checkbox32 = Checkbutton(frame2, text="Personalizado: ", variable=var32, command=atualizar_estado)
#     checkbox32.grid(row=9, column=2, sticky='w', pady=5)
#     peso_v = Entry(frame2, state=DISABLED)
#     peso_v.grid(row=10,column=2,sticky='e',pady=5)
#     Tooltip(lblv, "O peso de agrupamento refere-se ao peso da vari√°vel v_cssl no modelo. \n\
#     Quanto mais alto, mais importante ser√° essa vari√°vel,\n\
#     logo, o modelo pode deixar de tentar agrupar as aulas de \n\
#     um curso pr√≥ximas umas das outras se o peso for baixo.\n\
#     Por exemplo, ele pode entender que √© mais importante \n\
#     acomodar os alunos numa sala, do que agrupar os cursos.")

#     ttk.Separator(frame2, orient="horizontal").grid(row=11, column=0, columnspan=3, sticky="ew", pady=(0, 10))
#     lblz = tk.Label(frame2, text="Defina um peso de superlota√ß√£o:")
#     lblz.grid(row=12,column=0,sticky='w',pady=5)
#     checkbox41 = Checkbutton(frame2, text="Recomendado: 10", variable=var41, command=atualizar_estado)
#     checkbox41.grid(row=12, column=1, sticky='w', pady=5)
#     checkbox42 = Checkbutton(frame2, text="Personalizado: ", variable=var42, command=atualizar_estado)
#     checkbox42.grid(row=12, column=2, sticky='w', pady=5)
#     peso_z = Entry(frame2, state=DISABLED)
#     peso_z.grid(row=13,column=2,sticky='e',pady=5)
#     Tooltip(lblz, "O peso de superlota√ß√£o refere-se ao peso da vari√°vel z_as no modelo. \n\
#     Quanto mais alto, mais importante ser√° essa vari√°vel,\n\
#     logo, o modelo pode deixar de tentar acomodar melhor os \n\
#     alunos em uma sala se o peso for baixo.\n\
#     Por exemplo, ele pode entender que √© mais importante \n\
#     preencher uma sala o m√°ximo poss√≠vel, do que deixar alguns lugares desocupados \n\
#     para acomodar melhor os alunos, ou para receber alunos vindos do requerimento.")

#     ttk.Separator(frame2, orient="horizontal").grid(row=14, column=0, columnspan=3, sticky="ew", pady=(0, 10))
#     lbla = tk.Label(frame2, text="Defina um √≠ndice de superlota√ß√£o (valor entre 0 e 1, utilizando '.'):")
#     lbla.grid(row=15,column=0,sticky='w',pady=5)
#     checkbox51 = Checkbutton(frame2, text="Recomendado: 0.85", variable=var51, command=atualizar_estado)
#     checkbox51.grid(row=15, column=1, sticky='w', pady=5)
#     checkbox52 = Checkbutton(frame2, text="Personalizado: ", variable=var52, command=atualizar_estado)
#     checkbox52.grid(row=15, column=2, sticky='w', pady=5)
#     alpha = Entry(frame2, state=DISABLED)
#     alpha.grid(row=16,column=2,sticky='e',pady=5)
#     Tooltip(lbla, "O √≠ndice de superlota√ß√£o refere-se √† porcentagem usada pela vari√°vel z_as no modelo. \n\
#     Em outras palavras, √© o quanto uma aula preenche uma sala \n\
#     para que o modelo tente colocar essa aula em uma sala maior, \n\
#     garantindo uma melhor acomoda√ß√£o para os alunos e espa√ßo para \n\
#     alunos vindos do requerimento. Quanto mais alto, mais o modelo \n\
#     prioriza preencher o m√°ximo poss√≠vel de uma sala. Um valor baixo \n\
#     faz com que as salas maiores sejam preenchidas com mais facilidade, \n\
#     e um valor alto far√° o mesmo, mas para as salas menores.")

#     ttk.Separator(frame2, orient="horizontal").grid(row=17, column=0, columnspan=3, sticky="ew", pady=(0, 10))
#     lbl_pref = tk.Label(frame2, text="Defina um peso de salas preferencialmente vazias:")
#     lbl_pref.grid(row=18,column=0,sticky='w',pady=5)
#     checkbox61 = Checkbutton(frame2, text="Recomendado: 500", variable=var61, command=atualizar_estado)
#     checkbox61.grid(row=18, column=1, sticky='w', pady=5)
#     checkbox62 = Checkbutton(frame2, text="Personalizado: ", variable=var62, command=atualizar_estado)
#     checkbox62.grid(row=18, column=2, sticky='w', pady=5)
#     pref = Entry(frame2, state=DISABLED)
#     pref.grid(row=19,column=2,sticky='e',pady=5)
#     Tooltip(lbl_pref, "O peso de salas preferencialmente vazias refere-se √† import√¢ncia de determinadas salas ficarem desocupadas no modelo. \n\
#     Quanto mais alto, maior a chance de essas salas n√£o serem utilizadas,\n\
#     logo, o modelo pode tentar alocar aulas em salas indesejadas \n\
#     se o peso for baixo.\n\
#     Por exemplo, ele pode entender que √© mais importante \n\
#     preencher uma sala que poderia ser usada para alguma outra fun√ß√£o, por ela ser mais f√°cil de ser preenchida, \n\
#     do que mant√™-la desocupada para a p√≥s.")

#     # ttk.Separator(frame2, orient="horizontal").grid(row=20, column=0, columnspan=3, sticky="ew", pady=(0, 10))
#     # lblq = tk.Label(frame2, text="Defina uma quantidade de alunos da p√≥s para as disciplinas com espelho:")
#     # lblq.grid(row=21,column=0,sticky='w',pady=5)
#     # checkbox71 = Checkbutton(frame2, text="Recomendado: 20", variable=var71, command=atualizar_estado)
#     # checkbox71.grid(row=21, column=1, sticky='w', pady=5)
#     # checkbox72 = Checkbutton(frame2, text="Personalizado: ", variable=var72, command=atualizar_estado)
#     # checkbox72.grid(row=21, column=2, sticky='w', pady=5)
#     # qtd_pos = Entry(frame2, state=DISABLED)
#     # qtd_pos.grid(row=22,column=2,sticky='e',pady=5)
#     # Tooltip(lblq, "A quantidade de alunos da p√≥s refere-se a um valor sugerido pelo usu√°rio \n\
#     # para simbolizar quantos alunos da p√≥s-gradua√ß√£o far√£o \n\
#     # uma disciplina da gradua√ß√£o que √© espelhada com a p√≥s. \n\
#     # Esse valor ser√° aplicado no n√∫mero de inscritos de QUALQUER \n\
#     # disciplina que tenha espelho com a p√≥s.")

#     # Defino uma fun√ß√£o que detecta as configura√ß√µes escolhidas pelo usu√°rio.
#     def executar_configs_perso():
#         # Verifico se ao menos uma das checkbox relacionadas ao peso de aloca√ß√£o foi selecionada,
#         # pois o modelo precisa desse peso obrigatoriamente.
#         if not var11.get() and not var12.get():
#             # Se nenhum peso foi fornecido, uma janela alerta o ocorrido e pede para o usu√°rio definir um peso.
#             messagebox.showwarning("Aviso", "Por favor, defina um peso de aloca√ß√£o.")
#             return

#         # Verifico se a checkbox da configura√ß√£o recomendada est√° marcado:
#         elif var11.get():
#             # Se estiver, dou o valor recomendado para a vari√°vel auxiliar.
#             aux_x = '1'

#         # Verifico se a checkbox da configura√ß√£o personalizada est√° marcado:
#         else:
#             # Se estiver, dou o valor fornecido pelo usu√°rio para a vari√°vel auxiliar.
#             aux_x = peso_x.get()

#         # Verifico se ao menos uma das checkbox relacionadas ao peso de troca de sala foi selecionada,
#         # pois o modelo precisa desse peso obrigatoriamente. A l√≥gica √© a mesma da de anteriormente.
#         if not var21.get() and not var22.get():
#             messagebox.showwarning("Aviso", "Por favor, defina um peso de troca de sala.")
#             return
#         elif var21.get():
#             aux_y = '500'
#         else:
#             aux_y = peso_y.get()

#         # As condi√ß√µes a seguir seguem a mesma l√≥gica para cada par√¢metro e configura√ß√£o dispon√≠vel.
#         # Verifico se a checkbox da configura√ß√£o personalizada est√° marcada e sem um valor inserido pelo usu√°rio:
#         if var12.get() and not peso_x.get():
#             # Se for o caso, uma janela alerta o ocorrido e pede para o usu√°rio definir um valor para o par√¢metro.
#             messagebox.showwarning("Aviso", "Por favor, digite um peso de aloca√ß√£o.")
#             return

#         # Verifico se a checkbox da configura√ß√£o recomendada est√° marcada:
#         elif var11.get():
#             # Se estiver, dou o valor recomendado para a vari√°vel auxiliar.
#             aux_x = '1'

#         # Verifico, por fim, se a checkbox da configura√ß√£o personalizada est√° marcada.
#         else:
#             # Se estiver, para ter entrado nessa condi√ß√£o, o usu√°rio deve ter fornecido um valor para o par√¢metro.
#             # Portanto, dou o valor fornecido para a vari√°vel auxiliar.
#             aux_x = peso_x.get()

#         if var22.get() and not peso_y.get():
#             messagebox.showwarning("Aviso", "Por favor, digite um peso de troca de sala.")
#             return
#         elif var21.get():
#             aux_y = '500'
#         else:
#             aux_y = peso_y.get()

#         if var32.get() and not peso_v.get():
#             messagebox.showwarning("Aviso", "Por favor, digite um peso de agrupamento.")
#             return
#         elif var31.get():
#             aux_v = '1'
#         else:
#             aux_v = peso_v.get()

#         if var42.get() and not peso_z.get():
#             messagebox.showwarning("Aviso", "Por favor, digite um peso de superlota√ß√£o.")
#             return
#         elif var41.get():
#             aux_z = '10'
#         else:
#             aux_z = peso_z.get()

#         if var52.get() and not alpha.get():
#             messagebox.showwarning("Aviso", "Por favor, digite um √≠ndice de superlota√ß√£o.")
#             return
#         elif var51.get():
#             aux_a = '0.85'
#         else:
#             aux_a = alpha.get()

#         if var62.get() and not pref.get():
#             messagebox.showwarning("Aviso", "Por favor, digite um peso de salas preferencialmente vazias.")
#             return
#         elif var61.get():
#             aux_p = '500'
#         else:
#             aux_p = pref.get()

#         # if var72.get() and not qtd_pos.get():
#         #     messagebox.showwarning("Aviso", "Por favor, digite uma quantidade de alunos da p√≥s para as disciplinas com espelho.")
#         #     return
#         # elif var71.get():
#         #     aux_q = '20'
#         # else:
#         #     aux_q = qtd_pos.get()

#         # Se nenhum alerta foi gerado, as configura√ß√µes personalizadas devem estar corretas,
#         # ent√£o s√≥ resta rodar o script com elas.
#         roda_script(script="Modelo Universal-Copy1.py",
#                 nome=file_name, peso_x=aux_x, peso_y=aux_y, peso_v=aux_v, peso_z=aux_z,
#                 alpha=aux_a, pref=aux_p)



    
#     # Crio uma linha horizontal para separar as escolhas de par√¢metro dos bot√µes da janela.
#     ttk.Separator(frame2, orient="horizontal").grid(row=23, column=0, columnspan=2, sticky="w", pady=(0, 10))

#     # Defino o bot√£o de Executar o Modelo com os par√¢metros Recomendados, que chama a fun√ß√£o de rodar script e os
#     # par√¢metros recomendados diretamente.
#     ttk.Button(frame2, text="Executar com Recomendados",
#                 command=lambda: roda_script(script="Modelo Universal-Copy1.py",
#                                             nome=file_name, peso_x='1', peso_y='500', peso_v="",
#                                             peso_z='10', alpha='0.85', pref='500')).grid(row=24, column=0, sticky='w', pady=5)

#     # Defino o bot√£o de Executar o Modelo com os par√¢metros Personalizados, que chama a fun√ß√£o definida anteriormente
#     # para checar as configura√ß√µes personalizadas pelo usu√°rio.
#     ttk.Button(frame2, text="Executar com Personalizados",
#                 command=executar_configs_perso).grid(row=24, column=2, sticky='w', pady=5)

    
        
#         # # An√°logo aos bot√µes que s√£o definidos no menu de configura√ß√µes do modelo.
#         # ttk.Separator(frame2, orient="horizontal").grid(row=23, column=0, columnspan=2, sticky="w", pady=(0, 10))
#         # ttk.Button(frame2, text="Verificar com Recomendados",
#         #            command=lambda: roda_script(script="verificar_dados.py",
#         #                                        nome=file_name, peso_x='1', peso_y='500', peso_v="",
#         #                                        peso_z='10', alpha='0.85', pref='500')).grid(row=24, column=0, sticky='w', pady=5)

#         # ttk.Button(frame2, text="Verificar com Personalizados",
#         #            command=executar_configs_perso).grid(row=24, column=2, sticky='w', pady=5)

"""## An√°lise de Espa√ßos Livres (colocar nos arquivos de modelo)"""

# Fun√ß√£o que cria uma janela para selecionar arquivos de solu√ß√£o do modelo, que ser√£o analisados
# para criar planilhas mostrando os espa√ßos livres ap√≥s as aloca√ß√µes.
def analise_vazios():
    """
    Fun√ß√£o para an√°lise de espa√ßos livres no Google Colab
    Gera relat√≥rios de espa√ßos livres com base nos arquivos de entrada
    """
    
    clear_output(wait=True)
    print("=== AN√ÅLISE DE ESPA√áOS LIVRES ===")
    
    # Fun√ß√£o auxiliar para upload
    def fazer_upload(mensagem):
        print(f"\n{mensagem}")
        print("Por favor, fa√ßa o upload do arquivo:")
        uploaded = files.upload()
        if not uploaded:
            print("‚ùå Nenhum arquivo foi selecionado!")
            return None
        return next(iter(uploaded))
    
    # Solicitar arquivos necess√°rios
    print("\nüìÇ Selecione os arquivos necess√°rios:")
    arquivo_visu = fazer_upload("1. Planilha de Visualiza√ß√£o Completa da Solu√ß√£o do modelo")
    arquivo_salas = fazer_upload("2. Planilha dos dados das salas")
    
    if arquivo_visu is None or arquivo_salas is None:
        input("\nPressione Enter para tentar novamente...")
        return analise_vazios()
    
    # Solicitar nomes dos arquivos de sa√≠da
    print("\n‚úèÔ∏è Defina os nomes para os arquivos de sa√≠da:")
    nome_visualizacao = input("Nome para o arquivo de Visualiza√ß√£o de Espa√ßos Livres (sem extens√£o): ").strip()
    nome_planilha = input("Nome para o arquivo de Planilha de Espa√ßos Livres (sem extens√£o): ").strip()
    
    if not nome_visualizacao or not nome_planilha:
        print("‚ùå Por favor, forne√ßa nomes para ambos os arquivos de sa√≠da.")
        input("\nPressione Enter para tentar novamente...")
        return analise_vazios()
    
    # Adicionar extens√£o .xlsx se n√£o tiver
    if not nome_visualizacao.endswith('.xlsx'):
        nome_visualizacao += '.xlsx'
    if not nome_planilha.endswith('.xlsx'):
        nome_planilha += '.xlsx'
    
    # Caminhos de sa√≠da no Google Drive
    caminho_visualizacao = os.path.join('/content/drive/MyDrive/Estagio-SVGrad/Sa√≠das da Interface/Planilhas de Dados', nome_visualizacao)
    caminho_planilha = os.path.join('/content/drive/MyDrive/Estagio-SVGrad/Sa√≠das da Interface/Planilhas de Dados', nome_planilha)
    
    # Confirmar a√ß√£o
    print("\n‚öôÔ∏è Configura√ß√µes selecionadas:")
    print(f"- Arquivo de solu√ß√£o: {arquivo_visu}")
    print(f"- Arquivo de salas: {arquivo_salas}")
    print(f"- Sa√≠da 1: {caminho_visualizacao}")
    print(f"- Sa√≠da 2: {caminho_planilha}")
    
    confirmar = input("\nConfirmar gera√ß√£o dos relat√≥rios? (s/n): ").lower()
    if confirmar != 's':
        print("Opera√ß√£o cancelada.")
        input("\nPressione Enter para voltar ao menu principal...")
        return
    
    # Executar a fun√ß√£o de cria√ß√£o dos relat√≥rios
    try:
        print("\nüîÑ Processando dados e gerando relat√≥rios...")
        criar_visualizacao_de_vazias(
            arquivo_visu,
            arquivo_salas,
            caminho_visualizacao,
            caminho_planilha
        )
        
        print("\n‚úÖ Relat√≥rios gerados com sucesso!")
        print(f"- Visualiza√ß√£o de Espa√ßos Livres: {caminho_visualizacao}")
        print(f"- Planilha de Espa√ßos Livres: {caminho_planilha}")
        
    except Exception as e:
        print(f"\n‚ùå Ocorreu um erro durante a gera√ß√£o dos relat√≥rios:")
        print(str(e))
    
    input("\nPressione Enter para voltar ao menu principal...")
# def analise_vazios():
#     # Crio uma nova janela em cima da janela principal da interface.
#     nova_janela = tk.Toplevel(root)
#     nova_janela.title("An√°lise de Espa√ßos Livres")

#     # Crio o frame para armazenar os bot√µes e outros campos da nova janela.
#     frame = tk.Frame(nova_janela)
#     frame.pack(pady=10, padx=10)

#     # Defino uma vari√°vel para salvar o arquivo com a planilha de Visualiza√ß√£o Completa da Solu√ß√£o do modelo.
#     visu = tk.StringVar(value="Selecione a planilha de Visualiza√ß√£o Completa da Solu√ß√£o do modelo")

#     # Defino uma vari√°vel para salvar o arquivo com a planilha dos dados das salas.
#     salas = tk.StringVar(value="Selecione a planilha dos dados das salas")

#     # Defino uma vari√°vel para salvar o nome, fornecido pelo usu√°rio, para o arquivo de Visualiza√ß√£o de Espa√ßos Livres.
#     caminho_arquivo = tk.StringVar()

#     # Defino uma vari√°vel para salvar o nome, fornecido pelo usu√°rio, para o arquivo de Planilha de Espa√ßos Livres.
#     caminho_arquivo1 = tk.StringVar()

#     # Defino as fun√ß√µes para selecionar arquivos.
#     def selecionar_arquivo1():
#         # O usu√°rio seleciona o arquivo contendo a base de dados das aulas.
#         arquivo = filedialog.askopenfilename(title="Selecione a planilha de Visualiza√ß√£o Completa da Solu√ß√£o do modelo")

#         # Se um arquivo foi selecionado:
#         if arquivo:
#             # Salvo o caminho do arquivo.
#             visu.set(arquivo)

#     # Fun√ß√£o an√°loga.
#     def selecionar_arquivo2():
#         # O usu√°rio seleciona o arquivo contendo a base de dados das aulas.
#         arquivo = filedialog.askopenfilename(title="Selecione a planilha dos dados das salas")

#         # Se um arquivo foi selecionado:
#         if arquivo:
#             # Salvo o caminho do arquivo.
#             salas.set(arquivo)

#     # Defino uma fun√ß√£o que salva os valores das vari√°veis contendo o nome dos arquivos escolhidos.
#     def salvar_valores():
#         # Todas as condi√ß√µes a seguir seguem a l√≥gica de que, se um arquivo n√£o foi selecionado, uma janela avisando o ocorrido
#         # aparece, pedindo para o usu√°rio selecionar um arquivo no campo requerido, ou fornecer um nome para os arquivos
#         # que ser√£o criados.

#         if not visu.get() or visu.get() == "Selecione a planilha de Visualiza√ß√£o Completa da Solu√ß√£o do modelo":
#             messagebox.showwarning("Aviso", "Por favor, selecione a planilha de Visualiza√ß√£o Completa da Solu√ß√£o do modelo.")
#             return
#         if not salas.get() or salas.get() == "Selecione a planilha dos dados das salas":
#             messagebox.showwarning("Aviso", "Por favor, selecione a planilha dos dados das salas.")
#             return
#         if not caminho_arquivo.get():
#             messagebox.showwarning("Aviso", "Por favor, d√™ um nome para o arquivo de Visualiza√ß√£o de Espa√ßos Livres.")
#             return
#         if not caminho_arquivo1.get():
#             messagebox.showwarning("Aviso", "Por favor, d√™ um nome para o arquivo de Planilha de Espa√ßos Livres.")
#             return


#         # Com o arquivo necess√°rio selecionado, e os nomes dos novos arquivos obtidos, chamo a fun√ß√£o que far√° a an√°lise dos espa√ßos livres.
#         criar_visualizacao_de_vazias(visu.get(), salas.get(), caminho_arquivo.get(), caminho_arquivo1.get(), )

#         # E destruo a janela ap√≥s a conclus√£o do processo.
#         nova_janela.destroy()

#     # Crio uma legenda para ficar ao lado do bot√£o.
#     lbl_visu = tk.Label(frame, text="Selecione a de Dados da Solu√ß√£o do modelo")
#     # Defino a posi√ß√£o do texto na janela.
#     lbl_visu.grid(row=0, column=0, pady=5, sticky="w")
#     # Crio o bot√£o para salvar o arquivo da Visualiza√ß√£o Completa da Solu√ß√£o do modelo.
#     btn_selecionar_visu = tk.Button(frame, textvariable=visu, command=selecionar_arquivo1, wraplength=250, width=40)
#     # Defino a posi√ß√£o do bot√£o na janela.
#     btn_selecionar_visu.grid(row=0, column=1, padx=5, pady=5)

#     # As linhas a seguir s√£o an√°logas.
#     lbl_salas = tk.Label(frame, text="Selecione a planilha dos dados das salas")
#     lbl_salas.grid(row=1, column=0, pady=5, sticky="w")
#     btn_selecionar_salas = tk.Button(frame, textvariable=salas, command=selecionar_arquivo2, wraplength=250, width=40)
#     btn_selecionar_salas.grid(row=1, column=1, padx=5, pady=5)

#     lbl_cam = tk.Label(frame, text="Digite um nome para a Visualiza√ß√£o de Espa√ßos Livres:")
#     lbl_cam.grid(row=2, column=0, pady=5, sticky="w")
#     campo_cam = tk.Entry(frame, textvariable=caminho_arquivo)
#     campo_cam.grid(row=2, column=1, pady=5)

#     lbl_cam1 = tk.Label(frame, text="Digite um nome para a Planilha de Espa√ßos Livres:")
#     lbl_cam1.grid(row=3, column=0, pady=5, sticky="w")
#     campo_cam1 = tk.Entry(frame, textvariable=caminho_arquivo1)
#     campo_cam1.grid(row=3, column=1, pady=5)

#     # Defino um bot√ß√£o e sua posi√ß√£o na janela, cujo papel √© chamar a fun√ß√£o que salva os valores dos arquivos para a an√°lise.
#     ttk.Button(frame, text="Gerar An√°lise de Espa√ßos Livres", command=salvar_valores).grid(row=4,column=0,sticky='ew')

"""### Criar Visualiza√ß√£o em cima de Visualiza√ß√£o"""

# Fun√ß√£o que faz a an√°lise de espa√ßos livres restantes ap√≥s a aloca√ß√£o feita pelo modelo.

import pandas as pd
from openpyxl import load_workbook
from openpyxl.styles import PatternFill
from datetime import datetime, timedelta
import os

def criar_visualizacao_de_vazias(file_path, file_path_salas, caminho_arquivo, caminho_arquivo1):
    """
    Fun√ß√£o para criar visualiza√ß√£o de espa√ßos livres no Google Colab
    Gera dois arquivos:
    1. Planilha com visualiza√ß√£o gr√°fica dos hor√°rios livres
    2. Planilha com lista detalhada dos hor√°rios livres
    """
    
    try:
        print("\nüìä Processando arquivos...")
        
        # Carrega a planilha de solu√ß√£o
        wb = load_workbook(file_path)
        ws = wb.active

        # Define intervalo de hor√°rios (7:00 √†s 23:30 em intervalos de 30 minutos)
        start_time = datetime.strptime("07:00", "%H:%M")
        end_time = datetime.strptime("23:30", "%H:%M")
        horarios = []
        current_time = start_time
        while current_time <= end_time:
            horarios.append(current_time.strftime("%H:%M"))
            current_time += timedelta(minutes=30)

        sala_colunas = len(horarios)
        dias_semana = ["Segunda", "Ter√ßa", "Quarta", "Quinta", "Sexta", "S√°bado"]
        
        # Configura√ß√µes iniciais para processamento
        start_row = 1
        start_column = 2
        end_row = 1
        end_column = 1 + sala_colunas
        start = start_row + 2
        space_between = 3
        
        # Estilo para c√©lulas livres (amarelo)
        yellow_fill = PatternFill(start_color="00E3DE00", end_color="00E3DE00", fill_type="solid")
        
        # Calcula n√∫mero de salas utilizadas
        n_salas = int((ws.max_row+1) / (2 + len(dias_semana) + space_between))
        
        # Carrega dados das salas
        salas = pd.read_excel(file_path_salas)
        salas1 = []
        df_vazio = pd.DataFrame(columns=["Sala", "Dia da semana", "Hor√°rio vago"])

        # Fun√ß√£o auxiliar para verificar cor da c√©lula
        def get_cell_color(cell):
            fill = cell.fill
            if fill and fill.start_color.index != "00E3DE00":  # Ignorar c√©lulas amarelas
                return fill.start_color.index
            return None

        print("üîç Analisando hor√°rios livres por sala...")
        
        # Processa cada sala utilizada
        for i in range(n_salas+1):
            sala = ws.cell(row=start_row, column=start_column).value
            salas1.append(sala)
            
            # Processa cada dia da semana
            for row in ws.iter_rows(min_row=start, max_row=start+5):
                start_col = None
                
                for col_idx, cell in enumerate(row, start=1):
                    cell_color = get_cell_color(cell)
                    
                    # C√©lula vazia (potencial hor√°rio livre)
                    if cell_color == "00000000":
                        if type(cell) != openpyxl.cell.cell.MergedCell:
                            if start_col is None and cell.value not in dias_semana:
                                start_col = cell.column - 2
                    
                    # C√©lula ocupada
                    else:
                        if type(cell) != openpyxl.cell.cell.MergedCell:
                            cell.value = ""
                            cell.fill = yellow_fill
                        
                        # Registra intervalo livre encontrado
                        if start_col is not None and col_idx - start_col >= 1:
                            df_vazio.loc[len(df_vazio)] = [
                                f"{sala}",
                                f"{ws.cell(row=cell.row, column=1).value}",
                                f"{horarios[start_col]} - {horarios[col_idx-2]}"
                            ]
                        start_col = None
                
                # Registra √∫ltimo intervalo livre do dia
                if start_col is not None and start_col < len(row):
                    df_vazio.loc[len(df_vazio)] = [
                        f"{sala}",
                        f"{ws.cell(row=cell.row, column=1).value}",
                        f"{horarios[start_col]} - {horarios[col_idx-2]}"
                    ]
            
            # Atualiza para pr√≥xima sala
            start_row = start_row + 2 + len(dias_semana) + space_between
            end_row = start_row
            start = start_row + 2

        print("üîç Verificando salas n√£o utilizadas...")
        
        # Processa salas n√£o utilizadas
        for sala in salas['Sala'].tolist():
            if sala not in salas1:
                # Ignora salas individuais quando o conjunto foi usado
                if (sala == '6-303' and '6-303/6-304' in salas1) or \
                   (sala == '6-304' and '6-303/6-304' in salas1) or \
                   (sala == '6-305' and '6-305/6-306' in salas1) or \
                   (sala == '6-306' and '6-305/6-306' in salas1):
                    continue
                
                # Adiciona sala n√£o utilizada (livre o dia todo)
                for dia in dias_semana:
                    df_vazio.loc[len(df_vazio)] = [
                        f"{sala}",
                        dia,
                        "07:00 - 23:30"
                    ]

        # Garante extens√£o .xlsx
        if not caminho_arquivo.endswith(".xlsx"):
            caminho_arquivo += ".xlsx"
        if not caminho_arquivo1.endswith(".xlsx"):
            caminho_arquivo1 += ".xlsx"

        # Caminhos completos no Google Drive
        output_path1 = os.path.join('/content/drive/MyDrive/Estagio-SVGrad/Sa√≠das da Interface/Planilhas de Dados', caminho_arquivo)
        output_path2 = os.path.join('/content/drive/MyDrive/Estagio-SVGrad/Sa√≠das da Interface/Planilhas de Dados', caminho_arquivo1)

        print("üíæ Salvando arquivos...")
        
        # Salva arquivos
        wb.save(output_path1)
        df_vazio.to_excel(output_path2, sheet_name="Resultados", index=False)
        
        print("\n‚úÖ Arquivos gerados com sucesso!")
        print(f"- Visualiza√ß√£o gr√°fica: {output_path1}")
        print(f"- Lista detalhada: {output_path2}")
        
    except PermissionError:
        print("\n‚ùå Erro: N√£o foi poss√≠vel salvar os arquivos")
        print("Verifique se os arquivos est√£o abertos em outro programa")
    except Exception as e:
        print(f"\n‚ùå Ocorreu um erro inesperado:")
        print(str(e))
# def criar_visualizacao_de_vazias(file_path, file_path_salas, caminho_arquivo, caminho_arquivo1):
#     # Defino uma vari√°vel que recebe a planilha do Excel da Visualiza√ß√£o Completa da Solu√ß√£o do modelo.
#     wb = load_workbook(file_path)
#     ws = wb.active

#     # Defino duas vari√°veis com o hor√°rio inicial e final, isto √©, o intervalo dos hor√°rios que ser√£o colocados na planilha para a visualiza√ß√£o.
#     start_time = datetime.strptime("07:00", "%H:%M")
#     end_time = datetime.strptime("23:30", "%H:%M")

#     # Crio uma lista para conter os valores do intervalo de hor√°rios.
#     horarios = []

#     # Crio uma vari√°vel com o hor√°rio inicial.
#     current_time = start_time

#     # Enquanto o hor√°rio inicial n√£o for maior que o hor√°rio final, isto √©, enquanto houver valores para serem colocados no intervalo:
#     while current_time <= end_time:
#         # Adiciono o hor√°rio atual na lista de hor√°rios.
#         horarios.append(current_time.strftime("%H:%M"))

#         # Fa√ßo um acr√©scimo de 30 minutos no hor√°rio atual.
#         current_time += timedelta(minutes=30)

#     # Crio uma vari√°vel com a quantidade de colunas necess√°rias para colocar todos os hor√°rios do intervalo.
#     sala_colunas = len(horarios)

#     # Lista com os nomes dos dias da semana que ser√£o usados na visualiza√ß√£o.
#     dias_semana = ["Segunda", "Ter√ßa", "Quarta", "Quinta", "Sexta", "S√°bado"]

#     # Defino as linhas e colunas de in√≠cio e fim para a primeira tabela da planilha, isto √©, para preencher os dados da primeira sala.
#     start_row = 1 # Linha de in√≠cio.
#     start_column = 2 # Coluna de in√≠cio.
#     end_row = 1 # Linha de t√©rmino.
#     end_column = 1 + sala_colunas # Coluna de t√©rmino.
#     start = start_row + 2 # Linha de in√≠cio para listar os dias da semana.
#     space_between = 3 # N√∫mero de linhas entre a tabela de uma sala para a de outra sala.

#     # Defino um preenchimento amarelo para simbolizar os espa√ßos livres das salas.
#     yellow_fill = PatternFill(start_color="00E3DE00", end_color="00E3DE00", fill_type="solid")

#     # Defino uma vari√°vel que guarda o n√∫mero de salas utilizadas na solu√ß√£o do modelo.
#     # O c√°lculo feito √© baseado no comprimento da planilha, no n√∫mero de dias da semana mostrados na visualiza√ß√£o, e no
#     # espa√ßo entre cada "tabela" de cada sala.
#     n_salas = int((ws.max_row+1) / (2 + len(dias_semana) + space_between))

#     # Salvo os dados das salas em uma vari√°vel.
#     salas = pd.read_excel(file_path_salas)

#     # Crio uma lista para salvar quais salas foram usadas para a aloca√ß√£o do modelo.
#     salas1 = []

#     # Crio um dataframe vazio para salvar os intervalos de tempo onde as salas est√£o dispon√≠veis.
#     df_vazio = pd.DataFrame(columns=["Sala", "Dia da semana", "Hor√°rio vago"])

#     # Fun√ß√£o para obter a cor da c√©lula.
#     def get_cell_color(cell):
#         # Salvo a cor de preenchimento da c√©lula em uma vari√°vel.
#         fill = cell.fill

#         # if fill and fill.start_color.index != "ffffff":  # Ignorar c√©lulas sem cor
#         # Verifico se tinha algum preenchimento diferente, ou se o preenchimento √© amarelo:
#         if fill and fill.start_color.index != "00E3DE00":  # Ignorar c√©lulas amarelas
#             # Se houver, retorno o c√≥digo do preenchimento.
#             return fill.start_color.index  # Retorna o c√≥digo da cor

#         # Caso n√£o houver uma cor de preenchimento definida, retorno vazio.
#         return None  # Sem cor definida

#     # Para cada sala utilizada pelo modelo:
#     for i in range(n_salas+1):
#         # print(type(ws.cell(row=start_row, column=start_column)))
#         # Salvo a sala que est√° sendo analisada atualmente em uma vari√°vel.
#         sala = ws.cell(row=start_row, column=start_column).value

#         # E tamb√©m a adiciono na lista de salas usadas.
#         salas1.append(sala)

#         # Para cada linha da planilha:
#         for row in ws.iter_rows(min_row=start, max_row=start+5):
#         # for i, dia in enumerate(dias_semana, start=start):

#             # Defino a coluna inicial como vazia.
#             start_col = None  # In√≠cio da mesclagem
#             # current_color = None  # Cor atual

#             # Para cada par (coluna, c√©lula) da linha sendo analisada:
#             for col_idx, cell in enumerate(row, start=1):
#                 # Busco identificar a cor do preenchimento da c√©lula.
#                 cell_color = get_cell_color(cell)

#                 # Se a cor da c√©lula atual for branca, possivelmente deixei de estar analisando um hor√°rio ocupado:
#                 if cell_color == "00000000":
#                     # Verifico se a c√©lula √© uma c√©lula mesclada:
#                     if type(cell) != openpyxl.cell.cell.MergedCell:
#                         # Se n√£o for, verifico se a coluna inicial est√° como vazia,
#                         # e se a c√©lula atual n√£o faz parte da coluna de dias da semana:
#                         if start_col is None and cell.value not in dias_semana:
#                             # Se for o caso, salvo a coluna inicial na vari√°vel.
#                             # O workbook sempre considera a primeira coluna como 1, e como o primeiro "elemento" da lista de hor√°rios est√° na
#                             # coluna 2, ent√£o para traduzir corretamente a coluna da c√©lula vazia, preciso tirar 2 para o √≠ndice ficar compat√≠vel
#                             start_col = cell.column - 2

#                 # Se a cor da c√©lula atual n√£o for branca:
#                 else:
#                     # Verifico se a c√©lula que estou analisando n√£o √© mesclada:
#                     if type(cell) != openpyxl.cell.cell.MergedCell:
#                         # Se ela n√£o for, quer dizer que estou analisando a primeira c√©lula de um intervalo ocupado, isto √©,
#                         # estou analisando a c√©lula do topo esquerdo da mesclagem, que √© a √∫nica que pode ter seu valor alterado.
#                         # Assim, limpo o que estiver dentro da c√©lula.
#                         cell.value = ""

#                         # E mudo a cor de seu preenchimento para o amarelo definido anteriormente.
#                         cell.fill = yellow_fill

#                     # Agora, verifico se a coluna inicial √© diferente de vazio, ou seja, se ela j√° foi definida;
#                     # e verifico se a dist√¢ncia entre a coluna atual e a coluna inicial √© maior ou igual que 1,
#                     # certificando que n√£o estou olhando para a mesma coluna:
#                     if start_col is not None and col_idx - start_col >= 1:
#                         # Aqui √© onde eu vou pegar os intervalos do merge
#                         # print(f"a: {start_col}: {horarios[start_col-1]} - {horarios[col_idx-1-2+1]}\n")

#                         # Se isso for verdade, adiciono uma linha no dataframe contendo os hor√°rios dispon√≠veis at√© ent√£o.
#                         # Na ordem, esta a sala que estou analisando, o dia da semana com o hor√°rio dispon√≠vel, e
#                         # o intervalo de tempo livre do dia em quest√£o.
#                         # Como estou analisando linha por linha, a coluna do segundo valor sempre √© 1, pois refere-se
#                         # √† coluna de dias da semana; e eu preciso subtrair o valor 2 de col_idx para ignorar a primeira coluna
#                         # da tabela (-1), e para igualar com o √≠ndice usual (j√° que col_idx sempre come√ßa com o valor 1).
#                         df_vazio.loc[len(df_vazio)] = [f"{sala}", f"{ws.cell(row=cell.row, column=1).value}",
#                                                        f"{horarios[start_col]} - {horarios[col_idx-2]}"]

#                     # Ap√≥s estes processos, defino novamente a coluna de in√≠cio como vazia para definir um novo intervalo.
#                     start_col = None


#             # Por garantia, adiciono o √∫ltimo intervalo de hor√°rio dispon√≠vel nos dados, j√° que a an√°lise da linha
#             # poderia terminar e ir para a pr√≥xima sem incluir o √∫ltimo hor√°rio dispon√≠vel dela:
#             if start_col is not None and start_col < len(row):
#                 # print(f"b: {start_col}: {horarios[start_col-1]} - {horarios[col_idx-1-2+1]}\n")
#                 # Incluo esses dados da mesma forma como anteriormente.
#                 df_vazio.loc[len(df_vazio)] = [f"{sala}", f"{ws.cell(row=cell.row, column=1).value}",
#                                                f"{horarios[start_col]} - {horarios[col_idx-2]}"]

#         # Feito isso, atualizo meus dados de cria√ß√£o, isto √©, as coordenadas de onde a tabela da sala seguinte ser√° colocada na planilha.
#         start_row = start_row + 2 + len(dias_semana) + space_between
#         end_row = start_row
#         start = start_row + 2


#     # Ap√≥s fazer a an√°lise de espa√ßos livres de todas as salas utilizadas na aloca√ß√£o, verificarei quais ficaram inteiramente de fora.
#     # Para isso, verifico cada sala na planilha de salas:
#     for sala in salas['Sala'].tolist():
#         # Se a sala n√£o est√° na lista de salas utilizadas:
#         if sala not in salas1:

#             if sala == '6-303' and '6-303/6-304' in salas1:
#                 continue
#             elif sala == '6-304' and '6-303/6-304' in salas1:
#                 continue
#             elif sala == '6-305' and '6-305/6-306' in salas1:
#                 continue
#             elif sala == '6-306' and '6-305/6-306' in salas1:
#                 continue
#             else:
#                 # Adiciono qual sala n√£o foi utilizada na planilha de dados de espa√ßos livres.
#                 # As condi√ß√µes dadas anteriormente s√£o para garantir que o c√≥digo n√£o inclua as salas de laborat√≥rio avulsas
#                 # quando apenas as em conjunto foram utilizadas. Por exemplo, se o modelo tiver alocado apenas os laborat√≥rios
#                 # do bloco 6 (6-303/6-304 e 6-305/6-306), o algoritmo pode incluir, erroneamente, que a sala 6-303 n√£o foi usada.
#                 weekdays = ['Segunda', 'Ter√ßa', 'Quarta', 'Quinta', 'Sexta', 'S√°bado']
                
#                 for i in range(len(weekdays)):
#                     last_line = df_vazio.shape[0] + 1
#                     df_vazio.loc[last_line, 'Sala'] = f"{sala}"
#                     df_vazio.loc[last_line, 'Dia da semana'] = weekdays[i]
#                     df_vazio.loc[last_line, 'Hor√°rio vago'] = "07:00 - 23:30"


#     ## Verifico se o nome da nova base de dados termina com '.xlsx':
#     if not caminho_arquivo.endswith(".xlsx"):
#         # Em caso negativo, adiciono essa terminologia.
#         caminho_arquivo = caminho_arquivo + ".xlsx"

#     # Verifico se o nome da nova base de dados termina com '.xlsx':
#     if not caminho_arquivo1.endswith(".xlsx"):
#         # Em caso negativo, adiciono essa terminologia.
#         caminho_arquivo1 = caminho_arquivo1 + ".xlsx"

#     try:
#         # Por fim, salvo os arquivos criados com seus respectivos m√©todos.
#         wb.save(os.path.join(saidas, caminho_arquivo))
    
#     except PermissionError as e:
#         if e.errno == 13:  # Erro de permiss√£o (arquivo aberto ou bloqueado)
#             messagebox.showerror("Erro de Permiss√£o", 
#                                     (
#                                         f"N√£o foi poss√≠vel salvar o arquivo {os.path.basename(caminho_arquivo)}. "
#                                         "Verifique se ele est√° aberto em outro programa (como o Excel) e tente novamente."
#                                     )
#                                 )
#             return
#         else:
#             messagebox.showerror("Erro", f"Erro de permiss√£o:\n\n{str(e)}")
#             return
#     except Exception as e:
#         # Para qualquer outro erro
#         messagebox.showerror("Erro inesperado!", f"Ocorreu um erro inesperado:\n\n{str(e)}")
#         return
    

#     try:
#         df_vazio.to_excel(os.path.join(saidas, caminho_arquivo1), sheet_name="Resultados", index=False)

        
#     except PermissionError as e:
#         if e.errno == 13:  # Erro de permiss√£o (arquivo aberto ou bloqueado)
#             messagebox.showerror("Erro de Permiss√£o", 
#                                     (
#                                         f"N√£o foi poss√≠vel salvar o arquivo {os.path.basename(caminho_arquivo1)}. "
#                                         "Verifique se ele est√° aberto em outro programa (como o Excel) e tente novamente."
#                                     )
#                                 )
#             return
#         else:
#             messagebox.showerror("Erro", f"Erro de permiss√£o:\n\n{str(e)}")
#             return
#     except Exception as e:
#         # Para qualquer outro erro
#         messagebox.showerror("Erro inesperado!", f"Ocorreu um erro inesperado:\n\n{str(e)}")
#         return
    
#     # E abro uma janela avisando o usu√°rio de que os arquivos foram salvos.
#     messagebox.showinfo("Suesso", 
#                         f"Arquivo {caminho_arquivo} criado com sucesso!\n\
#                         \nArquivo {caminho_arquivo1} criado com sucesso!\n\
#                         \nVerifique a pasta {saidas} para encontr√°-lo.")

"""# Preencher Planilha de Dados"""

# Fun√ß√£o que preenche as planilhas de dados fornecidas pelo usu√°rio, sem a necessidade do mesmo preencher as
# aloca√ß√µes feitas pelo modelo de forma manual.
# Estruturalmente, a fun√ß√£o √© bem semelhante √† de construir a primeira base de dados (a das aulas), com a √∫nica diferen√ßa
# sendo dois campos a mais para inserir a bases de dados feita anteriormente, e a solu√ß√£o dada pelo modelo.

from google.colab import files
from IPython.display import clear_output
import os

def preencher_planilha_dados():
    """
    Fun√ß√£o para preencher planilhas com dados da solu√ß√£o no Google Colab
    Oferece duas op√ß√µes:
    1. Preencher com a solu√ß√£o completa
    2. Preencher com escolhas do usu√°rio
    """
    
    clear_output(wait=True)
    print("=== PREENCHER PLANILHAS COM DADOS DA SOLU√á√ÉO ===")
    
    # Dicion√°rio para armazenar os arquivos carregados
    arquivos = {
        'sme': None,
        'sma': None,
        'scc': None,
        'ssc': None,
        'outros': None,
        'solucao': None,
        'base': None
    }
    
    # Fun√ß√£o auxiliar para upload
    def fazer_upload(mensagem):
        print(f"\n{mensagem}")
        print("Por favor, fa√ßa o upload do arquivo:")
        uploaded = files.upload()
        if not uploaded:
            print("‚ùå Nenhum arquivo foi selecionado!")
            return None
        return next(iter(uploaded))
    
    # Solicitar upload dos arquivos necess√°rios
    print("\nüìÇ Selecione os arquivos necess√°rios:")
    arquivos['sme'] = fazer_upload("1. Planilha do SME")
    arquivos['sma'] = fazer_upload("2. Planilha do SMA")
    arquivos['scc'] = fazer_upload("3. Planilha do SCC")
    arquivos['ssc'] = fazer_upload("4. Planilha do SSC")
    arquivos['outros'] = fazer_upload("5. Planilha dos Outros Institutos")
    arquivos['solucao'] = fazer_upload("6. Planilha com os Dados da Solu√ß√£o do Modelo")
    arquivos['base'] = fazer_upload("7. Base de Dados")
    
    # Verificar se todos os arquivos foram carregados
    if any(v is None for v in arquivos.values()):
        input("\nPressione Enter para tentar novamente...")
        return preencher_planilha_dados()
    
    while True:
        clear_output(wait=True)
        print("=== OP√á√ïES DE PREENCHIMENTO ===")
        print(f"Arquivos carregados:")
        for k, v in arquivos.items():
            print(f"- {k.upper()}: {os.path.basename(v)}")
        
        print("\n1. Preencher com a solu√ß√£o completa")
        print("2. Preencher com escolhas do usu√°rio")
        print("3. Carregar arquivos diferentes")
        print("4. Voltar ao menu principal")
        print("==============================")
        
        opcao = input("\nSelecione uma op√ß√£o: ").strip()
        
        if opcao == "1":
            # Preencher com solu√ß√£o completa
            print("\nüîÑ Preparando para preencher planilhas com solu√ß√£o completa...")
            elenco = [arquivos['sme'], arquivos['sma'], arquivos['scc'], arquivos['ssc'], arquivos['outros']]
            try:
                preenchimento(elenco, arquivos['solucao'], arquivos['base'], True)
                print("\n‚úÖ Planilhas preenchidas com sucesso!")
            except Exception as e:
                print(f"\n‚ùå Erro durante o preenchimento:")
                print(str(e))
            input("\nPressione Enter para continuar...")
            return
            
        elif opcao == "2":
            # Preencher com escolhas do usu√°rio
            print("\nüîÑ Preparando para preencher planilhas com escolhas do usu√°rio...")
            elenco = [arquivos['sme'], arquivos['sma'], arquivos['scc'], arquivos['ssc'], arquivos['outros']]
            try:
                escolhas_preenchimento(elenco, arquivos['solucao'], arquivos['base'])
                print("\n‚úÖ Planilhas preenchidas com sucesso!")
            except Exception as e:
                print(f"\n‚ùå Erro durante o preenchimento:")
                print(str(e))
            input("\nPressione Enter para continuar...")
            return
            
        elif opcao == "3":
            # Carregar arquivos diferentes
            return preencher_planilha_dados()
            
        elif opcao == "4":
            # Voltar ao menu principal
            return
            
        else:
            print("‚ùå Op√ß√£o inv√°lida!")
            input("\nPressione Enter para continuar...")
# def preencher_planilha_dados():

#     # Crio uma nova janela em cima da janela principal da interface.
#     nova_janela = tk.Toplevel(root)
#     nova_janela.title("Selecionar Arquivo e Inserir Valor")

#     # Crio o frame para armazenar os bot√µes e outros campos da nova janela.
#     frame = tk.Frame(nova_janela)
#     frame.pack(pady=10, padx=10)

#     # Defino v√°rias vari√°veis para armazenar os nomes dos arquivos que ser√£o preenchidos.
#     arquivo_sme = tk.StringVar(value="Selecione a planilha do SME")
#     arquivo_sma = tk.StringVar(value="Selecione a planilha do SMA")
#     arquivo_scc = tk.StringVar(value="Selecione a planilha do SCC")
#     arquivo_ssc = tk.StringVar(value="Selecione a planilha do SSC")
#     arquivo_outros = tk.StringVar(value="Selecione a planilha dos Outros Institutos")
#     arquivo_sol = tk.StringVar(value="Selecione a planilha com os Dados da Solu√ß√£o do Modelo")
#     arquivo_base = tk.StringVar(value="Selecione a Base de Dados")



#     # Defino fun√ß√µes para selecionar arquivos.
#     def selecionar_sme():
#         # O usu√°rio seleciona o arquivo contendo a base de dados das aulas.
#         arquivo = filedialog.askopenfilename(title="Selecione a planilha do SME")

#         # Se um arquivo foi selecionado:
#         if arquivo:
#             # Salvo o caminho do arquivo.
#             arquivo_sme.set(arquivo)
#     def selecionar_sma():
#         arquivo = filedialog.askopenfilename(title="Selecione a planilha do SMA")
#         if arquivo:
#             arquivo_sma.set(arquivo)
#     def selecionar_scc():
#         arquivo = filedialog.askopenfilename(title="Selecione a planilha do SCC")
#         if arquivo:
#             arquivo_scc.set(arquivo)
#     def selecionar_ssc():
#         arquivo = filedialog.askopenfilename(title="Selecione a planilha do SSC")
#         if arquivo:
#             arquivo_ssc.set(arquivo)
#     def selecionar_outros():
#         arquivo = filedialog.askopenfilename(title="Selecione a planilha dos Outros Institutos")
#         if arquivo:
#             arquivo_outros.set(arquivo)
#     def selecionar_sol():
#         arquivo = filedialog.askopenfilename(title="Selecione a planilha com os Dados da Solu√ß√£o do Modelo")
#         if arquivo:
#             arquivo_sol.set(arquivo)
#     def selecionar_base():
#         arquivo = filedialog.askopenfilename(title="Selecione a Base de Dados")
#         if arquivo:
#             arquivo_base.set(arquivo)



#     # Crio uma legenda para ficar ao lado do bot√£o.
#     lbl_sme = tk.Label(frame, text="Selecione a planilha do SME")
#     # Defino a posi√ß√£o do texto na janela.
#     lbl_sme.grid(row=0, column=0, pady=5, sticky='w')
#     # Crio o bot√£o para salvar o arquivo do SME.
#     btn_selecionar_sme = tk.Button(frame, textvariable=arquivo_sme, command=selecionar_sme, wraplength=250, width=40)
#     # Defino a posi√ß√£o do bot√£o na janela.
#     btn_selecionar_sme.grid(row=0, column=1, padx=5, pady=5)

#     # As linhas a seguir s√£o an√°logas.
#     lbl_sma = tk.Label(frame, text="Selecione a planilha do SMA")
#     lbl_sma.grid(row=1, column=0, pady=5, sticky='w')
#     btn_selecionar_sma = tk.Button(frame, textvariable=arquivo_sma, command=selecionar_sma, wraplength=250, width=40)
#     btn_selecionar_sma.grid(row=1, column=1, padx=5, pady=5)

#     lbl_scc = tk.Label(frame, text="Selecione a planilha do SCC")
#     lbl_scc.grid(row=2, column=0, pady=5, sticky='w')
#     btn_selecionar_scc = tk.Button(frame, textvariable=arquivo_scc, command=selecionar_scc, wraplength=250, width=40)
#     btn_selecionar_scc.grid(row=2, column=1, padx=5, pady=5)

#     lbl_ssc = tk.Label(frame, text="Selecione a planilha do SSC")
#     lbl_ssc.grid(row=3, column=0, pady=5, sticky='w')
#     btn_selecionar_ssc = tk.Button(frame, textvariable=arquivo_ssc, command=selecionar_ssc, wraplength=250, width=40)
#     btn_selecionar_ssc.grid(row=3, column=1, padx=5, pady=5)

#     lbl_outros = tk.Label(frame, text="Selecione a planilha dos Outros Institutos")
#     lbl_outros.grid(row=4, column=0, pady=5, sticky='w')
#     btn_selecionar_outros = tk.Button(frame, textvariable=arquivo_outros, command=selecionar_outros, wraplength=250, width=40)
#     btn_selecionar_outros.grid(row=4, column=1, padx=5, pady=5)

#     lbl_sol = tk.Label(frame, text="Selecione a planilha com os Dados da Solu√ß√£o do Modelo")
#     lbl_sol.grid(row=5, column=0, pady=5, sticky='w')
#     btn_selecionar_sol = tk.Button(frame, textvariable=arquivo_sol, command=selecionar_sol, wraplength=250, width=40)
#     btn_selecionar_sol.grid(row=5, column=1, padx=5, pady=5)

#     lbl_base = tk.Label(frame, text="Selecione a Base de Dados")
#     lbl_base.grid(row=6, column=0, pady=5, sticky='w')
#     btn_selecionar_base = tk.Button(frame, textvariable=arquivo_base, command=selecionar_base, wraplength=250, width=40)
#     btn_selecionar_base.grid(row=6, column=1, padx=5, pady=5)

#     # Defino uma fun√ß√£o que salva os valores das vari√°veis contendo o nome dos arquivos escolhidos.
#     def salvar_valores():
#         # Todas as condi√ß√µes a seguir seguem a l√≥gica de que, se um arquivo n√£o foi selecionado, uma janela avisando o ocorrido
#         # aparece, pedindo para o usu√°rio selecionar um arquivo no campo requerido.

#         if not arquivo_sme.get() or arquivo_sme.get() == "Selecione a planilha do SME":
#             messagebox.showwarning("Aviso", "Por favor, selecione a planilha do SME.")
#             return
#         if not arquivo_sma.get() or arquivo_sma.get() == "Selecione a planilha do SMA":
#             messagebox.showwarning("Aviso", "Por favor, selecione a planilha do SMA.")
#             return
#         if not arquivo_scc.get() or arquivo_scc.get() == "Selecione a planilha do SCC":
#             messagebox.showwarning("Aviso", "Por favor, selecione a planilha do SCC.")
#             return
#         if not arquivo_ssc.get() or arquivo_ssc.get() == "Selecione a planilha do SSC":
#             messagebox.showwarning("Aviso", "Por favor, selecione a planilha do SSC.")
#             return
#         if not arquivo_outros.get() or arquivo_outros.get() == "Selecione a planilha dos Outros Institutos":
#             messagebox.showwarning("Aviso", "Por favor, selecione a planilha dos Outros Institutos.")
#             return
#         if not arquivo_sol.get() or arquivo_sol.get() == "Selecione a planilha com os Dados da Solu√ß√£o do Modelo":
#             messagebox.showwarning("Aviso", "Por favor, selecione a planilha com os Dados da Solu√ß√£o do Modelo.")
#             return
#         if not arquivo_base.get() or arquivo_base.get() == "Selecione a Base de Dados":
#             messagebox.showwarning("Aviso", "Por favor, selecione a Base de Dados.")
#             return

#         # Se todos os arquivos tiverem sido selecionados corretamente, crio uma lista com os elencos das disciplinas.
#         elenco = [arquivo_sme.get(), arquivo_sma.get(), arquivo_scc.get(), arquivo_ssc.get(), arquivo_outros.get()]

#         # E chamo a fun√ß√£o que ir√° realizar o preenchimento de cada um dos arquivos.
#         preenchimento(elenco, arquivo_sol.get(), arquivo_base.get(), True)

#         # # Com a conclus√£o do preenchimento, aviso o usu√°rio dos novos arquivos preenchidos.
#         # messagebox.showinfo("Sucesso!", f"Os seguintes arquivos foram criados utilizando os Dados da Solu√ß√£o do Modelo:\n\
#         # - {os.path.basename(arquivo_sme.get()).replace('.xlsx', ' Preenchido.xlsx')}\n\
#         # - {os.path.basename(arquivo_sma.get()).replace('.xlsx', ' Preenchido.xlsx')}\n\
#         # - {os.path.basename(arquivo_scc.get()).replace('.xlsx', ' Preenchido.xlsx')}\n\
#         # - {os.path.basename(arquivo_ssc.get()).replace('.xlsx', ' Preenchido.xlsx')}\n\
#         # - {os.path.basename(arquivo_outros.get()).replace('.xlsx', ' Preenchido.xlsx')}\n\
#         # - {os.path.basename(arquivo_base.get()).replace('.xlsx', ' Preenchido.xlsx')}\n")

#         # E fecho a janela que havia sido criada.
#         nova_janela.destroy()

#     # Defino uma fun√ß√£o que salva os valores das vari√°veis contendo o nome dos arquivos escolhidos.
#     def salvar_valores1():
#         # Todas as condi√ß√µes a seguir seguem a l√≥gica de que, se um arquivo n√£o foi selecionado, uma janela avisando o ocorrido
#         # aparece, pedindo para o usu√°rio selecionar um arquivo no campo requerido.

#         if not arquivo_sme.get() or arquivo_sme.get() == "Selecione a planilha do SME":
#             messagebox.showwarning("Aviso", "Por favor, selecione a planilha do SME.")
#             return
#         if not arquivo_sma.get() or arquivo_sma.get() == "Selecione a planilha do SMA":
#             messagebox.showwarning("Aviso", "Por favor, selecione a planilha do SMA.")
#             return
#         if not arquivo_scc.get() or arquivo_scc.get() == "Selecione a planilha do SCC":
#             messagebox.showwarning("Aviso", "Por favor, selecione a planilha do SCC.")
#             return
#         if not arquivo_ssc.get() or arquivo_ssc.get() == "Selecione a planilha do SSC":
#             messagebox.showwarning("Aviso", "Por favor, selecione a planilha do SSC.")
#             return
#         if not arquivo_outros.get() or arquivo_outros.get() == "Selecione a planilha dos Outros Institutos":
#             messagebox.showwarning("Aviso", "Por favor, selecione a planilha dos Outros Institutos.")
#             return
#         if not arquivo_sol.get() or arquivo_sol.get() == "Selecione a planilha com os Dados da Solu√ß√£o do Modelo":
#             messagebox.showwarning("Aviso", "Por favor, selecione a planilha com os Dados da Solu√ß√£o do Modelo.")
#             return
#         if not arquivo_base.get() or arquivo_base.get() == "Selecione a Base de Dados":
#             messagebox.showwarning("Aviso", "Por favor, selecione a Base de Dados.")
#             return



#         # Se todos os arquivos tiverem sido selecionados corretamente, crio uma lista com os elencos das disciplinas.
#         elenco = [arquivo_sme.get(), arquivo_sma.get(), arquivo_scc.get(), arquivo_ssc.get(), arquivo_outros.get()]

#         escolhas_preenchimento(elenco, arquivo_sol.get(), arquivo_base.get())


#     # Defino um bot√£o e sua posi√ß√£o na janela para chamar a fun√ß√£o que salva os nomes dos arquivos.

#     btn_salvar1 = ttk.Button(frame, text="Preencher Planilhas com escolhas do usu√°rio", command=salvar_valores1)
#     btn_salvar1.grid(row=7, column=0, pady=10)

#     btn_salvar2 = ttk.Button(frame, text="Preencher Planilhas com a Solu√ß√£o Completa", command=salvar_valores)
#     btn_salvar2.grid(row=7, column=1, pady=10)

"""## Escolhas de Preenchimento"""

# Fun√ß√£o que define uma janela para o menu de preenchimento dos arquivos.
from google.colab import files
from IPython.display import clear_output
import pandas as pd
import ipywidgets as widgets
from IPython.display import display

def escolhas_preenchimento(elenco1, file_path_sol1, file_path_base1):
    """
    Fun√ß√£o para selecionar aulas a serem fixadas e preencher planilhas
    Par√¢metros:
    - elenco1: Lista de caminhos para planilhas dos departamentos
    - file_path_sol1: Caminho da planilha com dados da solu√ß√£o
    - file_path_base1: Caminho da base de dados
    """
    
    clear_output(wait=True)
    print("=== SELECIONAR AULAS PARA FIXAR ===")
    
    # Carregar dados da solu√ß√£o
    try:
        df = pd.read_excel(file_path_sol1)
        df = df.sort_values(by=['Disciplina'], ignore_index=True)
    except Exception as e:
        print(f"‚ùå Erro ao carregar arquivo de solu√ß√£o: {str(e)}")
        input("\nPressione Enter para voltar...")
        return
    
    # Criar interface interativa
    print("\nüîç Selecione as aulas que deseja fixar (manter na mesma sala):")
    
    # Widgets para sele√ß√£o
    checkboxes = []
    output = widgets.Output()
    
    with output:
        # Cabe√ßalho
        header = widgets.HBox([
            widgets.Label(value="Disciplina", layout=widgets.Layout(width='300px')),
            widgets.Label(value="Hor√°rio", layout=widgets.Layout(width='150px')),
            widgets.Label(value="Sala", layout=widgets.Layout(width='100px')),
            widgets.Label(value="Inscritos", layout=widgets.Layout(width='80px')),
            widgets.Label(value="Fixar", layout=widgets.Layout(width='80px'))
        ])
        display(header)
        
        # Linhas com dados e checkboxes
        for d in df.index:
            hbox = widgets.HBox([
                widgets.Label(value=str(df.loc[d, 'Disciplina']), layout=widgets.Layout(width='300px')),
                widgets.Label(value=str(df.loc[d, 'Hor√°rio']), layout=widgets.Layout(width='150px')),
                widgets.Label(value=str(df.loc[d, 'Sala']), layout=widgets.Layout(width='100px')),
                widgets.Label(value=str(df.loc[d, 'Inscritos']), layout=widgets.Layout(width='80px')),
                widgets.Checkbox(value=False, layout=widgets.Layout(width='80px'))
            ])
            checkboxes.append(hbox)
            display(hbox)
    
    # Bot√£o para confirmar
    button = widgets.Button(description="Preencher planilhas com salas fixadas")
    
    def on_button_click(b):
        clear_output(wait=True)
        print("üîÑ Processando sele√ß√£o...")
        
        # Criar novo DataFrame com aulas selecionadas
        new_df = pd.DataFrame(columns=df.columns)
        for i, hbox in enumerate(checkboxes):
            if hbox.children[4].value:  # Verifica se o checkbox est√° marcado
                new_df.loc[len(new_df)] = df.loc[i]
        
        if new_df.empty:
            print("‚ö†Ô∏è Nenhuma aula foi selecionada para fixar!")
            input("\nPressione Enter para tentar novamente...")
            return escolhas_preenchimento(elenco1, file_path_sol1, file_path_base1)
        
        try:
            # Salvar arquivo tempor√°rio com aulas fixadas
            temp_path = file_path_sol1.replace('.xlsx',' com Fixadas.xlsx')
            new_df.to_excel(temp_path, sheet_name="Resultados", index=False)
            
            # Chamar fun√ß√£o de preenchimento
            preenchimento(elenco1, temp_path, file_path_base1, False)
            
            print("\n‚úÖ Planilhas preenchidas com sucesso!")
            print(f"- Aulas fixadas: {len(new_df)}")
            
        except PermissionError:
            print("‚ùå Erro: N√£o foi poss√≠vel salvar o arquivo")
            print("Verifique se o arquivo est√° aberto em outro programa")
        except Exception as e:
            print(f"‚ùå Ocorreu um erro inesperado:")
            print(str(e))
        
        input("\nPressione Enter para voltar ao menu principal...")
    
    button.on_click(on_button_click)
    
    # Exibir interface
    display(output, button)

# def escolhas_preenchimento(elenco1, file_path_sol1, file_path_base1):

#     elenco = elenco1

#     file_path_sol = file_path_sol1

#     file_path_base = file_path_base1

#     # Crio uma nova janela em cima da janela principal da interface.
#     nova_janela1 = tk.Toplevel(root)
#     nova_janela1.title("Selecione quais aulas devem ser fixadas")
#     nova_janela1.geometry("+250+150")



#     # Criando um Frame para conter o Canvas e a Scrollbar
#     frame_principal = tk.Frame(nova_janela1)
#     frame_principal.pack(fill=tk.BOTH, expand=True)

#     # Criando um Canvas dentro do Frame principal
#     canvas = tk.Canvas(frame_principal)
#     canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

#     # Criando uma Scrollbar para o Canvas
#     scrollbar = tk.Scrollbar(frame_principal, orient=tk.VERTICAL, command=canvas.yview)
#     scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

#     # Criando um Frame dentro do Canvas para colocar os checkboxes
#     frame_checkboxes = tk.Frame(canvas)

#     # Adicionando o Frame ao Canvas
#     canvas.create_window((0, 0), window=frame_checkboxes, anchor="nw")

#     df = pd.read_excel(file_path_sol)
#     # df = pd.read_excel('C:/Users/gabri/Est√°gio/C√≥digos/Endgame/Dados da Solu√ß√£o do Modelo.xlsx')

#     labels = ['Disciplina', 'Hor√°rio', 'Sala', 'Inscritos', 'Fixar sala']
#     for label in labels:
#         tk.Label(frame_checkboxes, text=label).grid(row=0, column=labels.index(label), pady=5, padx=5, sticky='ew')
#     ttk.Separator(frame_checkboxes, orient="horizontal").grid(row=1, column=0, columnspan=5, sticky="ew", pady=(0, 10))

#     df = df.sort_values(by=['Disciplina'], ignore_index=True)


#     vars_checkboxes = []  # Lista para armazenar as vari√°veis dos checkboxes
#     for d in df.index:
#         tk.Label(frame_checkboxes, text=df.loc[d, 'Disciplina']).grid(row=2+(2*d), column=0, pady=5, padx=5, sticky='ew')
#         tk.Label(frame_checkboxes, text=df.loc[d, 'Hor√°rio']).grid(row=2+(2*d), column=1, pady=5, padx=5, sticky='ew')
#         tk.Label(frame_checkboxes, text=df.loc[d, 'Sala']).grid(row=2+(2*d), column=2, pady=5, padx=5, sticky='ew')
#         tk.Label(frame_checkboxes, text=df.loc[d, 'Inscritos']).grid(row=2+(2*d), column=3, pady=5, padx=5, sticky='ew')
#         # tk.Label(frame_checkboxes, text='Fixar').grid(row=d+2, column=4, pady=5, padx=5, sticky='ew')
#         ttk.Separator(frame_checkboxes, orient="horizontal").grid(row=3+(2*d), column=0, columnspan=5, sticky="ew", pady=(0, 10))
#         var = tk.BooleanVar()
#         # checkbox = tk.Checkbutton(frame_checkboxes, text=opcao, variable=var)
#         tk.Checkbutton(frame_checkboxes, text='Fixar', variable=var).grid(row=2+(2*d), column=4, pady=5, padx=5, sticky='ew')
#         vars_checkboxes.append(var)  # Salvando a vari√°vel para futura refer√™ncia


#     # Atualizando o tamanho do Frame dentro do Canvas
#     def atualizar_scroll(event):
#         canvas.configure(scrollregion=canvas.bbox("all"))

#     frame_checkboxes.bind("<Configure>", atualizar_scroll)

#     # Configurando a Scrollbar para controlar o Canvas
#     canvas.configure(yscrollcommand=scrollbar.set)


#     def salvar_valores():

#         # print(elenco1, file_path_sol1, file_path_base1)
#         elenco = elenco1

#         file_path_sol = file_path_sol1

#         file_path_base = file_path_base1
#         # print(elenco, file_path_sol, file_path_base)
#         new_df = pd.DataFrame(columns=df.columns)
#         for var in vars_checkboxes:
#             if var.get():
#                 index = vars_checkboxes.index(var)
#                 new_df.loc[len(new_df)] = df.loc[index]

#         try:
#             new_df.to_excel(file_path_sol.replace('.xlsx',' com Fixadas.xlsx'), sheet_name="Resultados", index=False)
#         except PermissionError as e:
#                 if e.errno == 13:  # Erro de permiss√£o (arquivo aberto ou bloqueado)
#                     messagebox.showerror("Erro de Permiss√£o", 
#                                             (
#                                                 f"N√£o foi poss√≠vel salvar o arquivo {file_path_sol.replace('.xlsx',' com Fixadas.xlsx')}. "
#                                                 "Verifique se ele est√° aberto em outro programa (como o Excel) e tente novamente."
#                                             )
#                                         )
#                     return
#                 else:
#                     messagebox.showerror("Erro", f"Erro de permiss√£o:\n\n{str(e)}")
#                     return
#         except Exception as e:
#             # Para qualquer outro erro
#             messagebox.showerror("Erro inesperado!", f"Ocorreu um erro inesperado:\n\n{str(e)}")
#             return

#         # Se todos os arquivos tiverem sido selecionados corretamente, crio uma lista com os elencos das disciplinas.
#         # elenco = [arquivo_sme.get(), arquivo_sma.get(), arquivo_scc.get(), arquivo_ssc.get(), arquivo_outros.get()]

#         # E chamo a fun√ß√£o que ir√° realizar o preenchimento de cada um dos arquivos.
        
#         preenchimento(elenco, file_path_sol.replace('.xlsx',' com Fixadas.xlsx'), file_path_base, False)
        

        


#         # E fecho a janela que havia sido criada.
#         nova_janela1.destroy()


#     # Determinar a √∫ltima linha utilizada
#     ultima_linha = 2 + 2 * len(df)

#     ttk.Button(frame_checkboxes, text="Preencher planilhas com salas fixadas",
#                command=salvar_valores).grid(row=ultima_linha, column=3, pady=5, padx=5, sticky='ew')

#     nova_janela1.wait_window()

"""## Fun√ß√£o para preencher"""

# Fun√ß√£o que preenche os arquivos fornecidos pelo usu√°rio.

def preenchimento(lista_elenco, file_path_sol, file_path_base, preencher_elenco):
    # Abro a solu√ß√£o dada pelo modelo como um dataframe.
    solucao = pd.read_excel(file_path_sol)

    if preencher_elenco:
        # Para cada elenco na lista de elencos:
        for file_path_elenco in lista_elenco:
            # Leio e salvo o arquivo em uma vari√°vel.
            elenco = pd.read_excel(file_path_elenco)

            # Defino uma vari√°vel com o nome de um cabe√ßalho para ser encontrado, caso o cabe√ßalho n√£o seja a primeira linha da planilha.
            header_name = 'Disciplina (c√≥digo)'

            # Para cada linha e c√©lula da primeira coluna do dataframe:
            for i, valor in enumerate(elenco.loc[:,elenco.columns[0]]):
                # Se o valor da c√©lula for o nome do cabe√ßalho que estou procurando:
                if valor == header_name:
                    # Salvo o n√∫mero da linha do cabe√ßalho.
                    header_row = i+1
                    # E interrompo o loop.
                    break

            # Leio o arquivo da forma correta.
            elenco = pd.read_excel(file_path_elenco, header=header_row)

            # Para cada coluna da planilha:
            for col in range(len(elenco.columns)):
                # Verifico se tem um "\n" no texto do dataframe:
                if "\n" in elenco.columns[col]:
                    # Se houver, substituo ele por um " ".
                    elenco = elenco.rename(columns={elenco.columns[col] : elenco.columns[col].replace("\n", " ")})
                # Verifico se estou na coluna das salas:
                if "Sala" in elenco.columns[col]:
                    # Se estiver, substituo o nome da coluna por apenas "Sala"
                    elenco = elenco.rename(columns={elenco.columns[col] : "Sala"})

            # Abrir o arquivo como workbook
            wb = load_workbook(file_path_elenco)
            ws = wb.active

            # Para cada linha do dataframe:
            for d in range(len(elenco)):
                # Garanto que o c√≥digo de uma disciplina n√£o possui espa√ßos.
                elenco.loc[d, 'Disciplina (c√≥digo)'] = str(elenco.loc[d, 'Disciplina (c√≥digo)']).replace(' ', '')

                # Adiciono um tra√ßo '-' e o n√∫mero da turma ao nome da disciplina
                disciplina = str(elenco.loc[d, 'Disciplina (c√≥digo)']) + '-' + str(elenco.loc[d, 'Turma'])

                # Verifico se a disciplina em quest√£o foi inclu√≠da na solu√ß√£o:
                if disciplina in solucao['Disciplina'].tolist():
                    row = d+2
                    coluna = elenco.columns.get_loc('Sala')+1
                    ws.cell(row=header_row+row, column=coluna).value = None

                    solucao_filtrada = solucao[solucao['Disciplina'] == disciplina]

                    for i in range(len(solucao_filtrada)):
                        for a in solucao_filtrada.index:
                            if elenco.loc[d, 'Hor√°rio ' + str(i+1)] == solucao_filtrada.loc[a, 'Hor√°rio']:
                                if ws.cell(row=header_row+row, column=coluna).value:
                                    novo_valor = str(ws.cell(row=header_row+row, column=coluna).value) + ', ' + str(solucao_filtrada.loc[a, 'Sala'])
                                    ws.cell(row=header_row+row, column=coluna).value = novo_valor
                                else:
                                    ws.cell(row=header_row+row, column=coluna).value = str(solucao_filtrada.loc[a, 'Sala'])

            try:
                output_path = file_path_elenco.replace('.xlsx', ' Preenchido.xlsx')
                wb.save(output_path)
                # No Colab, precisamos disponibilizar o arquivo para download
                files.download(output_path)
            except Exception as e:
                print(f"Erro ao salvar o arquivo {file_path_elenco}: {str(e)}")
                return

    # Preencher a base de dados
    base = pd.ExcelFile(file_path_base)
    sheet_names = base.sheet_names
    base = pd.read_excel(file_path_base, sheet_name=sheet_names)

    for sheet in sheet_names[1:]:
        for d in range(len(base[sheet])):
            disciplina = base[sheet].loc[d, 'Disciplina (c√≥digo)']

            if disciplina in solucao['Disciplina'].tolist():
                base[sheet].loc[d, 'Sala'] = None
                solucao_filtrada = solucao[solucao['Disciplina'] == disciplina]

                novo_valor = ['0', '0', '0', '0']
                for i in range(4):
                    for a in solucao_filtrada.index:
                        if base[sheet].loc[d, 'Hor√°rio ' + str(i+1)] == solucao_filtrada.loc[a, 'Hor√°rio']:
                            novo_valor[i] = str(solucao_filtrada.loc[a, 'Sala'])

                salas_fixadas = novo_valor[0]
                for s in novo_valor[1:]:
                    salas_fixadas += ', ' + str(s)

                base[sheet].loc[d, 'Sala'] = salas_fixadas

    try:
        output_path = file_path_base.replace('.xlsx', ' Preenchido.xlsx')
        with pd.ExcelWriter(output_path, engine="openpyxl") as writer:
            for sheet in sheet_names:
                base[sheet].to_excel(writer, sheet_name=sheet, index=False)
        files.download(output_path)
    except Exception as e:
        print(f"Erro ao salvar o arquivo base: {str(e)}")
        return
    
    # Mensagem de sucesso
    if preencher_elenco:
        print("Sucesso! Os seguintes arquivos foram criados utilizando os Dados da Solu√ß√£o do Modelo:")
        for elenco in lista_elenco:
            print(f"- {os.path.basename(elenco.replace('.xlsx', ' Preenchido.xlsx'))}")
        print(f"- {os.path.basename(file_path_base.replace('.xlsx', ' Preenchido.xlsx'))}")
    else:
        print("Sucesso! O seguinte arquivo foi criado utilizando os Dados da Solu√ß√£o do Modelo:")
        print(f"- {os.path.basename(file_path_sol)}")
        print(f"- {os.path.basename(file_path_base.replace('.xlsx', ' Preenchido.xlsx'))}")
# def preenchimento(lista_elenco, file_path_sol, file_path_base, preencher_elenco):
#     # Abro a solu√ß√£o dada pelo modelo como um dataframe.
#     solucao = pd.read_excel(file_path_sol)


#     if preencher_elenco:
#         # Para cada elenco na lista de elencos:
#         for file_path_elenco in lista_elenco:
#             # Leio e salvo o arquivo em uma vari√°vel.
#             elenco = pd.read_excel(file_path_elenco)
#             # file_path = 'C:/Users/gabri/Est√°gio/C√≥digos/Endgame/Testes/Elenco SME_2025 testando.xlsx'
#             # sme = pd.read_excel(file_path)

#             # Defino uma vari√°vel com o nome de um cabe√ßalho para ser encontrado, caso o cabe√ßalho n√£o seja a primeira linha da planilha.
#             header_name = 'Disciplina (c√≥digo)'

#             # Para cada linha e c√©lula da primeira coluna do dataframe:
#             for i, valor in enumerate(elenco.loc[:,elenco.columns[0]]):
#                 # Se o valor da c√©lula for o nome do cabe√ßalho que estou procurando:
#                 if valor == header_name:
#                     # Salvo o n√∫mero da linha do cabe√ßalho.
#                     header_row = i+1

#                     # E interrompo o loop.
#                     break

#             # Leio o arquivo da forma correta.
#             elenco = pd.read_excel(file_path_elenco, header=header_row)

#             # Para cada coluna da planilha:
#             for col in range(len(elenco.columns)):
#                 # Verifico se tem um "\n" no texto do dataframe:
#                 if "\n" in elenco.columns[col]:
#                     # Se houver, substituo ele por um " ".
#                     elenco = elenco.rename(columns={elenco.columns[col] : elenco.columns[col].replace("\n", " ")})
#                 # Verifico se estou na coluna das salas:
#                 if "Sala" in elenco.columns[col]:
#                     # Se estiver, substituo o nome da coluna por apenas "Sala"
#                     elenco = elenco.rename(columns={elenco.columns[col] : "Sala"})



#             # Como ler o arquivo como um dataframe e salv√°-lo altera a estrutura da planilha, preciso abrir o arquivo como um
#             # workbook, e utilizarei o dataframe definido anteriormente para utilizar m√©todos de busca mais eficientes.
#             wb = load_workbook(file_path_elenco)
#             ws = wb.active

#             # Para cada linha do dataframe:
#             for d in range(len(elenco)):
#                 # Garanto que o c√≥digo de uma disciplina n√£o possui espa√ßos.
#                 elenco.loc[d, 'Disciplina (c√≥digo)'] = str(elenco.loc[d, 'Disciplina (c√≥digo)']).replace(' ', '')

#                 # Adiciono um tra√ßo '-' e o n√∫mero da turma ao nome da disciplina para ser igual
#                 # ao utilizado no modelo.
#                 disciplina = str(elenco.loc[d, 'Disciplina (c√≥digo)']) + '-' + str(elenco.loc[d, 'Turma'])

#                 # Verifico se a disciplina em quest√£o foi inclu√≠da na solu√ß√£o:
#                 if disciplina in solucao['Disciplina'].tolist():

#                     # Se foi, salvo a linha da disciplina com um acr√©scimo de duas unidades; uma para pular a linha do cabe√ßalho, e a outra para
#                     # igualar com os √≠ndices das linhas do workbook.
#                     row = d+2

#                     # Semelhantemente, salvo o √≠ndice da coluna de salas do dataframe com um acr√©scimo de 1.
#                     coluna = elenco.columns.get_loc('Sala')+1

#                     # Limpo o valor da c√©lula da sala da disciplina d, utilizando uma soma de √≠ndices para garantir
#                     # que a linha est√° correta.
#                     ws.cell(row=header_row+row, column=coluna).value = None

#                     # Agora, fa√ßo um pequeno filtro das linhas de solu√ß√£o da disciplina, ou seja,
#                     # filtro os dados da solu√ß√£o para analisar apenas os que pertencem √†s aulas da disciplina.
#                     solucao_filtrada = solucao[solucao['Disciplina'] == disciplina]


#                     # Antes de explicar cada linha do trecho seguinte, devo explicar a l√≥gica por tr√°s dele.
#                     # Com a solu√ß√£o filtrada, eu tenho, separadamente, os hor√°rios das aulas de uma disciplina e a sala
#                     # onde cada uma foi alocada. Dessa forma, eu consigo iterar no comprimento da solu√ß√£o filtrada,
#                     # que deve me dar o n√∫mero de colunas de hor√°rio que aquela disciplina possui.
#                     # E se eu cruzar essa itera√ß√£o com uma que verifica se uma das aulas corresponde com a atual coluna de hor√°rio,
#                     # eu consigo cruzar colocar, em ordem, qual a sala de cada aula.

#                     # Para cada linha dessa solu√ß√£o filtrada, que diz respeito a cada aula da disciplina:
#                     for i in range(len(solucao_filtrada)):
#                         # E para cada aula da disciplina na solu√ß√£o filtrada:
#                         for a in solucao_filtrada.index:
#                             # Verifico se o hor√°rio da coluna 'Hor√°rio i+1' bate com o hor√°rio da aula 'a':
#                             if elenco.loc[d, 'Hor√°rio ' + str(i+1)] == solucao_filtrada.loc[a, 'Hor√°rio']:
#                                 # Se os hor√°rios batem, verifico se algum outro hor√°rio j√° foi colocado na c√©lula:
#                                 if ws.cell(row=header_row+row, column=coluna).value:
#                                     # Se foi, defino o novo valor da c√©lula como o valor antigo somado com o novo, mas separado por uma v√≠rgula.
#                                     novo_valor = str(ws.cell(row=header_row+row, column=coluna).value) + ', ' + str(solucao_filtrada.loc[a, 'Sala'])

#                                     # E defino o valor da c√©lula com esse novo valor.
#                                     ws.cell(row=header_row+row, column=coluna).value = novo_valor

#                                 # Como eu havia limpado todas as c√©lulas de sala anteriormente, tenho certeza que n√£o h√° nenhum outro hor√°rio,
#                                 # ent√£o coloco o primeiro na c√©lula respectiva.
#                                 else:
#                                     ws.cell(row=header_row+row, column=coluna).value = str(solucao_filtrada.loc[a, 'Sala'])


#             try:
#                 # Ap√≥s isso, salvo um novo arquivo de elenco de mesmo nome, mas adicionando 'Preenchido' para saber qual √© qual.
#                 wb.save(file_path_elenco.replace('.xlsx', ' Preenchido.xlsx'))
#             except PermissionError as e:
#                 if e.errno == 13:  # Erro de permiss√£o (arquivo aberto ou bloqueado)
#                     messagebox.showerror("Erro de Permiss√£o", 
#                                             (
#                                                 f"N√£o foi poss√≠vel salvar o arquivo {file_path_sol.replace('.xlsx',' com Fixadas.xlsx')}. "
#                                                 "Verifique se ele est√° aberto em outro programa (como o Excel) e tente novamente."
#                                             )
#                                         )
#                     return
#                 else:
#                     messagebox.showerror("Erro", f"Erro de permiss√£o:\n\n{str(e)}")
#                     return
#             except Exception as e:
#                 # Para qualquer outro erro
#                 messagebox.showerror("Erro inesperado!", f"Ocorreu um erro inesperado:\n\n{str(e)}")
#                 return
        
        

#     # Com todos os elencos preenchidos, agora resta preencher a base de dados para o modelo.
#     # Assim, abro a base de dados como um arquivo Excel.
#     base = pd.ExcelFile(file_path_base)

#     # Salvo quais as planilhas do arquivo.
#     sheet_names = base.sheet_names

#     # E leio novamente o arquivo, mas como um dataframe com as planilhas corretas.
#     base = pd.read_excel(file_path_base, sheet_name=sheet_names)


#     # Para cada planilha de disciplinas, isto √©, para cada planilha ap√≥s a planilha de salas:
#     for sheet in sheet_names[1:]:
#         # Refa√ßo a mesma l√≥gica feita anteriormente. Verificarei se a disciplina foi alocada em alguma sala, filtrarei o dataframe,
#         # e cruzarei os dados da solu√ß√£o com os do dataframe, deixando o mesmo formato e ordem das salas para cada aula das disciplinas.
#         for d in range(len(base[sheet])):
#             disciplina = base[sheet].loc[d, 'Disciplina (c√≥digo)']

#             if disciplina in solucao['Disciplina'].tolist():
#                 base[sheet].loc[d, 'Sala'] = None
#                 solucao_filtrada = solucao[solucao['Disciplina'] == disciplina]


#                 novo_valor = ['0', '0', '0', '0']
#                 for i in range(4):
#                     for a in solucao_filtrada.index:
#                         if base[sheet].loc[d, 'Hor√°rio ' + str(i+1)] == solucao_filtrada.loc[a, 'Hor√°rio']:
#                             novo_valor[i] = str(solucao_filtrada.loc[a, 'Sala'])

#                 salas_fixadas = novo_valor[0]
#                 for s in novo_valor[1:]:
#                     salas_fixadas += ', ' + str(s)

#                 base[sheet].loc[d, 'Sala'] = salas_fixadas

#     try:
#         # Com o novo dataframe constru√≠do, salvo-o como arquivo Excel com o nome alterado para distin√ß√£o.
#         with pd.ExcelWriter(file_path_base.replace('.xlsx', ' Preenchido.xlsx'), engine="openpyxl") as writer:
#             for sheet in sheet_names:
#                 base[sheet].to_excel(writer, sheet_name=sheet, index=False)
#     except PermissionError as e:
#         if e.errno == 13:  # Erro de permiss√£o (arquivo aberto ou bloqueado)
#             messagebox.showerror("Erro de Permiss√£o", 
#                                     (
#                                         f"N√£o foi poss√≠vel salvar o arquivo {file_path_sol.replace('.xlsx',' com Fixadas.xlsx')}. "
#                                         "Verifique se ele est√° aberto em outro programa (como o Excel) e tente novamente."
#                                     )
#                                 )
#             return
#         else:
#             messagebox.showerror("Erro", f"Erro de permiss√£o:\n\n{str(e)}")
#             return
#     except Exception as e:
#         # Para qualquer outro erro
#         messagebox.showerror("Erro inesperado!", f"Ocorreu um erro inesperado:\n\n{str(e)}")
#         return
    
#     if preencher_elenco:
#         # Com a conclus√£o do preenchimento, aviso o usu√°rio dos novos arquivos preenchidos.
#         messagebox.showinfo("Sucesso!", f"O seguinte arquivo foi criado utilizando os Dados da Solu√ß√£o do Modelo:\n\
#         - {os.path.basename(lista_elenco[0].replace('.xlsx', ' Preenchido.xlsx'))}\n\
#         - {os.path.basename(lista_elenco[1].replace('.xlsx', ' Preenchido.xlsx'))}\n\
#         - {os.path.basename(lista_elenco[2].replace('.xlsx', ' Preenchido.xlsx'))}\n\
#         - {os.path.basename(lista_elenco[3].replace('.xlsx', ' Preenchido.xlsx'))}\n\
#         - {os.path.basename(lista_elenco[4].replace('.xlsx', ' Preenchido.xlsx'))}\n\
#         - {os.path.basename(file_path_base.replace('.xlsx', ' Preenchido.xlsx'))}\n")
#     else:
#         # Com a conclus√£o do preenchimento, aviso o usu√°rio dos novos arquivos preenchidos.
#         messagebox.showinfo("Sucesso!", f"O seguinte arquivo foi criado utilizando os Dados da Solu√ß√£o do Modelo:\n\
#         - {os.path.basename(file_path_sol)}\n\
#         - {os.path.basename(file_path_base.replace('.xlsx', ' Preenchido.xlsx'))}\n")

import os
from google.colab import drive
from IPython.display import clear_output

# 1. Configura√ß√£o do Google Drive
def setup_drive():
    """Monta o Google Drive e cria a estrutura de pastas"""
    # Monta o Google Drive
    drive.mount('/content/drive')
    
    # Caminho base no Drive (pode ser ajustado)
    drive_path = '/content/drive/MyDrive/Estagio-SVGrad'
    
    # Cria a pasta principal se n√£o existir
    os.makedirs(drive_path, exist_ok=True)
    
    # Cria a estrutura de pastas
    saidas_path = os.path.join(drive_path, "Sa√≠das da Interface")
    subpastas = ["Planilhas de Dados", "Sa√≠das do Modelo"]
    
    os.makedirs(saidas_path, exist_ok=True)
    for subpasta in subpastas:
        os.makedirs(os.path.join(saidas_path, subpasta), exist_ok=True)
    
    return saidas_path

# Iniciar a interface

"""Exibe o menu principal e gerencia as op√ß√µes"""
saidas = setup_drive()
executando = True

while executando:
    clear_output(wait=True)
    print("=== MENU PRINCIPAL ===")
    print("1. Construir Planilha com os dados das Aulas")
    print("2. Construir Planilha com os dados do J√∫piterWeb")
    print("3. Construir Base de Dados do Modelo")
    print("4. Construir Base de Dados de Pior Caso")
    print("5. Verificar Dados e Executar Modelo")
    print("6. Relat√≥rio de Espa√ßos Livres")
    print("7. Preencher planilhas com Dados da Solu√ß√£o")
    print("S. Sair")
    print("======================")
    
    opcao = input("Digite o n√∫mero da op√ß√£o desejada: ").strip().upper()
    
    if opcao == '1':
        planilha_dep(jupiter=False)
        input("\nPressione Enter para continuar...")
    elif opcao == '2':
        planilha_dep(jupiter=True)
        input("\nPressione Enter para continuar...")
    elif opcao == '3':
        base_dados(pior_caso=False)
        input("\nPressione Enter para continuar...")
    elif opcao == '4':
        base_dados(pior_caso=True)
        input("\nPressione Enter para continuar...")
    elif opcao == '5':
        execute()
        input("\nPressione Enter para continuar...")
    elif opcao == '6':
        analise_vazios()
        input("\nPressione Enter para continuar...")
    elif opcao == '7':
        preencher_planilha_dados()
        input("\nPressione Enter para continuar...")
    elif opcao == 'S':
        executando = False
    else:
        print("Op√ß√£o inv√°lida! Tente novamente.")
        input("\nPressione Enter para continuar...")

print("\nObrigado por utilizar a interface!")

