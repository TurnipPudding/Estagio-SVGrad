# -*- coding: utf-8 -*-
"""Interface final.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/github/TurnipPudding/Estagio-SVGrad/blob/Testando_proibir_horarios_com_eta/Interface%20final.ipynb

## Imports
"""
from google.colab import files
from IPython.display import clear_output

import pandas as pd # Biblioteca Pandas para trabalhar com dataframes e planilhas do Excel.
import subprocess # Biblioteca Subprocess para chamar a execu√ß√£o de scripts/outros c√≥digos em Python.
import os # Biblioteca OS para auxiliar na cria√ß√£o e salvamento de arquivos.
# Biblioteca Openpyxl para trabalhar com planilhas do Excel de forma mais elaborada.
import openpyxl
from openpyxl import Workbook
from openpyxl.styles import PatternFill, Alignment, Border, Side
from openpyxl.utils import get_column_letter
from openpyxl import load_workbook
from openpyxl.formatting.rule import DataBar, FormatObject, Rule
from datetime import datetime, timedelta # Fun√ß√µes para a leitura de hor√°rios de aula
import sys

"""# Teste de Interface mais Clara

## Padroniza dataframe
"""

# Fun√ß√£o que padroniza os dataframes para terem o mesmo formato.
def padroniza_dataframe(file_name, header_row, ano):
    # Leio o dataframe correto, com a linha do cabe√ßalho.
    df = pd.read_excel(file_name, header=header_row)
    # print(df['Hor√°rio 4'])
    # Primeiramente, para cada cabe√ßalho/coluna 'col' do dataframe.
    for col in range(len(df.columns)):
        # Verifico se tem um "\n" no texto do dataframe.
        if "\n" in df.columns[col]:
            # Se houver, substituo ele por um " ".
            df = df.rename(columns={df.columns[col] : df.columns[col].replace("\n", " ")})
        # Verifico se estou na coluna das salas - "Sala (a definir)".
        if "Sala" in df.columns[col]:
            # Se estiver, substituo o nome da coluna por apenas "Sala".
            df = df.rename(columns={df.columns[col] : "Sala"})

    for idx, row in df.iterrows():
        df.loc[idx, 'Deve ser alocada no ICMC?'] = str(df.loc[idx, 'Deve ser alocada no ICMC?']).replace(' ', '')
        if df.loc[idx, 'Deve ser alocada no ICMC?'] == 'x':
            df.loc[idx, 'Deve ser alocada no ICMC?'] = 'X'
    # Filtro o dataframe para fazer a edi√ß√£o apenas nas disciplinas que importam.
    # Isto √©, eu passo a trabalhar apenas com as disciplinas marcadas com um 'X' que devem ser alocadas no ICMC.
    df = df[df['Deve ser alocada no ICMC?'] == 'X']

    # Ap√≥s editar os cabe√ßalhos, verifico se existe um cabe√ßalho chamado "Hor√°rio 4" no dataframe.
    if "Hor√°rio 3" not in df.columns:
        # Se n√£o houver, eu o adiciono no dataframe. Primeiro, procuro pelo cabe√ßalho "Hor√°rio 3", e insiro a nova coluna ao lado.
        df.insert(df.columns.get_loc("Hor√°rio 2") + 1, "Hor√°rio 3", pd.NA)

    # Ap√≥s editar os cabe√ßalhos, verifico se existe um cabe√ßalho chamado "Hor√°rio 4" no dataframe.
    if "Hor√°rio 4" not in df.columns:
        # Se n√£o houver, eu o adiciono no dataframe. Primeiro, procuro pelo cabe√ßalho "Hor√°rio 3", e insiro a nova coluna ao lado.
        df.insert(df.columns.get_loc("Hor√°rio 3") + 1, "Hor√°rio 4", pd.NA)

    if "observa√ß√µes" in df.columns:
        df = df.rename(columns={"observa√ß√µes" : "Observa√ß√µes"})

    if "Observa√ß√µes" not in df.columns:
        df.insert(df.columns.get_loc("Hor√°rio 4") + 1, "Observa√ß√µes", pd.NA)

    # Salvo o nome dos cabe√ßalhos do dataframe ap√≥s as edi√ß√µes.
    headers = df.columns

    # Preencho os espa√ßos vazios da coluna de uso de laborat√≥rios com "N√£o". Dessa forma, o usu√°rio s√≥ precisa indicar qual disciplina
    # requer um laborat√≥rio.
    df['Utilizar√° laborat√≥rio? (sim ou n√£o)'] = df['Utilizar√° laborat√≥rio? (sim ou n√£o)'].fillna("N√£o")
    # print(df['Utilizar√° laborat√≥rio? (sim ou n√£o)'])

    # Busco e listo por disciplinas cuja Turma n√£o foi definida.
    turmas0 = df[df['Turma'].isna()].index.tolist()
    # Se existirem tais disciplinas, uma janela √© aberta para indicar as linhas do arquivo que possuem turmas vazias.
    if len(turmas0) != 0:
        messagebox.showwarning(f"Aviso!", 
                               (
                                   f"A(s) linha(s) {[d + header_row + 2 for d in turmas0]} do arquivo {file_name} "
                                   f"possuem turmas n√£o identificadas. Verifique qual a turma da disciplina."
                                )
                            )
        return None

    # Adiciono mais duas colunas no dataframe, uma para colocar o n√∫mero de inscritos das disciplinas, e outra para o ano dos dados.
    df.insert(df.columns.get_loc(headers[-1]), "Vagas por disciplina", "")
    df.insert(df.columns.get_loc(headers[-1]), "Ano dos dados", ano)

    # Alguns hor√°rios das disciplinas podem ter sido definidos com um tra√ßo diferente do usual do teclado.
    # Por isso, eu busco em cada coluna de hor√°rios por esses poss√≠veis tra√ßos errados, pois eles prejudicam a leitura das disciplinas.
    # Para cada coluna de hor√°rio:
    for header in ['Hor√°rio 1', 'Hor√°rio 2', 'Hor√°rio 3', 'Hor√°rio 4']:
        # Para cada linha do dataframe:
        for d in df.index:
            # Verifico se o tra√ßo anormal est√° na c√©lula em quest√£o.
            if "‚Äì" in str(df.loc[d, header]):
                # Se estiver, substituo-o pelo tra√ßo normal.
                df.loc[d, header] = df.loc[d, header].replace('‚Äì', '-')
            if not pd.isna(df.loc[d, header]) \
                and "-" not in str(df.loc[d, header]) \
                    and not (df.loc[d, header] == ""):
                # print((df.loc[d, header]) == "")
                messagebox.showwarning(f"Aviso! H√° um hor√°rio de aula n√£o padronizado!",
                                   (
                                       f"Verifique a linha {d+header_row+2} da coluna {header} do arquivo {file_name}.\n"
                                       f"Padr√£o correto: 'Segunda - 08:10/09:50'\n"
                                       f"Provavelmente, falta um '-' entre o dia da semana e o hor√°rio da aula."
                                   )
                                )
                return None
            print(len(str(df.loc[d, header]).split("-")))
            if not pd.isna(df.loc[d, header]) and len(str(df.loc[d, header]).split("-")) > 2:
                messagebox.showwarning(f"Aviso! H√° um hor√°rio de aula n√£o padronizado!",
                                   (
                                       f"Verifique a linha {d+header_row+2} da coluna {header} do arquivo {file_name}.\n"
                                       f"Padr√£o correto: 'Segunda - 08:10/09:50'\n"
                                       f"Provavelmente, h√° mais de um '-' na c√©lula."
                                   )
                                )
                return None

    # Adiciono 4 colunas para anotar poss√≠veis salas onde as aulas ficam PROIBIDAS de serem alocadas.
    # Cada coluna refere-se a uma coluna de hor√°rios, fazendo com que as salas listadas em uma coluna afetem apenas a aula de mesma coluna.
    # Ex: Adicionar a sala 3-009 na segunda coluna de proibi√ß√£o faz com que a aula do Hor√°rio 2 de uma disciplina n√£o possa ser na 3-009.
    df.insert(df.columns.get_loc(headers[-1]), "Proibir Hor√°rio 1", pd.NA)
    df.insert(df.columns.get_loc(headers[-1]), "Proibir Hor√°rio 2", pd.NA)
    df.insert(df.columns.get_loc(headers[-1]), "Proibir Hor√°rio 3", pd.NA)
    df.insert(df.columns.get_loc(headers[-1]), "Proibir Hor√°rio 4", pd.NA)

    # Retorno o dataframe com todas as padroniza√ß√µes necess√°rias.
    return df

"""## Tooltip"""

# Classe Tooltip utilizada para mostrar textos ao sobrevoar o mouse em alguma parte da interface.
class Tooltip:
    def __init__(self, widget, text):
        self.widget = widget
        self.text = text
        self.tooltip_window = None

        # Eventos para mostrar e ocultar o tooltip
        widget.bind("<Enter>", self.show_tooltip)
        widget.bind("<Leave>", self.hide_tooltip)

    def show_tooltip(self, event=None):
        # Cria a janela do tooltip
        if self.tooltip_window is not None:
            return

        x = self.widget.winfo_rootx() + 20  # Posi√ß√£o X do tooltip
        y = self.widget.winfo_rooty() + 20  # Posi√ß√£o Y do tooltip

        self.tooltip_window = tk.Toplevel(self.widget)
        self.tooltip_window.wm_overrideredirect(True)  # Remove bordas da janela
        self.tooltip_window.geometry(f"+{x}+{y}")

        label = tk.Label(
            self.tooltip_window,
            text=self.text,
            background="lightyellow",
            relief="solid",
            borderwidth=1,
            font=("Arial", 10)
        )
        label.pack(ipadx=5, ipady=3)

    def hide_tooltip(self, event=None):
        # Destr√≥i a janela do tooltip
        if self.tooltip_window:
            self.tooltip_window.destroy()
            self.tooltip_window = None

"""## Ler planilhas dos institutos (Base de dados das aulas e do jupiter)"""

# Fun√ß√£o para criar a base de dados das aulas e a dos dados do J√∫piterWeb.
# Seu par√¢metro 'jupiter' refere-se a uma vari√°vel booleana, que recebe o valor True caso seja o momento de criar a Base de Dados do J√∫piter,
# e False caso contr√°rio.

def planilha_dep(jupiter):
    """
    Fun√ß√£o para constru√ß√£o de planilhas de dados usando upload interativo no Colab
    Par√¢metro:
    - jupiter: booleano que indica se √© para dados do J√∫piterWeb (True) ou das Aulas (False)
    """
    
    clear_output(wait=True)
    print(f"=== CONSTRUIR {'BASE DE DADOS DO J√öPITERWEB' if jupiter else 'BASE DE DADOS DAS AULAS'} ===")
    
    # Dicion√°rio para armazenar os arquivos carregados
    arquivos_carregados = {}
    
    # Fun√ß√£o auxiliar para upload com mensagem espec√≠fica
    def fazer_upload(mensagem):
        print(f"\n{mensagem}")
        print("Por favor, fa√ßa o upload do arquivo:")
        uploaded = files.upload()
        if not uploaded:
            print("Nenhum arquivo foi selecionado!")
            return None
        # Retorna o primeiro arquivo carregado
        return next(iter(uploaded))
    
    # Solicitar arquivos obrigat√≥rios
    arquivos_carregados['sme'] = fazer_upload("1. Planilha do SME (arquivo Excel)")
    arquivos_carregados['sma'] = fazer_upload("2. Planilha do SMA (arquivo Excel)")
    arquivos_carregados['scc'] = fazer_upload("3. Planilha do SCC (arquivo Excel)")
    arquivos_carregados['ssc'] = fazer_upload("4. Planilha do SSC (arquivo Excel)")
    
    if not jupiter:
        # Arquivos espec√≠ficos para dados das aulas
        arquivos_carregados['outros'] = fazer_upload("5. Planilha dos Outros Institutos (arquivo Excel)")
        arquivos_carregados['salas'] = fazer_upload("6. Planilha dos dados das salas (arquivo Excel)")
        ano_dados = input("\n7. Digite o ano dos dados: ").strip()
    else:
        # L√≥gica para m√∫ltiplos arquivos no modo J√∫piter
        lista_outros = []
        print("\n5. Arquivos dos Outros Institutos (fa√ßa upload de cada arquivo separadamente)")
        while True:
            print(f"\nArquivo {len(lista_outros)+1} (deixe vazio e pressione Enter para parar):")
            uploaded = files.upload()
            if not uploaded:
                break
            lista_outros.append(next(iter(uploaded)))
    
    nome_arquivo = input("\nDigite o nome para a base de dados (sem extens√£o): ").strip()
    
    # Valida√ß√£o dos inputs
    def validar_arquivo(arquivo, nome):
        if arquivo is None:
            print(f"Erro: Por favor, forne√ßa o {nome}")
            return False
        return True
    
    # Verifica arquivos obrigat√≥rios
    if not all([
        validar_arquivo(arquivos_carregados['sme'], "arquivo do SME"),
        validar_arquivo(arquivos_carregados['sma'], "arquivo do SMA"),
        validar_arquivo(arquivos_carregados['scc'], "arquivo do SCC"),
        validar_arquivo(arquivos_carregados['ssc'], "arquivo do SSC")
    ]):
        input("\nPressione Enter para tentar novamente...")
        return planilha_dep(jupiter)
    
    if not jupiter:
        if not all([
            validar_arquivo(arquivos_carregados['outros'], "arquivo dos Outros Institutos"),
            validar_arquivo(arquivos_carregados['salas'], "arquivo dos dados das salas"),
            ano_dados
        ]):
            input("\nPressione Enter para tentar novamente...")
            return planilha_dep(jupiter)
    else:
        if not lista_outros:
            print("Erro: Por favor, adicione pelo menos um arquivo dos Outros Institutos")
            input("\nPressione Enter para tentar novamente...")
            return planilha_dep(jupiter)
    
    if not nome_arquivo:
        print("Erro: Por favor, forne√ßa um nome para a base de dados")
        input("\nPressione Enter para tentar novamente...")
        return planilha_dep(jupiter)
    
    # Chamar a fun√ß√£o de concatena√ß√£o
    if not jupiter:
        concat_df(
            arquivos_carregados['sme'], arquivos_carregados['sma'], arquivos_carregados['scc'],
            arquivos_carregados['ssc'], arquivos_carregados['salas'], nome_arquivo, 
            ano_dados, jupiter, arquivos_carregados['outros']
        )
    else:
        concat_df(
            arquivos_carregados['sme'], arquivos_carregados['sma'], arquivos_carregados['scc'],
            arquivos_carregados['ssc'], None, nome_arquivo, 
            None, jupiter, lista_outros
        )
    
    print("\n‚úÖ Base de dados criada com sucesso!")
    input("\nPressione Enter para voltar ao menu principal...")
# def planilha_dep(jupiter):

#     # Crio uma nova janela em cima da janela principal da interface.
#     nova_janela = tk.Toplevel(root)

#     # Baseado em qual base de dados ser√° criada, defino um nome diferente para a janela.
#     if not jupiter:
#         nova_janela.title("Construir Base de Dados das Aulas")

#     else:
#         nova_janela.title("Construir Base de Dados do J√∫piterWeb")

#     # Crio o frame para armazenar os bot√µes e outros campos da nova janela.
#     frame = tk.Frame(nova_janela)
#     frame.pack(pady=10, padx=10)

#     # Defino v√°rias vari√°veis para armazenar os nomes dos arquivos para criar a base de dados.
#     arquivo_sme = tk.StringVar(value="Selecione a planilha do SME")
#     arquivo_sma = tk.StringVar(value="Selecione a planilha do SMA")
#     arquivo_scc = tk.StringVar(value="Selecione a planilha do SCC")
#     arquivo_ssc = tk.StringVar(value="Selecione a planilha do SSC")
#     arquivo_outros = tk.StringVar(value="Selecione a planilha dos Outros Institutos")
#     arquivo_salas = tk.StringVar(value="Selecione a planilha dos dados das salas")
#     # Defino uma vari√°vel para conter o ano dos dados fornecidos.
#     ano_dados = IntVar()
#     # Defino uma vari√°vel para conter o nome da nova base de dados.
#     nome_arquivo = tk.StringVar()
#     # Defino uma lista que ir√° conter os nomes de outros arquivos necess√°rios para criar uma base de dados.
#     lista_outros = []

#     # Defino as fun√ß√µes para selecionar arquivos.
#     def selecionar_sme():
#         # A classe filedialog faz com que o gerenciador de arquivos seja aberto para selecionar um arquivo.
#         # O usu√°rio seleciona o arquivo contendo a base de dados das aulas.
#         arquivo = filedialog.askopenfilename(title="Selecione a planilha do SME")

#         # Se um arquivo foi selecionado:
#         if arquivo:
#             # Salvo o caminho do arquivo.
#             arquivo_sme.set(arquivo)
#     def selecionar_sma():
#         arquivo = filedialog.askopenfilename(title="Selecione a planilha do SMA")
#         if arquivo:
#             arquivo_sma.set(arquivo)
#     def selecionar_scc():
#         arquivo = filedialog.askopenfilename(title="Selecione a planilha do SCC")
#         if arquivo:
#             arquivo_scc.set(arquivo)
#     def selecionar_ssc():
#         arquivo = filedialog.askopenfilename(title="Selecione a planilha do SSC")
#         if arquivo:
#             arquivo_ssc.set(arquivo)
#     # Se n√£o estiver criando a base de dados do J√∫piter:
#     if not jupiter:
#         # Tamb√©m defino as fun√ß√µes necess√°rias para salvar outros arquivos.
#         def selecionar_outros():
#             arquivo = filedialog.askopenfilename(title="Selecione a planilha dos Outros Institutos")
#             if arquivo:
#                 arquivo_outros.set(arquivo)
#         def selecionar_salas():
#             arquivo = filedialog.askopenfilename(title="Selecione a planilha dos dados das salas")
#             if arquivo:
#                 arquivo_salas.set(arquivo)



#     # Crio uma legenda para ficar ao lado do bot√£o.
#     lbl_sme = tk.Label(frame, text="Selecione a planilha do SME:")
#     # Defino a posi√ß√£o do texto na janela.
#     lbl_sme.grid(row=0, column=0, pady=5, sticky="w")
#     # Crio o bot√£o para salvar o arquivo do SME.
#     btn_selecionar_sme = tk.Button(frame, textvariable=arquivo_sme, command=selecionar_sme, wraplength=250, width=40)
#     # Defino a posi√ß√£o do bot√£o na janela.
#     btn_selecionar_sme.grid(row=0, column=1, padx=5, pady=5)

#     # As linhas a seguir s√£o an√°logas.
#     lbl_sma = tk.Label(frame, text="Selecione a planilha do SMA:")
#     lbl_sma.grid(row=1, column=0, pady=5, sticky="w")
#     btn_selecionar_sma = tk.Button(frame, textvariable=arquivo_sma, command=selecionar_sma, wraplength=250, width=40)
#     btn_selecionar_sma.grid(row=1, column=1, padx=5, pady=5)

#     lbl_scc = tk.Label(frame, text="Selecione a planilha do SCC:")
#     lbl_scc.grid(row=2, column=0, pady=5, sticky="w")
#     btn_selecionar_scc = tk.Button(frame, textvariable=arquivo_scc, command=selecionar_scc, wraplength=250, width=40)
#     btn_selecionar_scc.grid(row=2, column=1, padx=5, pady=5)

#     lbl_ssc = tk.Label(frame, text="Selecione a planilha do SSC:")
#     lbl_ssc.grid(row=3, column=0, pady=5, sticky="w")
#     btn_selecionar_ssc = tk.Button(frame, textvariable=arquivo_ssc, command=selecionar_ssc, wraplength=250, width=40)
#     btn_selecionar_ssc.grid(row=3, column=1, padx=5, pady=5)

#     # Como anteriormente, caso a base sendo criada n√£o √© a do J√∫piterWeb:
#     if not jupiter:
#         # Defino algumas legendas e bot√µes adicionais.
#         lbl_outros = tk.Label(frame, text="Selecione a planilha dos Outros Institutos:")
#         lbl_outros.grid(row=4, column=0, pady=5, sticky="w")
#         btn_selecionar_outros = tk.Button(frame, textvariable=arquivo_outros, command=selecionar_outros, wraplength=250, width=40)
#         btn_selecionar_outros.grid(row=4, column=1, padx=5, pady=5)

#         lbl_salas = tk.Label(frame, text="Selecione a planilha dos dados das salas:")
#         lbl_salas.grid(row=5, column=0, pady=5, sticky="w")
#         btn_selecionar_salas = tk.Button(frame, textvariable=arquivo_salas, command=selecionar_salas, wraplength=250, width=40)
#         btn_selecionar_salas.grid(row=5, column=1, padx=5, pady=5)


#         # Campo para inserir o valor
#         lbl_ano = tk.Label(frame, text="Insira o ano dos dados:")
#         lbl_ano.grid(row=6, column=0, sticky="w", pady=5)
#         campo_ano = tk.Entry(frame, textvariable=ano_dados)
#         campo_ano.grid(row=6, column=1, pady=5)

#     # Caso esteja sendo criada a base de dados do J√∫piter:
#     else:
#         # Defino um frame adicional na janela.
#         frame2 = tk.Frame(nova_janela)
#         frame2.pack(pady=10, padx=10)

#         # Defino algumas fun√ß√µes especiais para utilizar nesse novo frame.

#         # Defino uma fun√ß√£o para salvar um arquivo, da mesma forma como as fun√ß√µes anteriores.
#         def add_file():
#             file_path = filedialog.askopenfilename(title="Selecione um arquivo")
#             # A diferen√ßa, √© que se um arquivo foi selecionado, eu o salvo em uma lista, ao inv√©s de uma vari√°vel √∫nica.
#             if file_path:
#                 lista_outros.append(file_path)
#                 # E tamb√©m atualizo a lista visualizada no frame utilizando uma outra fun√ß√£o definida aqui.
#                 update_listbox()

#         # Defino uma fun√ß√£o para remover um arquivo da lista selecionado pelo usu√°rio.
#         def remove_selected():
#             # Tento executar as linhas a seguir, que s√≥ devem ser executadas se o usu√°rio escolher um arquivo da lista.
#             try:
#                 # Salvo o √≠ndice do arquivo selecionado pelo usu√°rio.
#                 selected_index = file_listbox.curselection()[0]
#                 # Removo o arquivo de mesmo √≠ndice da lista.
#                 lista_outros.pop(selected_index)
#                 # E atualizo a lista visualizada no frame.
#                 update_listbox()
#             # Se nenhum arquivo ser selecionado, a intera√ß√£o √© ignorada, e nada acontece.
#             except IndexError:
#                 pass

#         # Defino uma fun√ß√£o que atualiza a visualiza√ß√£o da lista no frame.
#         def update_listbox():
#             # Primeiro, limpo a lista que estava sendo mostrada anteriormente.
#             file_listbox.delete(0, tk.END)
#             # Depois disso, adiciono os arquivos da lista no visor.
#             for file in lista_outros:
#                 file_listbox.insert(tk.END, file)  # Adiciona os arquivos novamente

#         # Defino um bot√£o para adicionar arquivos, e sua posi√ß√£o na janela.
#         add_file_button = tk.Button(frame2, text="Adicionar Arquivo", command=add_file)
#         add_file_button.grid(row=0, column=0, pady=5, sticky="w")

#         # Defino uma lista para aparecer no visor do frame.
#         file_listbox = tk.Listbox(frame2, width=100, height=10)
#         file_listbox.grid(row=1, column=0, pady=5)

#         # Defino um bot√£o para remover arquivos, e sua posi√ß√£o na janela.
#         remove_file_button = tk.Button(frame2, text="Remover Selecionado", command=remove_selected)
#         remove_file_button.grid(row=0, column=0, pady=5, sticky="e")


#     # Defino uma legenda e sua posi√ß√£o na janela, que indicar√° o campo onde o usu√°rio digitar√° o nome do arquivo da base de dados.
#     lbl_arq = tk.Label(frame, text="Insira o nome para a base de dados:")
#     lbl_arq.grid(row=7, column=0, sticky="w", pady=5)
#     campo_arq = tk.Entry(frame, textvariable=nome_arquivo)
#     campo_arq.grid(row=7, column=1, pady=5)


#     # Defino uma fun√ß√£o que salva os valores das vari√°veis contendo o nome dos arquivos escolhidos.
#     def salvar_valores():
#         # Todas as condi√ß√µes a seguir seguem a l√≥gica de que, se um arquivo n√£o foi selecionado, uma janela avisando o ocorrido
#         # aparece, pedindo para o usu√°rio selecionar um arquivo no campo requerido.

#         if not arquivo_sme.get() or arquivo_sme.get() == "Selecione a planilha do SME":
#             messagebox.showwarning("Aviso", "Por favor, selecione a planilha do SME.")
#             return
#         if not arquivo_sma.get() or arquivo_sma.get() == "Selecione a planilha do SMA":
#             messagebox.showwarning("Aviso", "Por favor, selecione a planilha do SMA.")
#             return
#         if not arquivo_scc.get() or arquivo_scc.get() == "Selecione a planilha do SCC":
#             messagebox.showwarning("Aviso", "Por favor, selecione a planilha do SCC.")
#             return
#         if not arquivo_ssc.get() or arquivo_ssc.get() == "Selecione a planilha do SSC":
#             messagebox.showwarning("Aviso", "Por favor, selecione a planilha do SSC.")
#             return

#         # Caso n√£o seja a base dos dados do J√∫piter que est√° sendo feita:
#         if not jupiter:
#             # Verifico se os arquivos foram selecionados, e os campos preenchidos, novamente alertando se algo estiver faltando.
#             if not arquivo_outros.get() or arquivo_outros.get() == "Selecione a planilha dos Outros Institutos":
#                 messagebox.showwarning("Aviso", "Por favor, selecione a planilha dos Outros Institutos.")
#                 return
#             if not arquivo_salas.get() or arquivo_salas.get() == "Selecione a planilha dos dados das salas":
#                 messagebox.showwarning("Aviso", "Por favor, selecione a planilha dos dados das salas.")
#                 return
#             if not ano_dados.get():
#                 messagebox.showwarning("Aviso", "Por favor, insira o ano dos dados.")
#                 return
#         # Caso seja a base dos dados do J√∫piter que est√° sendo feita:
#         else:
#             # Verifico se foram adicionados arquivos com os dados dos outros institutos, alertando a aus√™ncia deles.
#             if len(lista_outros) == 0:
#                 messagebox.showwarning("Aviso", "Por favor, selecione a(s) planilha(s) dos Outros Institutos.")
#                 return

#         # Fa√ßo o mesmo alerta de antes caso o usu√°rio n√£o tenha fornecido o nome para a nova base de dados.
#         if not nome_arquivo.get():
#             messagebox.showwarning("Aviso", "Por favor, insira o nome da base de dados.")
#             return


#         # Baseando-se em qual base de dados est√° sendo criada, chamo uma fun√ß√£o para concatenar os dados dos arquivos fornecidos.
#         if not jupiter:
#             concat_df(arquivo_sme.get(), arquivo_sma.get(), arquivo_scc.get(),
#                       arquivo_ssc.get(), arquivo_salas.get(), nome_arquivo.get(), ano_dados.get(), jupiter, arquivo_outros.get())
#         else:
#             concat_df(arquivo_sme.get(), arquivo_sma.get(), arquivo_scc.get(),
#                       arquivo_ssc.get(), None, nome_arquivo.get(), None, jupiter, lista_outros)
#         # messagebox.showinfo("Sucesso", "Valores salvos com sucesso!")

#         # Terminada a concatena√ß√£o, destruo a janela de sele√ß√£o.
#         nova_janela.destroy()

#     # Defino um bot√£o e seu espa√ßo na janela para chamar a fun√ß√£o que salva os nomes dos arquivos.
#     btn_salvar = tk.Button(nova_janela, text="Criar base de dados", command=salvar_valores)
#     btn_salvar.pack(pady=10)

    # Uma importante ressalva. Por conta da maneira que os bot√µes, textos e campos podem ser colocados na janela,
    # √© poss√≠vel deixar certos bot√µes com uma ordem, mesmo que "o espa√ßo entre eles deveria estar vazio".
    # Por exemplo: no caso de estar fazendo a base de dados do J√∫piter, algumas posi√ß√µes podem estar denotadas como
    # linha 7 depois de linha 5, mas o espa√ßo onde estaria a linha 6 n√£o possui nada. Neste caso, a linha 7 √© jogada para cima,
    # preenchendo o lugar da linha 6.
    # Em outras palavras, enquanto a ordem for mantida de menor para maior, mesmo que possa "faltar" defini√ß√µes em determinadas linhas,
    # a ordem e espa√ßo dos objetos e widgets ser√° mantida.

"""### Ler Dataframe"""

# Fun√ß√£o que l√™ um dado arquivo.
def ler_df(caminho_arquivo):
    """
    Fun√ß√£o para ler arquivos de dados (Excel ou CSV) no Google Colab
    Retorna um DataFrame pandas ou None em caso de erro
    """
    try:
        if caminho_arquivo.endswith(('.xlsx', '.xls')):
            df = pd.read_excel(caminho_arquivo)
            return df
        elif caminho_arquivo.endswith('.csv'):
            df = pd.read_csv(caminho_arquivo, on_bad_lines='skip', sep=';', encoding='latin-1')
            return df
        else:
            print("‚ùå Erro: Formato de arquivo n√£o suportado!")
            print("Por favor, use arquivos .xlsx, .xls ou .csv")
            return None
            
    except Exception as e:
        print(f"‚ùå Erro ao carregar o arquivo {caminho_arquivo}:\n\n{e}")
        return None
    
# def ler_df(caminho_arquivo):
#     # Tento ler um arquivo.
#     try:
#         # Dependendo do tipo de arquivo, precisa utilizar leituras de dados diferentes. Vale ressaltar que essa fun√ß√£o l√™ apenas arquivos
#         # de planilha, como '.xlsx', '.xls' e '.csv'. Com o arquivo lido, retorno o dataframe correspondente.
#         if caminho_arquivo.endswith(('.xlsx', '.xls')):
#             df = pd.read_excel(caminho_arquivo)
#             return df
#         elif caminho_arquivo.endswith('.csv'):
#             df = pd.read_csv(caminho_arquivo, on_bad_lines='skip', sep=';', encoding='latin-1')
#             return df
#         else:
#             # Caso o arquivo fornecido seja incompat√≠vel, alerto o usu√°rio.
#             raise ValueError("Formato de arquivo n√£o suportado!")

#     # No caso de algum erro inesperado ocorrer, alerto o usu√°rio com uma mensagem e o nome do erro.
#     except Exception as e:
#             messagebox.showerror("Erro", f"Erro ao carregar o arquivo:\n{e}")
#     # return df

"""### Concatenar"""

# Fun√ß√£o que concatena as planilhas em um √∫nico arquivo.
# import os

def concat_df(SME, SMA, SCC, SSC, salas, nome_arquivo, ano, jupiter, outros):
    """
    Fun√ß√£o para concatenar planilhas em um √∫nico arquivo no Google Colab
    """
    files = []
    
    if not jupiter:
        # L√™ a planilha de salas
        print("\nüìÇ Lendo dados das salas...")
        df_salas = ler_df(salas)
        if df_salas is None:
            print("‚ùå Erro na leitura do arquivo de salas. Opera√ß√£o cancelada.")
            return

        name_files = [SME, SMA, SCC, SSC, outros]
        sheets = ["SME", "SMA", "SCC", "SSC", "Outros"]
    else:
        name_files = [SME, SMA, SCC, SSC]
        name_files.extend(outros)
        sheets = []

    # Processa cada arquivo
    for i, name in enumerate(name_files):
        # print(f"\nüìÇ Processando arquivo {i+1}/{len(name_files)}...")
        df = ler_df(name)
        if df is None:
            print(f"‚ùå Erro no arquivo {name}. Opera√ß√£o cancelada.")
            return

        if not jupiter:
            header_name = 'Disciplina (c√≥digo)'
            header_found = False
            
            for i, valor in enumerate(df.loc[:,df.columns[0]]):
                if valor == header_name:
                    header_row = i+1
                    df_padronizado = padroniza_dataframe(name, header_row, ano)
                    
                    if df_padronizado.empty:
                        print(f"‚ùå O arquivo '{os.path.basename(name)}' n√£o pode ser lido ou est√° vazio.")
                        print("Verifique se as disciplinas a serem alocadas est√£o marcadas.")
                        return
                        
                    files.append(df_padronizado)
                    header_found = True
                    break
                    
            if not header_found:
                print(f"‚ùå A coluna '{header_name}' n√£o foi encontrada no arquivo {os.path.basename(name)}")
                print("Verifique o cabe√ßalho do arquivo de entrada.")
                return
        else:
            try:
                new_name = str(df.loc[0, 'Disciplina'])[:3]
                sheets.append(new_name)
                files.append(df)
            except KeyError:
                print(f"‚ùå A coluna 'Disciplina' n√£o foi encontrada no arquivo {os.path.basename(name)}")
                print("Verifique o cabe√ßalho do arquivo de entrada.")
                return
            except Exception as e:
                print(f"‚ùå Ocorreu um erro inesperado:\n{e}")
                return

    # Garante a extens√£o .xlsx
    if not nome_arquivo.endswith(".xlsx"):
        nome_arquivo += ".xlsx"

    # Caminho de sa√≠da no Google Drive
    
    output_path = os.path.join('/content/drive/MyDrive/Estagio-SVGrad/Sa√≠das da Interface/Planilhas de Dados', nome_arquivo)
    
    try:
        # print("\nüîÑ Salvando arquivo concatenado...")
        with pd.ExcelWriter(output_path, engine="openpyxl") as writer:
            if not jupiter:
                df_salas.to_excel(writer, sheet_name="Salas", index=False)
            
            for sh in range(len(files)):
                files[sh].to_excel(writer, sheet_name=sheets[sh], index=False)
        
        print(f"\n‚úÖ Arquivo {nome_arquivo} criado com sucesso!")
        print(f"Local: {output_path}")
        
    except PermissionError:
        print(f"‚ùå N√£o foi poss√≠vel salvar o arquivo {nome_arquivo}")
        print("Verifique se ele est√° aberto em outro programa e tente novamente.")
    except Exception as e:
        print(f"‚ùå Ocorreu um erro inesperado:\n{e}")
# def concat_df(SME, SMA, SCC, SSC, salas, nome_arquivo, ano, jupiter, outros):
#     # Crio uma vari√°vel para listar os arquivos que ser√£o concatenados.
#     files = []
#     # Caso eu n√£o esteja concatenando os arquivos para a base do J√∫piterWeb:
#     if not jupiter:
#         # Leio a planilha com os dados das salas e salvo em um dataframe separado.
#         df_salas = ler_df(salas)

#         # Defino uma lista com os nomes dos arquivos a serem concatenados.
#         name_files = [SME, SMA, SCC, SSC, outros]

#         # Para cada nome de arquivo:
#         for name in name_files:
#             # Leio e salvo o arquivo em uma vari√°vel.
#             df = ler_df(name)

#             # Defino uma vari√°vel com o nome de um cabe√ßalho para ser encontrado, caso o cabe√ßalho n√£o seja a primeira linha da planilha.
#             header_name = 'Disciplina (c√≥digo)'

#             header_found = False
#             # Para cada linha e c√©lula da primeira coluna do dataframe:
#             for i, valor in enumerate(df.loc[:,df.columns[0]]):
#                 # Se o valor da c√©lula for o nome do cabe√ßalho que estou procurando:
#                 if valor == header_name:
#                     # Salvo o n√∫mero da linha do cabe√ßalho.
#                     header_row = i+1

#                     # Chamo a fun√ß√£o que ler√° o dataframe da forma correta e o deixar√° no formato padronizado.
#                     df_padronizado = padroniza_dataframe(name, header_row, ano)

#                     # Caso o dataframe n√£o esteja vazio, isto √©, se o arquivo foi lido corretamente e n√£o tinha nenhum erro aparente:
#                     if not df_padronizado.empty:
#                         # Adiciono o dataframe na lista dos que ser√£o concatenados.
#                         files.append(df_padronizado)
#                     # Caso tenha ocorrido um erro, retorno para a fun√ß√£o anterior, onde o usu√°rio verificar√° os arquivos selecionados.
#                     else:
#                         messagebox.showerror(f"Erro no arquivo",
#                                                 (
#                                                     f"O arquivo '{name}' n√£o pode ser lido, est√° vazio, ou n√£o foram marcadas as "
#                                                     f"disciplinas a serem alocadas. Verifique-o."
#                                                 )
#                                              )
#                         return

#                     # Se o cabe√ßalho foi encontrado, n√£o h√° motivo para continuar buscando, ent√£o encerro o loop dessa busca.
#                     header_found = True
#                     break

#             if not header_found:
#                 messagebox.showerror("Erro de Cabe√ßalho", 
#                                         (
#                                             f"A coluna '{header_name}' n√£o foi encontrada no arquivo {os.path.basename(name)}. "
#                                             "Verifique o cabe√ßalho do arquivo de entrada."
#                                         )
#                                     )
#                 return
#         # Com os arquivos lidos, salvo os nomes predeterminados das planilhas.
#         sheets = ["SME", "SMA", "SCC", "SSC", "Outros"]

#     # Para o caso de concatenando os arquivos para a base do J√∫piter:
#     else:
#         # Defino uma lista com os nomes dos arquivos a serem concatenados.
#         name_files = [SME, SMA, SCC, SSC]

#         # Adiciono os nomes dos arquivos dos outros institutos a essa lista de nomes.
#         name_files.extend(outros)

#         sheets = []

        
#     # Para cada nome de arquivo de outros institutos:
#         for name in name_files:
#             # Leio e salvo o arquivo em uma vari√°vel.
#             df = ler_df(name)

#             try:
#                 # Salvo a sigla das disciplinas daquele instituto. Eu considerei como sigla os 3 primeiros caracteres do nome de uma disciplina.
#                 # Ex: SME0230 pertence ao departamento do SME, 7600005 pertence ao departamento 760, e assim por diante.
#                 new_name = str(df.loc[0, 'Disciplina'])[:3]

#             except KeyError as e:
#                 coluna_faltando = str(e).strip("'")
#                 messagebox.showerror("Erro de Cabe√ßalho", 
#                                         (
#                                             f"A coluna 'Disciplina' n√£o foi encontrada no arquivo {os.path.basename(name)}. "
#                                             "Verifique o cabe√ßalho do arquivo de entrada."
#                                         )
#                                     )
#                 return

#             except Exception as e:
#                 # Caso ocorra algum erro, alerto o usu√°rio.
#                 messagebox.showerror("Erro inesperado", f"Ocorreu um erro inesperado:\n\n{e}")
#                 return
        
#             # Com o arquivo lido, salvo a sigla do instituto na lista de siglas.
#             sheets.append(new_name)

#             # Salvo o dataframe em na lista dos arquivos que ser√£o concatenados.
#             files.append(df)


#     # Com todos os dados obtidos e padronizados, verifico se o nome da base de dados termina com '.xlsx':
#     if not nome_arquivo.endswith(".xlsx"):
#         # Em caso negativo, adiciono essa terminologia.
#         nome_arquivo = nome_arquivo + ".xlsx"


#     # Com todos os dados obtidos e padronizados, verifico se o nome da base de dados termina com '.xlsx':
#     if not nome_arquivo.endswith(".xlsx"):
#         # Em caso negativo, adiciono essa terminologia.
#         nome_arquivo = nome_arquivo + ".xlsx"

#     try:
#         # Para finalmente concatenar os arquivos lidos, defino o nome da base de dados com o nome dispon√≠vel.
#         with pd.ExcelWriter(os.path.join(saidas, nome_arquivo), engine="openpyxl") as writer:
#             # Caso a base sendo definida n√£o for a do J√∫piter, preciso incluir a planilha de salas no arquivo.
#             if not jupiter:
#                 df_salas.to_excel(writer, sheet_name="Salas", index=False)
    
#             # Incluo todas as planilhas com as aulas dos departamentos no arquivo.
#             for sh in range(len(files)):
#                 files[sh].to_excel(writer, sheet_name=sheets[sh], index=False)
    
#         # Com o processo terminado, mostro uma mensagem confirmando que o arquivo foi criado com sucesso.
#         messagebox.showinfo("Sucesso!", f"Arquivo {nome_arquivo} criado com sucesso!\nVerifique a pasta {saidas} para encontr√°-lo.")

#     except PermissionError as e:
#         if e.errno == 13:  # Erro de permiss√£o (arquivo aberto ou bloqueado)
#             messagebox.showerror("Erro de Permiss√£o", 
#                                     (
#                                         f"N√£o foi poss√≠vel salvar o arquivo {nome_arquivo}. "
#                                         "Verifique se ele est√° aberto em outro programa (como o Excel) e tente novamente."
#                                     )
#                                 )
#             return
#         else:
#             messagebox.showerror("Erro", f"Erro de permiss√£o:\n\n{str(e)}")
#             return

#     except KeyError as e:
#         coluna_faltando = str(e).strip("'")
#         messagebox.showerror("Erro de Cabe√ßalho", 
#                                         (
#                                             f"A coluna 'Disciplina' n√£o foi encontrada no arquivo {os.path.basename(name)}. "
#                                             "Verifique o cabe√ßalho do arquivo de entrada."
#                                         )
#                                     )
#         return
    
#     except Exception as e:
#         # Para qualquer outro erro
#         messagebox.showerror("Erro inesperado!", f"Ocorreu um erro inesperado:\n\n{str(e)}")
#         return

"""## Construir base de dados completa"""

# Fun√ß√£o que cria a base de dados completa, isto √©, a que faz o cruzamento dos dados das aulas com os dados do J√∫piterWeb.
# Seu par√¢metro 'pior_caso' refere-se a uma vari√°vel booleana, que recebe o valor False caso seja o momento de criar a Base de Dados Completa,
# cruzando os dados das aulas com os dados do J√∫piterWeb, e True caso seja o momento de criar a Base de Dados de Pior Caso.
# A Base de Dados de Pior Caso faz uma simples compara√ß√£o entre os dados de dois anos distintos, misturando dados dos dois anos para
# montar uma an√°lise com os maiores n√∫meros de inscritos desses anos.
def base_dados(pior_caso):

    # Crio uma nova janela em cima da janela principal da interface.
    nova_janela = tk.Toplevel(root)

    # Baseado em qual base de dados ser√° criada, defino um nome diferente para a janela.
    if not pior_caso:
        nova_janela.title("Construir Base de Dados do Modelo")

    else:
        nova_janela.title("Construir Base de Dados de Pior Caso")

    # Crio o frame para armazenar os bot√µes e outros campos da nova janela.
    frame = tk.Frame(nova_janela)
    frame.pack(pady=10, padx=10)

    # Caso n√£o esteja fazendo a base de pior caso:
    if not pior_caso:
        # Defino algumas vari√°veis para salvar o arquivo com a base de dados das aulas,
        # a base de dados do J√∫piterWeb, e a base de dados dos ingressantes.
        arquivo_base = tk.StringVar(value="Selecione a planilha dos dados das aulas")
        arquivo_jptr = tk.StringVar(value="Selecione a planilha dos dados do j√∫piter")
        arquivo_ing = tk.StringVar(value="Selecione a planilha dos dados dos ingressantes")
        arquivo_esp = tk.StringVar(value="Selecione a planilha com os inscritos das disciplinas com espelho")
    # Caso esteja fazendo a base de pior caso:
    else:
        # Defino as vari√°veis para salvar os arquivos das bases de dados.
        arquivo_base1 = tk.StringVar(value="Selecione a base de dados mais recente")
        arquivo_base2 = tk.StringVar(value="Selecione a base de dados mais antiga")

    # Defino uma vari√°vel para salvar o nome da nova base de dados, seja ela a de pior caso ou n√£o.
    nome_arquivo = tk.StringVar()

    # Fun√ß√µes para selecionar um arquivo. Como a fun√ß√£o 'm√£e' (base_dados) pode ser utilizada em duas ocasi√µes diferentes,
    # essas fun√ß√µes para selecionar arquivos tamb√©m s√£o diferentes dependendo da ocasi√£o.
    def selecionar_um():
        # Caso n√£o esteja fazendo a base de pior caso:
        if not pior_caso:
            # O usu√°rio seleciona o arquivo contendo a base de dados das aulas.
            arquivo = filedialog.askopenfilename(title="Selecione a planilha dos dados das aulas")

            # Se um arquivo foi selecionado:
            if arquivo:
                # Salvo o caminho do arquivo.
                arquivo_base.set(arquivo)
        # Caso esteja fazendo a base de pior caso:
        else:
            # O usu√°rio seleciona o arquivo contendo a base de dados mais recente.
            arquivo = filedialog.askopenfilename(title="Selecione a base de dados mais recente")

            # Se um arquivo foi selecionado:
            if arquivo:
            # Salvo o caminho do arquivo.
                arquivo_base1.set(arquivo)
    def selecionar_dois():
        if not pior_caso:
            arquivo = filedialog.askopenfilename(title="Selecione a planilha dos dados do j√∫piter")
            if arquivo:
                arquivo_jptr.set(arquivo)
        else:
            arquivo = filedialog.askopenfilename(title="Selecione a base de dados mais antiga")
            if arquivo:
                arquivo_base2.set(arquivo)

    # Caso n√£o esteja fazendo a base de pior caso:
    if not pior_caso:
        # Defino uma outra fun√ß√£o para selecionar o arquivo com a base de dados dos ingressantes, com o mesmo funcionamento das demais.
        def selecionar_tres():
            arquivo = filedialog.askopenfilename(title="Selecione a planilha dos dados dos ingressantes")
            if arquivo:
                arquivo_ing.set(arquivo)
        # Defino uma fun√ß√£o para selecionar o arquivo com os inscritos das disciplinas com espelho.
        def selecionar_quatro():
            arquivo = filedialog.askopenfilename(title="Selecione a planilha com os inscritos das disciplinas com espelho")
            if arquivo:
                arquivo_esp.set(arquivo)

    # Caso n√£o esteja fazendo a base de pior caso:
    if not pior_caso:
        # Defino legendas e bot√µes na janela para o usu√°rio definir os arquivos necess√°rios.
        lbl_base = tk.Label(frame, text="Selecione a planilha dos dados das aulas")
        lbl_base.grid(row=0, column=0, pady=5, sticky="w")
        btn_selecionar_base = tk.Button(frame, textvariable=arquivo_base, command=selecionar_um, wraplength=250, width=40)
        btn_selecionar_base.grid(row=0, column=1, padx=5, pady=5)

        lbl_jptr = tk.Label(frame, text="Selecione a planilha dos dados do j√∫piter")
        lbl_jptr.grid(row=1, column=0, pady=5, sticky="w")
        btn_selecionar_jptr = tk.Button(frame, textvariable=arquivo_jptr, command=selecionar_dois, wraplength=250, width=40)
        btn_selecionar_jptr.grid(row=1, column=1, padx=5, pady=5)

        lbl_ing = tk.Label(frame, text="Selecione a planilha dos dados dos ingressantes")
        lbl_ing.grid(row=2, column=0, pady=5, sticky="w")
        btn_selecionar_ing = tk.Button(frame, textvariable=arquivo_ing, command=selecionar_tres, wraplength=250, width=40)
        btn_selecionar_ing.grid(row=2, column=1, padx=5, pady=5)

        lbl_esp = tk.Label(frame, text="Selecione a planilha com os inscritos das disciplinas com espelho")
        lbl_esp.grid(row=3, column=0, pady=5, sticky="w")
        btn_selecionar_esp = tk.Button(frame, textvariable=arquivo_esp, command=selecionar_quatro, wraplength=250, width=40)
        btn_selecionar_esp.grid(row=3, column=1, padx=5, pady=5)

    # Caso esteja fazendo a base de pior caso:
    else:
        # Defino legendas e bot√µes na janela para o usu√°rio definir os arquivos necess√°rios.
        lbl_base1 = tk.Label(frame, text="Selecione a base de dados mais recente")
        lbl_base1.grid(row=0, column=0, pady=5, sticky="w")
        btn_selecionar_base1 = tk.Button(frame, textvariable=arquivo_base1, command=selecionar_um, wraplength=250, width=40)
        btn_selecionar_base1.grid(row=0, column=1, padx=5, pady=5)

        lbl_base2 = tk.Label(frame, text="Selecione a base de dados mais antiga")
        lbl_base2.grid(row=1, column=0, pady=5, sticky="w")
        btn_selecionar_base2 = tk.Button(frame, textvariable=arquivo_base2, command=selecionar_dois, wraplength=250, width=40)
        btn_selecionar_base2.grid(row=1, column=1, padx=5, pady=5)

    # Defino a legenda e o campo na janela para o usu√°rio inserir o nome da nova base de dados.
    lbl_arq = tk.Label(frame, text="Insira o nome para a nova base de dados:")
    lbl_arq.grid(row=4, column=0, sticky="w", pady=5)
    campo_arq = tk.Entry(frame, textvariable=nome_arquivo)
    campo_arq.grid(row=4, column=1, pady=5)


    # Defino uma fun√ß√£o que salva os valores das vari√°veis contendo o nome dos arquivos escolhidos.
    def salvar_valores():
        # Caso n√£o esteja fazendo a base de pior caso:
        if not pior_caso:
            # Todas as condi√ß√µes a seguir seguem a l√≥gica de que, se um arquivo n√£o foi selecionado, uma janela avisando o ocorrido
            # aparece, pedindo para o usu√°rio selecionar um arquivo no campo requerido.

            if not arquivo_base.get() or arquivo_base.get() == "Selecione a planilha dos dados das aulas":
                messagebox.showwarning("Aviso", "Por favor, selecione a planilha dos dados das aulas.")
                return
            if not arquivo_jptr.get() or arquivo_jptr.get() == "Selecione a planilha dos dados do j√∫piter":
                messagebox.showwarning("Aviso", "Por favor, selecione a planilha dos dados do j√∫piter.")
                return
            if not arquivo_ing.get() or arquivo_ing.get() == "Selecione a planilha dos dados dos ingressantes":
                messagebox.showwarning("Aviso", "Por favor, selecione a planilha dos dados dos ingressantes.")
                return
            if not arquivo_esp.get() or arquivo_esp.get() == "Selecione a planilha com os inscritos das disciplinas com espelho":
                messagebox.showwarning("Aviso", "Por favor, selecione a planilha com os inscritos das disciplinas com espelho.")
                return

        # Caso esteja fazendo a base de pior caso:
        else:
            # Todas as condi√ß√µes a seguir seguem a l√≥gica de que, se um arquivo n√£o foi selecionado, uma janela avisando o ocorrido
            # aparece, pedindo para o usu√°rio selecionar um arquivo no campo requerido.
            if not arquivo_base1.get() or arquivo_base1.get() == "Selecione a base de dados mais recente":
                messagebox.showwarning("Aviso", "Por favor, selecione a primeira base de dados.")
                return
            if not arquivo_base2.get() or arquivo_base2.get() == "Selecione a base de dados mais antiga":
                messagebox.showwarning("Aviso", "Por favor, selecione a segunda base de dados.")
                return

        # Crio uma vari√°vel auxiliar para salvar o nome da nova base de dados dada pelo usu√°rio.
        nome = nome_arquivo.get()

        # Se o usu√°rio n√£o forneceu um nome para a nova base de dados:
        if not nome:
            # Uma janela alertando o ocorrido √© aberta.
            messagebox.showwarning("Aviso", "Por favor, insira o nome da nova base de dados.")
            return

        # Verifico se o nome da nova base de dados termina com '.xlsx':
        if not nome.endswith(".xlsx"):
            # Em caso negativo, adiciono essa terminologia.
            nome = nome + ".xlsx"


        # Caso n√£o esteja fazendo a base de pior caso:
        if not pior_caso:
            # Tento executar o script do c√≥digo respons√°vel em cruzar os dados das aulas com os do J√∫piter.
            try:
                file1 = arquivo_base.get()
                file2 = arquivo_jptr.get()
                file3 = arquivo_ing.get()
                file4 = arquivo_esp.get()
                # subprocess(["python", "jupiter sheet maker.py", [df_filename1, df_filename2, df_filename3]])
                subprocess.run(
                    # ["python", "jupiter sheet maker.py", file1, file2, file3, file4, nome],
                    [sys.executable, "jupiter sheet maker.py", file1, file2, file3, file4, nome],
                    check=True,
                    capture_output=True,
                    text=True
                    )
                
                # Com o processo terminado, mostro uma mensagem confirmando que o arquivo foi criado com sucesso.
                messagebox.showinfo("Sucesso!", f"Base de dados para o modelo criada com sucesso. Verifique o arquivo {nome}.")
                

            # Caso ocorra algum erro durante a execu√ß√£o do script, uma janela alertando o erro √© apresentada para o usu√°rio.
            except subprocess.CalledProcessError as e:
                if e.returncode == 1:
                    msg = e.stderr.strip() if e.stderr else "Erro desconhecido."
                    messagebox.showerror("Erro", f"Erro ao executar o script. Verifique os arquivos de entrada.\n\n{msg}")
                elif e.returncode == 2:
                    msg = e.stderr.strip() if e.stderr else "Erro desconhecido."
                    messagebox.showerror("Erro", f"Erro de permiss√£o. Verifique se o arquivo {nome} est√° aberto em outro programa.\n\n{msg}")
                elif e.returncode == 4:
                    msg = e.stderr.strip() if e.stderr else "Erro desconhecido."
                    messagebox.showerror("Erro", f"Erro ao executar o script:\n\n{msg}")
                else:
                    messagebox.showerror("Erro", f"Erro inesperado: {e}")
                return
            
            # Caso um erro inesperado ocorra, uma janela alertando o erro √© apresentada para o usu√°rio.
            except Exception as e:
                messagebox.showerror("Erro", f"Erro inesperado: {e}")
                return
            
            
        # Caso esteja fazendo a base de pior caso:
        else:
            # Leio os dois dataframes fornecidos pelo usu√°rio.
            df1 = pd.read_excel(arquivo_base1.get(), sheet_name=["Salas", "SME", "SMA", "SCC", "SSC", "Outros"])
            df2 = pd.read_excel(arquivo_base2.get(), sheet_name=["Salas", "SME", "SMA", "SCC", "SSC", "Outros"])

            # Chamo a fun√ß√£o que faz um dataframe com o maior n√∫mero de inscritos de cada ano.
            df_pior_caso = base_pior_caso(df1, df2, ["Salas", "SME", "SMA", "SCC", "SSC", "Outros"])
            try:
                # Com a base de pior caso feita, salvo-a em um arquivo de Excel com o nome fornecido pelo usu√°rio.
                with pd.ExcelWriter(os.path.join(saidas, nome), engine="openpyxl") as writer:
                    for sh, df_sh in df_pior_caso.items():
                        df_sh.to_excel(writer, sheet_name=sh, index=False)
                # Com o processo terminado, mostro uma mensagem confirmando que o arquivo foi criado com sucesso.
                messagebox.showinfo("Sucesso!", f"Arquivo {nome} criado com sucesso!\nVerifique a pasta {saidas} para encontr√°-lo.")

            except PermissionError as e:
                if e.errno == 13:  # Erro de permiss√£o (arquivo aberto ou bloqueado)
                    messagebox.showerror("Erro de Permiss√£o", 
                                            (
                                                f"N√£o foi poss√≠vel salvar o arquivo {nome_arquivo}. "
                                                "Verifique se ele est√° aberto em outro programa (como o Excel) e tente novamente."
                                            )
                                        )
                    return
                else:
                    messagebox.showerror("Erro", f"Erro de permiss√£o:\n\n{str(e)}")
                    return
            except Exception as e:
                # Para qualquer outro erro
                messagebox.showerror("Erro inesperado!", f"Ocorreu um erro inesperado:\n\n{str(e)}")
                return
    
            

        # messagebox.showinfo("Sucesso", "Valores salvos com sucesso!")
        # Terminada a cria√ß√£o da base de dados, destruo a janela de sele√ß√£o.
        nova_janela.destroy()

    # Defino um bot√£o e seu espa√ßo na janela para chamar a fun√ß√£o que salva os nomes dos arquivos.
    btn_salvar = tk.Button(nova_janela, text="Criar base de dados", command=salvar_valores)
    btn_salvar.pack(pady=10)

"""### Pior caso"""

# Fun√ß√£o que faz a an√°lise de pior caso.
# Note que df1 deve sempre ser a base de dados mais recente, enquanto df2 deve sempre ser a base de dados mais antiga.
def base_pior_caso(df1, df2, sheets):

    # df1 = pd.read_excel(df1_name, sheet_name=sheets)
    # df2 = pd.read_excel(df1_name, sheet_name=sheets)
    try:
    # Para cada planilha na base de dados mais recente:
        # for sh in df1.sheet_names[1:]:
        for sh in sheets[1:]:
            # Considerando que df1 e df2 possuem as mesmas planilhas (ou, pelo menos, deveriam), crio duas vari√°veis auxiliares
            # para salvar os dados a mesma planilha de ambas as bases.
            df1_sh = df1[sh]
            df2_sh = df2[sh]

            # Crio tamb√©m duas vari√°veis para salvar as colunas de disciplinas das bases como listas.
            l1 = df1_sh['Disciplina (c√≥digo)'].tolist()
            l2 = df2_sh['Disciplina (c√≥digo)'].tolist()

            # Para cada disciplina 'd' na lista de disciplinas da base de dados mais recente:
            for d in l1:
                # Verifico se 'd' est√° na lista de disciplinas da base de dados mais antiga:
                if d in l2:
                    # Em caso positivo, verifico se o n√∫mero de inscritos do ano mais recente da disciplina √© menor
                    # que o n√∫mero de inscritos do ano mais antigo da disciplina.
                    if df1[sh].loc[l1.index(d), 'Vagas por disciplina'] < df2[sh].loc[l2.index(d), 'Vagas por disciplina']:
                        # Se for o caso, ent√£o no ano anterior houveram mais inscritos, isto √©, no ano mais recente, pode ser que
                        # o n√∫mero de inscritos chegue at√© esse valor ou o ultrapasse.
                        # Por conta disso, atualizo o n√∫mero de inscritos e o ano dos dados da disciplina 'd' na base mais recente.
                        df1[sh].loc[l1.index(d), 'Vagas por disciplina'] = df2[sh].loc[l2.index(d), 'Vagas por disciplina']
                        df1[sh].loc[l1.index(d), 'Ano dos dados'] = df2[sh].loc[l2.index(d), 'Ano dos dados']

    except KeyError as e:
        coluna_faltando = str(e).strip("'")
        messagebox.showerror("Erro de Cabe√ßalho", 
                                (
                                    f"A coluna '{coluna_faltando}' n√£o foi encontrada em um dos arquivos. "
                                    "Verifique o cabe√ßalho dos arquivos de entrada."
                                )
                            )
        return
    
    except Exception as e:
        # Caso ocorra algum erro, alerto o usu√°rio.
        messagebox.showerror("Erro inesperado", f"Ocorreu um erro inesperado:\n\n{e}")
        return
    # Ap√≥s concluir a an√°lise, retorno a base de dados atualizada.
    return df1

"""## Executar"""

# Fun√ß√£o que faz a verifica√ß√£o de dados e execu√ß√£o do modelo.
def execute():
    # Crio uma nova janela em cima da janela principal da interface.
    nova_janela = tk.Toplevel(root)
    nova_janela.geometry("+200+200")
    nova_janela.title("Verificar Dados e Executar Modelo")

    # Crio o frame para armazenar os bot√µes e outros campos da nova janela.
    frame = tk.Frame(nova_janela)
    frame.pack(pady=10, padx=10)

    # Defino uma vari√°vel para salvar o arquivo com a base de dados para o modelo, seja ela a completa ou a de pior caso.
    arquivo_selecionado1 = tk.StringVar(value="Selecione uma base de dados")

    # Defino a fun√ß√£o para selecionar a base de dados.
    def selecionar_arquivo1():
        # O usu√°rio seleciona o arquivo contendo a base de dados das aulas.
        arquivo = filedialog.askopenfilename(title="Selecione uma base de dados")

        # Se um arquivo foi selecionado:
        if arquivo:
            # Salvo o caminho do arquivo.
            arquivo_selecionado1.set(arquivo)



    # Defino um bot√£o, e sua posi√ß√£o na janela, para o usu√°rio escolher a base de dados.
    btn_selecionar1 = tk.Button(frame, textvariable=arquivo_selecionado1,
                                command=selecionar_arquivo1, wraplength=250, width=40)
    btn_selecionar1.grid(row=0, column=0, padx=5, pady=5)


    # Defino uma linha de separa√ß√£o horizontal na janela, separando o bot√£o de sele√ß√£o de arquivo do bot√£o de verifica√ß√£o de dados.
    vd_separator = ttk.Separator(frame, orient="horizontal")
    vd_separator.grid(row=2, column=0, sticky="ew", pady=(0, 10))

    # Defino um bot√£o, e sua posi√ß√£o na janela, para o usu√°rio abrir o menu de verifica√ß√£o de dados.
    vd1 = ttk.Button(frame, text="Selecionar Verifica√ß√£o de Dados",
                     command=lambda: roda_script("verificar_dados.py", arquivo_selecionado1.get(), "", "", "", "", "", ""))
    vd1.grid(row=4, column=0, pady=5)

    # Defino uma linha de separa√ß√£o horizontal na janela, separando o bot√£o de verifica√ß√£o de dados do bot√£o de execu√ß√£o do modelo.
    em_separator = ttk.Separator(frame, orient="horizontal")
    em_separator.grid(row=5, column=0, sticky="ew", pady=(0,10))

    # Defino um bot√£o, e sua posi√ß√£o na janela, para o usu√°rio abrir o menu de execu√ß√£o do modelo.
    em = ttk.Button(frame, text="Selecionar Modelo", command=lambda: Novo_edit_config(file_name=arquivo_selecionado1.get()))
    em.grid(row=6, column=0, pady=5)

"""### Roda Script"""

# Fun√ß√£o que roda um script em Python. Seus par√¢metros s√£o vari√°veis fornecidas pelo usu√°rio, como qual script
# o nome da base de dados que ser√° lida, e o peso das vari√°veis do modelo.
def roda_script(script, nome, peso_x, peso_y, peso_v, peso_z, alpha, pref):

    # Crio uma janela para mostrar a sa√≠da do script, como prints importantes e at√© sa√≠das de erros.
    output_window = tk.Toplevel(root)
    output_window.title("Sa√≠da do Script")
    output_text = scrolledtext.ScrolledText(output_window, width=120, height=40)
    output_text.pack()

    # Tento executar o script escolhido pelo usu√°rio.
    try:
        # Executo o script utilizando subprocess.
        process = subprocess.Popen(
            # ["python", script, nome, peso_x, peso_y, peso_v, peso_z, alpha, pref],
            [sys.executable, script, nome, peso_x, peso_y, peso_v, peso_z, alpha, pref],
            stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True
        )

        # Capturo e exibo a sa√≠da linha por linha do script.
        # Para cada linha da sa√≠da:
        for line in iter(process.stdout.readline, ""):
            # Verifico se a linha est√° vazia, isto √©, se cheguei no final da sa√≠da do script.
            if line.strip():
                # Se n√£o cheguei, insiro a linha no final da janela.
                output_text.insert(tk.END, line)

                # Tamb√©m coloco para o rodap√© rolar automaticamente at√© o final da janela.
                output_text.see(tk.END)

                # Por fim, atualizo a interface para que o usu√°rio veja a linha mais recente da sa√≠da.
                root.update()

        # Se algum erro ocorrer durante a execu√ß√£o do script, ele √© enviado para a vari√°vel stderr, e n√£o √© mostrado pela se√ß√£o anterior.
        # Assim, salvo o poss√≠vel erro do script na vari√°vel stderr.
        stderr = process.communicate()[1]

        # Se ocorreu um erro, isto √©, se stderr n√£o √© uma vari√°vel vazia:
        if stderr:
            # Insiro a linha de erro no final da janela.
            output_text.insert(tk.END, "\n[ERRO]:\n" + stderr)

            # E rolo automaticamente at√© o final da janela.
            output_text.see(tk.END)

    # Caso ocorra algum erro durante a execu√ß√£o do script, uma janela alertando o erro √© apresentada para o usu√°rio.
    except subprocess.CalledProcessError as e:
        if e.returncode == 1:
            messagebox.showerror("Erro", f"Erro ao executar o script. Verifique os arquivos de entrada.\n\nErro: {e}")
        elif e.returncode == 2:
            messagebox.showerror("Erro", f"Erro de permiss√£o. Verifique se o arquivo {nome} est√° aberto em outro programa.\n\nErro: {e}")
        else:
            messagebox.showerror("Erro", f"Erro inesperado: {e}")
        return
    
    # Caso um erro inesperado ocorra, uma janela alertando o erro √© apresentada para o usu√°rio.
    except Exception as e:
        messagebox.showerror("Erro", f"Erro inesperado: {e}")
        return

    # # Caso algum erro ocorra ao executar o script, alerto o usu√°rio inserindo o erro na janela de sa√≠da.
    # except Exception as e:
    #     output_text.insert(tk.END, f"\nErro ao executar o script: {e}")

"""### Novo Edit Configs"""

# Fun√ß√£o que cria uma nova janela para configurar os par√¢metros da verifica√ß√£o ou do modelo antes de chamar o script.
# Seus par√¢metros s√£o o nome da base de dados (file_name) e uma vari√°vel booleana 'verify', que recebe o valor True quando
# o menu √© de configura√ß√µes da Verifica√ß√£o dos Dados, e False quando o menu √© de configura√ß√µes para Executar o Modelo
def Novo_edit_config(file_name):

    # Fa√ßo uma breve verifica√ß√£o para saber se foi fornecida uma base de dados.
    if file_name == "Selecione uma base de dados":
        # Se nenhum arquivo foi selecionado, uma janela avisando o ocorrido
        # aparece, pedindo para o usu√°rio fornecer uma base de dados.
        messagebox.showwarning("Aviso", "Por favor, selecione uma base de dados.")
        return


    # Crio uma nova janela em cima da janela principal da interface.
    configs = tk.Toplevel(root)
    configs.geometry("+360+150")
    configs.title("Personalizar par√¢metros")

    # Crio o frame para armazenar os bot√µes e outros campos da nova janela.
    frame2 = tk.Frame(configs)
    frame2.pack(pady=10, padx=10)

    # Defino 'casais' de vari√°veis. Cada vari√°vel refere-se a um valor de um checkbox de uma linha.
    # Ex: var11 refere-se ao valor do checkbox da primeira linha e da primeira coluna, enquanto
    # var22 refere-se ao valor do checkbox da primeira linha e da segunda coluna.
    var11 = IntVar()
    var12 = IntVar()
    var21 = IntVar()
    var22 = IntVar()
    var31 = IntVar()
    var32 = IntVar()
    var41 = IntVar()
    var42 = IntVar()
    var51 = IntVar()
    var52 = IntVar()
    var61 = IntVar()
    var62 = IntVar()
    # var71 = IntVar()
    # var72 = IntVar()

    # Defino uma fun√ß√£o que atualiza o estado de cada checkbox ap√≥s marcar, ou desmarcar, um deles.
    def atualizar_estado():
        # Se o checkbox da primeira linha e primeira coluna estiver marcado:
        if var11.get():
            # Desabilito o checkbox da primeira linha e segunda coluna.
            checkbox12.config(state=DISABLED)
        # Se ele n√£o estiver mais marcado:
        else:
            # Retorno o checkbox da primeira linha e segunda coluna ao normal.
            checkbox12.config(state=NORMAL)
        # Se o checkbox da primeira linha e segunda coluna estiver marcado:
        if var12.get():
            # Desabilito o checkbox da primeira linha e segunda coluna.
            checkbox11.config(state=DISABLED)
            # E habilito o campo correspondente para o usu√°rio inserir um valor.
            peso_x.config(state=NORMAL)
        # Se ele n√£o estiver mais marcado:
        else:
            # Retorno o checkbox da primeira linha e primeira coluna ao normal.
            checkbox11.config(state=NORMAL)
            # E deleto o conte√∫do inserido no campo, al√©m de desabilit√°-lo novamente.
            peso_x.delete(0, "end")
            peso_x.config(state=DISABLED)

        # As demais condi√ß√µes s√£o an√°logas √†s anteriores.

        if var21.get():
            checkbox22.config(state=DISABLED)
        else:
            checkbox22.config(state=NORMAL)
        if var22.get():
            checkbox21.config(state=DISABLED)
            peso_y.config(state=NORMAL)
        else:
            checkbox21.config(state=NORMAL)
            peso_y.delete(0, "end")
            peso_y.config(state=DISABLED)

        if var31.get():
            checkbox32.config(state=DISABLED)
        else:
            checkbox32.config(state=NORMAL)
        if var32.get():
            checkbox31.config(state=DISABLED)
            peso_v.config(state=NORMAL)
        else:
            checkbox31.config(state=NORMAL)
            peso_v.delete(0, "end")
            peso_v.config(state=DISABLED)

        if var41.get():
            checkbox42.config(state=DISABLED)
        else:
            checkbox42.config(state=NORMAL)
        if var42.get():
            checkbox41.config(state=DISABLED)
            peso_z.config(state=NORMAL)
        else:
            checkbox41.config(state=NORMAL)
            peso_z.delete(0, "end")
            peso_z.config(state=DISABLED)

        if var51.get():
            checkbox52.config(state=DISABLED)
        else:
            checkbox52.config(state=NORMAL)
        if var52.get():
            checkbox51.config(state=DISABLED)
            alpha.config(state=NORMAL)
        else:
            checkbox51.config(state=NORMAL)
            alpha.delete(0, "end")
            alpha.config(state=DISABLED)

        if var61.get():
            checkbox62.config(state=DISABLED)
        else:
            checkbox62.config(state=NORMAL)
        if var62.get():
            checkbox61.config(state=DISABLED)
            pref.config(state=NORMAL)
        else:
            checkbox61.config(state=NORMAL)
            pref.delete(0, "end")
            pref.config(state=DISABLED)

        # Esse par de vari√°veis n√£o est√° separado com as demais por elas serem associadas com os √∫nicos valores necess√°rios
        # tanto para a verifica√ß√£o dos dados, quanto para a execu√ß√£o do modelo, que s√£o o n√∫mero de alunos da p√≥s a serem
        # considerados em disciplinas com espelho.
        # if var71.get():
        #     checkbox72.config(state=DISABLED)
        # else:
        #     checkbox72.config(state=NORMAL)
        # if var72.get():
        #     checkbox71.config(state=DISABLED)
        #     qtd_pos.config(state=NORMAL)
        # else:
        #     checkbox71.config(state=NORMAL)
        #     qtd_pos.delete(0, "end")
        #     qtd_pos.config(state=DISABLED)

    
    # Defino uma linha puramente est√©tica no topo da janela.
    # Em seguida, defino uma legenda e um bot√£o ao lado, ambos desabilitados, apenas para servir como
    # instru√ß√µes e mostrar as configura√ß√µes recomendadas dos par√¢metros.
    ttk.Separator(frame2, orient="horizontal").grid(row=0, column=0, columnspan=3, sticky="ew", pady=(0, 10))
    lbl = tk.Label(frame2, text="Selecione e/ou digite os valores que deseja para os par√¢metros.", state=DISABLED)
    lbl.grid(row=1,column=0,sticky='w')
    btnl = ttk.Button(frame2, text="Recomenda√ß√µes - Configura√ß√µes Recomendadas", state=DISABLED)
    btnl.grid(row=1,column=1,sticky='e')
    Tooltip(btnl, "Recomendado:\n\
    Peso de aloca√ß√£o: 1\n\
    Peso de troca de sala: 500\n\
    Peso de agrupamento: 1\n\
    Peso de superlota√ß√£o: 10\n\
    √çndice de superlota√ß√£o: 0.85\n\
    Peso de salas preferencialmente vazias: 1\n\
    Quantidade de alunos da p√≥s: 20")

    # Semelhantemente, os pr√≥ximos 'blocos de c√≥digo' seguem a mesma l√≥gica.
    # Crio uma linha para separar o espa√ßo de cada par√¢metro.
    # Incluo uma legenda com uma Tooltip para explicar o prop√≥sito do par√¢metro.
    # Crio uma checkbox para marcar a configura√ß√£o padr√£o daquele par√¢metro sempre primeiro.
    # Crio, ap√≥s ele, um checkbox para marcar a configura√ß√£o personalizada com um campo desabilitado ao lado dele.
    # Ele precisa estar desabilitado inicialmente, ou √© poss√≠vel inserir um valor mesmo sem marcar um checkbox.
    ttk.Separator(frame2, orient="horizontal").grid(row=2, column=0, columnspan=3, sticky="ew", pady=(0, 10))
    lblx = tk.Label(frame2, text="Defina um peso de aloca√ß√£o:")
    lblx.grid(row=3, column=0, sticky='w', pady=5)
    # checkbox1 = Checkbutton(frame1, text="Modelo 1", variable=var1, command=atualizar_estado)
    checkbox11 = Checkbutton(frame2, text="Recomendado: 1", variable=var11, command=atualizar_estado)
    checkbox11.grid(row=3, column=1, sticky='w', pady=5)
    checkbox12 = Checkbutton(frame2, text="Personalizado: ", variable=var12, command=atualizar_estado)
    checkbox12.grid(row=3, column=2, sticky='w', pady=5)
    peso_x = Entry(frame2, state=DISABLED)
    peso_x.grid(row=4, column=2, sticky='e', pady=5)
    Tooltip(lblx, "O peso de aloca√ß√£o refere-se ao peso da vari√°vel x_as no modelo. \n\
    Quanto mais alto, mais importante ser√° essa vari√°vel,\n\
    logo, o modelo pode deixar de alocar de forma √≥tima se o peso for baixo.\n\
    Por exemplo, ele pode entender que √© mais importante agrupar \n\
    os cursos, do que usar o maior espa√ßo poss√≠vel.")

    ttk.Separator(frame2, orient="horizontal").grid(row=5, column=0, columnspan=3, sticky="ew", pady=(0, 10))
    lbly = tk.Label(frame2, text="Defina um peso de troca de sala:")
    lbly.grid(row=6,column=0,sticky='w',pady=5)
    checkbox21 = Checkbutton(frame2, text="Recomendado: 500", variable=var21, command=atualizar_estado)
    checkbox21.grid(row=6, column=1, sticky='w', pady=5)
    checkbox22 = Checkbutton(frame2, text="Personalizado: ", variable=var22, command=atualizar_estado)
    checkbox22.grid(row=6, column=2, sticky='w', pady=5)
    peso_y = Entry(frame2, state=DISABLED)
    peso_y.grid(row=7,column=2,sticky='e',pady=5)
    Tooltip(lbly, "O peso de troca de sala refere-se ao peso da vari√°vel y_t no modelo. \n\
    Quanto mais alto, mais importante ser√° essa vari√°vel,\n\
    logo, o modelo pode deixar de manter aulas de uma \n\
    turma/disciplina alocadas na mesma sala se o peso for baixo.\n\
    Por exemplo, ele pode entender que √© mais importante preencher \n\
    uma sala o m√°ximo poss√≠vel sem verificar quais s√£o elas.")


    ttk.Separator(frame2, orient="horizontal").grid(row=8, column=0, columnspan=3, sticky="ew", pady=(0, 10))
    lblv = tk.Label(frame2, text="Defina um peso de agrupamento:")
    lblv.grid(row=9,column=0,sticky='w',pady=5)
    checkbox31 = Checkbutton(frame2, text="Recomendado: 1", variable=var31, command=atualizar_estado)
    checkbox31.grid(row=9, column=1, sticky='w', pady=5)
    checkbox32 = Checkbutton(frame2, text="Personalizado: ", variable=var32, command=atualizar_estado)
    checkbox32.grid(row=9, column=2, sticky='w', pady=5)
    peso_v = Entry(frame2, state=DISABLED)
    peso_v.grid(row=10,column=2,sticky='e',pady=5)
    Tooltip(lblv, "O peso de agrupamento refere-se ao peso da vari√°vel v_cssl no modelo. \n\
    Quanto mais alto, mais importante ser√° essa vari√°vel,\n\
    logo, o modelo pode deixar de tentar agrupar as aulas de \n\
    um curso pr√≥ximas umas das outras se o peso for baixo.\n\
    Por exemplo, ele pode entender que √© mais importante \n\
    acomodar os alunos numa sala, do que agrupar os cursos.")

    ttk.Separator(frame2, orient="horizontal").grid(row=11, column=0, columnspan=3, sticky="ew", pady=(0, 10))
    lblz = tk.Label(frame2, text="Defina um peso de superlota√ß√£o:")
    lblz.grid(row=12,column=0,sticky='w',pady=5)
    checkbox41 = Checkbutton(frame2, text="Recomendado: 10", variable=var41, command=atualizar_estado)
    checkbox41.grid(row=12, column=1, sticky='w', pady=5)
    checkbox42 = Checkbutton(frame2, text="Personalizado: ", variable=var42, command=atualizar_estado)
    checkbox42.grid(row=12, column=2, sticky='w', pady=5)
    peso_z = Entry(frame2, state=DISABLED)
    peso_z.grid(row=13,column=2,sticky='e',pady=5)
    Tooltip(lblz, "O peso de superlota√ß√£o refere-se ao peso da vari√°vel z_as no modelo. \n\
    Quanto mais alto, mais importante ser√° essa vari√°vel,\n\
    logo, o modelo pode deixar de tentar acomodar melhor os \n\
    alunos em uma sala se o peso for baixo.\n\
    Por exemplo, ele pode entender que √© mais importante \n\
    preencher uma sala o m√°ximo poss√≠vel, do que deixar alguns lugares desocupados \n\
    para acomodar melhor os alunos, ou para receber alunos vindos do requerimento.")

    ttk.Separator(frame2, orient="horizontal").grid(row=14, column=0, columnspan=3, sticky="ew", pady=(0, 10))
    lbla = tk.Label(frame2, text="Defina um √≠ndice de superlota√ß√£o (valor entre 0 e 1, utilizando '.'):")
    lbla.grid(row=15,column=0,sticky='w',pady=5)
    checkbox51 = Checkbutton(frame2, text="Recomendado: 0.85", variable=var51, command=atualizar_estado)
    checkbox51.grid(row=15, column=1, sticky='w', pady=5)
    checkbox52 = Checkbutton(frame2, text="Personalizado: ", variable=var52, command=atualizar_estado)
    checkbox52.grid(row=15, column=2, sticky='w', pady=5)
    alpha = Entry(frame2, state=DISABLED)
    alpha.grid(row=16,column=2,sticky='e',pady=5)
    Tooltip(lbla, "O √≠ndice de superlota√ß√£o refere-se √† porcentagem usada pela vari√°vel z_as no modelo. \n\
    Em outras palavras, √© o quanto uma aula preenche uma sala \n\
    para que o modelo tente colocar essa aula em uma sala maior, \n\
    garantindo uma melhor acomoda√ß√£o para os alunos e espa√ßo para \n\
    alunos vindos do requerimento. Quanto mais alto, mais o modelo \n\
    prioriza preencher o m√°ximo poss√≠vel de uma sala. Um valor baixo \n\
    faz com que as salas maiores sejam preenchidas com mais facilidade, \n\
    e um valor alto far√° o mesmo, mas para as salas menores.")

    ttk.Separator(frame2, orient="horizontal").grid(row=17, column=0, columnspan=3, sticky="ew", pady=(0, 10))
    lbl_pref = tk.Label(frame2, text="Defina um peso de salas preferencialmente vazias:")
    lbl_pref.grid(row=18,column=0,sticky='w',pady=5)
    checkbox61 = Checkbutton(frame2, text="Recomendado: 500", variable=var61, command=atualizar_estado)
    checkbox61.grid(row=18, column=1, sticky='w', pady=5)
    checkbox62 = Checkbutton(frame2, text="Personalizado: ", variable=var62, command=atualizar_estado)
    checkbox62.grid(row=18, column=2, sticky='w', pady=5)
    pref = Entry(frame2, state=DISABLED)
    pref.grid(row=19,column=2,sticky='e',pady=5)
    Tooltip(lbl_pref, "O peso de salas preferencialmente vazias refere-se √† import√¢ncia de determinadas salas ficarem desocupadas no modelo. \n\
    Quanto mais alto, maior a chance de essas salas n√£o serem utilizadas,\n\
    logo, o modelo pode tentar alocar aulas em salas indesejadas \n\
    se o peso for baixo.\n\
    Por exemplo, ele pode entender que √© mais importante \n\
    preencher uma sala que poderia ser usada para alguma outra fun√ß√£o, por ela ser mais f√°cil de ser preenchida, \n\
    do que mant√™-la desocupada para a p√≥s.")

    # ttk.Separator(frame2, orient="horizontal").grid(row=20, column=0, columnspan=3, sticky="ew", pady=(0, 10))
    # lblq = tk.Label(frame2, text="Defina uma quantidade de alunos da p√≥s para as disciplinas com espelho:")
    # lblq.grid(row=21,column=0,sticky='w',pady=5)
    # checkbox71 = Checkbutton(frame2, text="Recomendado: 20", variable=var71, command=atualizar_estado)
    # checkbox71.grid(row=21, column=1, sticky='w', pady=5)
    # checkbox72 = Checkbutton(frame2, text="Personalizado: ", variable=var72, command=atualizar_estado)
    # checkbox72.grid(row=21, column=2, sticky='w', pady=5)
    # qtd_pos = Entry(frame2, state=DISABLED)
    # qtd_pos.grid(row=22,column=2,sticky='e',pady=5)
    # Tooltip(lblq, "A quantidade de alunos da p√≥s refere-se a um valor sugerido pelo usu√°rio \n\
    # para simbolizar quantos alunos da p√≥s-gradua√ß√£o far√£o \n\
    # uma disciplina da gradua√ß√£o que √© espelhada com a p√≥s. \n\
    # Esse valor ser√° aplicado no n√∫mero de inscritos de QUALQUER \n\
    # disciplina que tenha espelho com a p√≥s.")

    # Defino uma fun√ß√£o que detecta as configura√ß√µes escolhidas pelo usu√°rio.
    def executar_configs_perso():
        # Verifico se ao menos uma das checkbox relacionadas ao peso de aloca√ß√£o foi selecionada,
        # pois o modelo precisa desse peso obrigatoriamente.
        if not var11.get() and not var12.get():
            # Se nenhum peso foi fornecido, uma janela alerta o ocorrido e pede para o usu√°rio definir um peso.
            messagebox.showwarning("Aviso", "Por favor, defina um peso de aloca√ß√£o.")
            return

        # Verifico se a checkbox da configura√ß√£o recomendada est√° marcado:
        elif var11.get():
            # Se estiver, dou o valor recomendado para a vari√°vel auxiliar.
            aux_x = '1'

        # Verifico se a checkbox da configura√ß√£o personalizada est√° marcado:
        else:
            # Se estiver, dou o valor fornecido pelo usu√°rio para a vari√°vel auxiliar.
            aux_x = peso_x.get()

        # Verifico se ao menos uma das checkbox relacionadas ao peso de troca de sala foi selecionada,
        # pois o modelo precisa desse peso obrigatoriamente. A l√≥gica √© a mesma da de anteriormente.
        if not var21.get() and not var22.get():
            messagebox.showwarning("Aviso", "Por favor, defina um peso de troca de sala.")
            return
        elif var21.get():
            aux_y = '500'
        else:
            aux_y = peso_y.get()

        # As condi√ß√µes a seguir seguem a mesma l√≥gica para cada par√¢metro e configura√ß√£o dispon√≠vel.
        # Verifico se a checkbox da configura√ß√£o personalizada est√° marcada e sem um valor inserido pelo usu√°rio:
        if var12.get() and not peso_x.get():
            # Se for o caso, uma janela alerta o ocorrido e pede para o usu√°rio definir um valor para o par√¢metro.
            messagebox.showwarning("Aviso", "Por favor, digite um peso de aloca√ß√£o.")
            return

        # Verifico se a checkbox da configura√ß√£o recomendada est√° marcada:
        elif var11.get():
            # Se estiver, dou o valor recomendado para a vari√°vel auxiliar.
            aux_x = '1'

        # Verifico, por fim, se a checkbox da configura√ß√£o personalizada est√° marcada.
        else:
            # Se estiver, para ter entrado nessa condi√ß√£o, o usu√°rio deve ter fornecido um valor para o par√¢metro.
            # Portanto, dou o valor fornecido para a vari√°vel auxiliar.
            aux_x = peso_x.get()

        if var22.get() and not peso_y.get():
            messagebox.showwarning("Aviso", "Por favor, digite um peso de troca de sala.")
            return
        elif var21.get():
            aux_y = '500'
        else:
            aux_y = peso_y.get()

        if var32.get() and not peso_v.get():
            messagebox.showwarning("Aviso", "Por favor, digite um peso de agrupamento.")
            return
        elif var31.get():
            aux_v = '1'
        else:
            aux_v = peso_v.get()

        if var42.get() and not peso_z.get():
            messagebox.showwarning("Aviso", "Por favor, digite um peso de superlota√ß√£o.")
            return
        elif var41.get():
            aux_z = '10'
        else:
            aux_z = peso_z.get()

        if var52.get() and not alpha.get():
            messagebox.showwarning("Aviso", "Por favor, digite um √≠ndice de superlota√ß√£o.")
            return
        elif var51.get():
            aux_a = '0.85'
        else:
            aux_a = alpha.get()

        if var62.get() and not pref.get():
            messagebox.showwarning("Aviso", "Por favor, digite um peso de salas preferencialmente vazias.")
            return
        elif var61.get():
            aux_p = '500'
        else:
            aux_p = pref.get()

        # if var72.get() and not qtd_pos.get():
        #     messagebox.showwarning("Aviso", "Por favor, digite uma quantidade de alunos da p√≥s para as disciplinas com espelho.")
        #     return
        # elif var71.get():
        #     aux_q = '20'
        # else:
        #     aux_q = qtd_pos.get()

        # Se nenhum alerta foi gerado, as configura√ß√µes personalizadas devem estar corretas,
        # ent√£o s√≥ resta rodar o script com elas.
        roda_script(script="Modelo Universal-Copy1.py",
                nome=file_name, peso_x=aux_x, peso_y=aux_y, peso_v=aux_v, peso_z=aux_z,
                alpha=aux_a, pref=aux_p)



    
    # Crio uma linha horizontal para separar as escolhas de par√¢metro dos bot√µes da janela.
    ttk.Separator(frame2, orient="horizontal").grid(row=23, column=0, columnspan=2, sticky="w", pady=(0, 10))

    # Defino o bot√£o de Executar o Modelo com os par√¢metros Recomendados, que chama a fun√ß√£o de rodar script e os
    # par√¢metros recomendados diretamente.
    ttk.Button(frame2, text="Executar com Recomendados",
                command=lambda: roda_script(script="Modelo Universal-Copy1.py",
                                            nome=file_name, peso_x='1', peso_y='500', peso_v="",
                                            peso_z='10', alpha='0.85', pref='500')).grid(row=24, column=0, sticky='w', pady=5)

    # Defino o bot√£o de Executar o Modelo com os par√¢metros Personalizados, que chama a fun√ß√£o definida anteriormente
    # para checar as configura√ß√µes personalizadas pelo usu√°rio.
    ttk.Button(frame2, text="Executar com Personalizados",
                command=executar_configs_perso).grid(row=24, column=2, sticky='w', pady=5)

    
        
        # # An√°logo aos bot√µes que s√£o definidos no menu de configura√ß√µes do modelo.
        # ttk.Separator(frame2, orient="horizontal").grid(row=23, column=0, columnspan=2, sticky="w", pady=(0, 10))
        # ttk.Button(frame2, text="Verificar com Recomendados",
        #            command=lambda: roda_script(script="verificar_dados.py",
        #                                        nome=file_name, peso_x='1', peso_y='500', peso_v="",
        #                                        peso_z='10', alpha='0.85', pref='500')).grid(row=24, column=0, sticky='w', pady=5)

        # ttk.Button(frame2, text="Verificar com Personalizados",
        #            command=executar_configs_perso).grid(row=24, column=2, sticky='w', pady=5)

"""## An√°lise de Espa√ßos Livres (colocar nos arquivos de modelo)"""

# Fun√ß√£o que cria uma janela para selecionar arquivos de solu√ß√£o do modelo, que ser√£o analisados
# para criar planilhas mostrando os espa√ßos livres ap√≥s as aloca√ß√µes.
def analise_vazios():
    # Crio uma nova janela em cima da janela principal da interface.
    nova_janela = tk.Toplevel(root)
    nova_janela.title("An√°lise de Espa√ßos Livres")

    # Crio o frame para armazenar os bot√µes e outros campos da nova janela.
    frame = tk.Frame(nova_janela)
    frame.pack(pady=10, padx=10)

    # Defino uma vari√°vel para salvar o arquivo com a planilha de Visualiza√ß√£o Completa da Solu√ß√£o do modelo.
    visu = tk.StringVar(value="Selecione a planilha de Visualiza√ß√£o Completa da Solu√ß√£o do modelo")

    # Defino uma vari√°vel para salvar o arquivo com a planilha dos dados das salas.
    salas = tk.StringVar(value="Selecione a planilha dos dados das salas")

    # Defino uma vari√°vel para salvar o nome, fornecido pelo usu√°rio, para o arquivo de Visualiza√ß√£o de Espa√ßos Livres.
    caminho_arquivo = tk.StringVar()

    # Defino uma vari√°vel para salvar o nome, fornecido pelo usu√°rio, para o arquivo de Planilha de Espa√ßos Livres.
    caminho_arquivo1 = tk.StringVar()

    # Defino as fun√ß√µes para selecionar arquivos.
    def selecionar_arquivo1():
        # O usu√°rio seleciona o arquivo contendo a base de dados das aulas.
        arquivo = filedialog.askopenfilename(title="Selecione a planilha de Visualiza√ß√£o Completa da Solu√ß√£o do modelo")

        # Se um arquivo foi selecionado:
        if arquivo:
            # Salvo o caminho do arquivo.
            visu.set(arquivo)

    # Fun√ß√£o an√°loga.
    def selecionar_arquivo2():
        # O usu√°rio seleciona o arquivo contendo a base de dados das aulas.
        arquivo = filedialog.askopenfilename(title="Selecione a planilha dos dados das salas")

        # Se um arquivo foi selecionado:
        if arquivo:
            # Salvo o caminho do arquivo.
            salas.set(arquivo)

    # Defino uma fun√ß√£o que salva os valores das vari√°veis contendo o nome dos arquivos escolhidos.
    def salvar_valores():
        # Todas as condi√ß√µes a seguir seguem a l√≥gica de que, se um arquivo n√£o foi selecionado, uma janela avisando o ocorrido
        # aparece, pedindo para o usu√°rio selecionar um arquivo no campo requerido, ou fornecer um nome para os arquivos
        # que ser√£o criados.

        if not visu.get() or visu.get() == "Selecione a planilha de Visualiza√ß√£o Completa da Solu√ß√£o do modelo":
            messagebox.showwarning("Aviso", "Por favor, selecione a planilha de Visualiza√ß√£o Completa da Solu√ß√£o do modelo.")
            return
        if not salas.get() or salas.get() == "Selecione a planilha dos dados das salas":
            messagebox.showwarning("Aviso", "Por favor, selecione a planilha dos dados das salas.")
            return
        if not caminho_arquivo.get():
            messagebox.showwarning("Aviso", "Por favor, d√™ um nome para o arquivo de Visualiza√ß√£o de Espa√ßos Livres.")
            return
        if not caminho_arquivo1.get():
            messagebox.showwarning("Aviso", "Por favor, d√™ um nome para o arquivo de Planilha de Espa√ßos Livres.")
            return


        # Com o arquivo necess√°rio selecionado, e os nomes dos novos arquivos obtidos, chamo a fun√ß√£o que far√° a an√°lise dos espa√ßos livres.
        criar_visualizacao_de_vazias(visu.get(), salas.get(), caminho_arquivo.get(), caminho_arquivo1.get(), )

        # E destruo a janela ap√≥s a conclus√£o do processo.
        nova_janela.destroy()

    # Crio uma legenda para ficar ao lado do bot√£o.
    lbl_visu = tk.Label(frame, text="Selecione a de Dados da Solu√ß√£o do modelo")
    # Defino a posi√ß√£o do texto na janela.
    lbl_visu.grid(row=0, column=0, pady=5, sticky="w")
    # Crio o bot√£o para salvar o arquivo da Visualiza√ß√£o Completa da Solu√ß√£o do modelo.
    btn_selecionar_visu = tk.Button(frame, textvariable=visu, command=selecionar_arquivo1, wraplength=250, width=40)
    # Defino a posi√ß√£o do bot√£o na janela.
    btn_selecionar_visu.grid(row=0, column=1, padx=5, pady=5)

    # As linhas a seguir s√£o an√°logas.
    lbl_salas = tk.Label(frame, text="Selecione a planilha dos dados das salas")
    lbl_salas.grid(row=1, column=0, pady=5, sticky="w")
    btn_selecionar_salas = tk.Button(frame, textvariable=salas, command=selecionar_arquivo2, wraplength=250, width=40)
    btn_selecionar_salas.grid(row=1, column=1, padx=5, pady=5)

    lbl_cam = tk.Label(frame, text="Digite um nome para a Visualiza√ß√£o de Espa√ßos Livres:")
    lbl_cam.grid(row=2, column=0, pady=5, sticky="w")
    campo_cam = tk.Entry(frame, textvariable=caminho_arquivo)
    campo_cam.grid(row=2, column=1, pady=5)

    lbl_cam1 = tk.Label(frame, text="Digite um nome para a Planilha de Espa√ßos Livres:")
    lbl_cam1.grid(row=3, column=0, pady=5, sticky="w")
    campo_cam1 = tk.Entry(frame, textvariable=caminho_arquivo1)
    campo_cam1.grid(row=3, column=1, pady=5)

    # Defino um bot√ß√£o e sua posi√ß√£o na janela, cujo papel √© chamar a fun√ß√£o que salva os valores dos arquivos para a an√°lise.
    ttk.Button(frame, text="Gerar An√°lise de Espa√ßos Livres", command=salvar_valores).grid(row=4,column=0,sticky='ew')

"""### Criar Visualiza√ß√£o em cima de Visualiza√ß√£o"""

# Fun√ß√£o que faz a an√°lise de espa√ßos livres restantes ap√≥s a aloca√ß√£o feita pelo modelo.
def criar_visualizacao_de_vazias(file_path, file_path_salas, caminho_arquivo, caminho_arquivo1):
    # Defino uma vari√°vel que recebe a planilha do Excel da Visualiza√ß√£o Completa da Solu√ß√£o do modelo.
    wb = load_workbook(file_path)
    ws = wb.active

    # Defino duas vari√°veis com o hor√°rio inicial e final, isto √©, o intervalo dos hor√°rios que ser√£o colocados na planilha para a visualiza√ß√£o.
    start_time = datetime.strptime("07:00", "%H:%M")
    end_time = datetime.strptime("23:30", "%H:%M")

    # Crio uma lista para conter os valores do intervalo de hor√°rios.
    horarios = []

    # Crio uma vari√°vel com o hor√°rio inicial.
    current_time = start_time

    # Enquanto o hor√°rio inicial n√£o for maior que o hor√°rio final, isto √©, enquanto houver valores para serem colocados no intervalo:
    while current_time <= end_time:
        # Adiciono o hor√°rio atual na lista de hor√°rios.
        horarios.append(current_time.strftime("%H:%M"))

        # Fa√ßo um acr√©scimo de 30 minutos no hor√°rio atual.
        current_time += timedelta(minutes=30)

    # Crio uma vari√°vel com a quantidade de colunas necess√°rias para colocar todos os hor√°rios do intervalo.
    sala_colunas = len(horarios)

    # Lista com os nomes dos dias da semana que ser√£o usados na visualiza√ß√£o.
    dias_semana = ["Segunda", "Ter√ßa", "Quarta", "Quinta", "Sexta", "S√°bado"]

    # Defino as linhas e colunas de in√≠cio e fim para a primeira tabela da planilha, isto √©, para preencher os dados da primeira sala.
    start_row = 1 # Linha de in√≠cio.
    start_column = 2 # Coluna de in√≠cio.
    end_row = 1 # Linha de t√©rmino.
    end_column = 1 + sala_colunas # Coluna de t√©rmino.
    start = start_row + 2 # Linha de in√≠cio para listar os dias da semana.
    space_between = 3 # N√∫mero de linhas entre a tabela de uma sala para a de outra sala.

    # Defino um preenchimento amarelo para simbolizar os espa√ßos livres das salas.
    yellow_fill = PatternFill(start_color="00E3DE00", end_color="00E3DE00", fill_type="solid")

    # Defino uma vari√°vel que guarda o n√∫mero de salas utilizadas na solu√ß√£o do modelo.
    # O c√°lculo feito √© baseado no comprimento da planilha, no n√∫mero de dias da semana mostrados na visualiza√ß√£o, e no
    # espa√ßo entre cada "tabela" de cada sala.
    n_salas = int((ws.max_row+1) / (2 + len(dias_semana) + space_between))

    # Salvo os dados das salas em uma vari√°vel.
    salas = pd.read_excel(file_path_salas)

    # Crio uma lista para salvar quais salas foram usadas para a aloca√ß√£o do modelo.
    salas1 = []

    # Crio um dataframe vazio para salvar os intervalos de tempo onde as salas est√£o dispon√≠veis.
    df_vazio = pd.DataFrame(columns=["Sala", "Dia da semana", "Hor√°rio vago"])

    # Fun√ß√£o para obter a cor da c√©lula.
    def get_cell_color(cell):
        # Salvo a cor de preenchimento da c√©lula em uma vari√°vel.
        fill = cell.fill

        # if fill and fill.start_color.index != "ffffff":  # Ignorar c√©lulas sem cor
        # Verifico se tinha algum preenchimento diferente, ou se o preenchimento √© amarelo:
        if fill and fill.start_color.index != "00E3DE00":  # Ignorar c√©lulas amarelas
            # Se houver, retorno o c√≥digo do preenchimento.
            return fill.start_color.index  # Retorna o c√≥digo da cor

        # Caso n√£o houver uma cor de preenchimento definida, retorno vazio.
        return None  # Sem cor definida

    # Para cada sala utilizada pelo modelo:
    for i in range(n_salas+1):
        # print(type(ws.cell(row=start_row, column=start_column)))
        # Salvo a sala que est√° sendo analisada atualmente em uma vari√°vel.
        sala = ws.cell(row=start_row, column=start_column).value

        # E tamb√©m a adiciono na lista de salas usadas.
        salas1.append(sala)

        # Para cada linha da planilha:
        for row in ws.iter_rows(min_row=start, max_row=start+5):
        # for i, dia in enumerate(dias_semana, start=start):

            # Defino a coluna inicial como vazia.
            start_col = None  # In√≠cio da mesclagem
            # current_color = None  # Cor atual

            # Para cada par (coluna, c√©lula) da linha sendo analisada:
            for col_idx, cell in enumerate(row, start=1):
                # Busco identificar a cor do preenchimento da c√©lula.
                cell_color = get_cell_color(cell)

                # Se a cor da c√©lula atual for branca, possivelmente deixei de estar analisando um hor√°rio ocupado:
                if cell_color == "00000000":
                    # Verifico se a c√©lula √© uma c√©lula mesclada:
                    if type(cell) != openpyxl.cell.cell.MergedCell:
                        # Se n√£o for, verifico se a coluna inicial est√° como vazia,
                        # e se a c√©lula atual n√£o faz parte da coluna de dias da semana:
                        if start_col is None and cell.value not in dias_semana:
                            # Se for o caso, salvo a coluna inicial na vari√°vel.
                            # O workbook sempre considera a primeira coluna como 1, e como o primeiro "elemento" da lista de hor√°rios est√° na
                            # coluna 2, ent√£o para traduzir corretamente a coluna da c√©lula vazia, preciso tirar 2 para o √≠ndice ficar compat√≠vel
                            start_col = cell.column - 2

                # Se a cor da c√©lula atual n√£o for branca:
                else:
                    # Verifico se a c√©lula que estou analisando n√£o √© mesclada:
                    if type(cell) != openpyxl.cell.cell.MergedCell:
                        # Se ela n√£o for, quer dizer que estou analisando a primeira c√©lula de um intervalo ocupado, isto √©,
                        # estou analisando a c√©lula do topo esquerdo da mesclagem, que √© a √∫nica que pode ter seu valor alterado.
                        # Assim, limpo o que estiver dentro da c√©lula.
                        cell.value = ""

                        # E mudo a cor de seu preenchimento para o amarelo definido anteriormente.
                        cell.fill = yellow_fill

                    # Agora, verifico se a coluna inicial √© diferente de vazio, ou seja, se ela j√° foi definida;
                    # e verifico se a dist√¢ncia entre a coluna atual e a coluna inicial √© maior ou igual que 1,
                    # certificando que n√£o estou olhando para a mesma coluna:
                    if start_col is not None and col_idx - start_col >= 1:
                        # Aqui √© onde eu vou pegar os intervalos do merge
                        # print(f"a: {start_col}: {horarios[start_col-1]} - {horarios[col_idx-1-2+1]}\n")

                        # Se isso for verdade, adiciono uma linha no dataframe contendo os hor√°rios dispon√≠veis at√© ent√£o.
                        # Na ordem, esta a sala que estou analisando, o dia da semana com o hor√°rio dispon√≠vel, e
                        # o intervalo de tempo livre do dia em quest√£o.
                        # Como estou analisando linha por linha, a coluna do segundo valor sempre √© 1, pois refere-se
                        # √† coluna de dias da semana; e eu preciso subtrair o valor 2 de col_idx para ignorar a primeira coluna
                        # da tabela (-1), e para igualar com o √≠ndice usual (j√° que col_idx sempre come√ßa com o valor 1).
                        df_vazio.loc[len(df_vazio)] = [f"{sala}", f"{ws.cell(row=cell.row, column=1).value}",
                                                       f"{horarios[start_col]} - {horarios[col_idx-2]}"]

                    # Ap√≥s estes processos, defino novamente a coluna de in√≠cio como vazia para definir um novo intervalo.
                    start_col = None


            # Por garantia, adiciono o √∫ltimo intervalo de hor√°rio dispon√≠vel nos dados, j√° que a an√°lise da linha
            # poderia terminar e ir para a pr√≥xima sem incluir o √∫ltimo hor√°rio dispon√≠vel dela:
            if start_col is not None and start_col < len(row):
                # print(f"b: {start_col}: {horarios[start_col-1]} - {horarios[col_idx-1-2+1]}\n")
                # Incluo esses dados da mesma forma como anteriormente.
                df_vazio.loc[len(df_vazio)] = [f"{sala}", f"{ws.cell(row=cell.row, column=1).value}",
                                               f"{horarios[start_col]} - {horarios[col_idx-2]}"]

        # Feito isso, atualizo meus dados de cria√ß√£o, isto √©, as coordenadas de onde a tabela da sala seguinte ser√° colocada na planilha.
        start_row = start_row + 2 + len(dias_semana) + space_between
        end_row = start_row
        start = start_row + 2


    # Ap√≥s fazer a an√°lise de espa√ßos livres de todas as salas utilizadas na aloca√ß√£o, verificarei quais ficaram inteiramente de fora.
    # Para isso, verifico cada sala na planilha de salas:
    for sala in salas['Sala'].tolist():
        # Se a sala n√£o est√° na lista de salas utilizadas:
        if sala not in salas1:

            if sala == '6-303' and '6-303/6-304' in salas1:
                continue
            elif sala == '6-304' and '6-303/6-304' in salas1:
                continue
            elif sala == '6-305' and '6-305/6-306' in salas1:
                continue
            elif sala == '6-306' and '6-305/6-306' in salas1:
                continue
            else:
                # Adiciono qual sala n√£o foi utilizada na planilha de dados de espa√ßos livres.
                # As condi√ß√µes dadas anteriormente s√£o para garantir que o c√≥digo n√£o inclua as salas de laborat√≥rio avulsas
                # quando apenas as em conjunto foram utilizadas. Por exemplo, se o modelo tiver alocado apenas os laborat√≥rios
                # do bloco 6 (6-303/6-304 e 6-305/6-306), o algoritmo pode incluir, erroneamente, que a sala 6-303 n√£o foi usada.
                weekdays = ['Segunda', 'Ter√ßa', 'Quarta', 'Quinta', 'Sexta', 'S√°bado']
                
                for i in range(len(weekdays)):
                    last_line = df_vazio.shape[0] + 1
                    df_vazio.loc[last_line, 'Sala'] = f"{sala}"
                    df_vazio.loc[last_line, 'Dia da semana'] = weekdays[i]
                    df_vazio.loc[last_line, 'Hor√°rio vago'] = "07:00 - 23:30"


    ## Verifico se o nome da nova base de dados termina com '.xlsx':
    if not caminho_arquivo.endswith(".xlsx"):
        # Em caso negativo, adiciono essa terminologia.
        caminho_arquivo = caminho_arquivo + ".xlsx"

    # Verifico se o nome da nova base de dados termina com '.xlsx':
    if not caminho_arquivo1.endswith(".xlsx"):
        # Em caso negativo, adiciono essa terminologia.
        caminho_arquivo1 = caminho_arquivo1 + ".xlsx"

    try:
        # Por fim, salvo os arquivos criados com seus respectivos m√©todos.
        wb.save(os.path.join(saidas, caminho_arquivo))
    
    except PermissionError as e:
        if e.errno == 13:  # Erro de permiss√£o (arquivo aberto ou bloqueado)
            messagebox.showerror("Erro de Permiss√£o", 
                                    (
                                        f"N√£o foi poss√≠vel salvar o arquivo {os.path.basename(caminho_arquivo)}. "
                                        "Verifique se ele est√° aberto em outro programa (como o Excel) e tente novamente."
                                    )
                                )
            return
        else:
            messagebox.showerror("Erro", f"Erro de permiss√£o:\n\n{str(e)}")
            return
    except Exception as e:
        # Para qualquer outro erro
        messagebox.showerror("Erro inesperado!", f"Ocorreu um erro inesperado:\n\n{str(e)}")
        return
    

    try:
        df_vazio.to_excel(os.path.join(saidas, caminho_arquivo1), sheet_name="Resultados", index=False)

        
    except PermissionError as e:
        if e.errno == 13:  # Erro de permiss√£o (arquivo aberto ou bloqueado)
            messagebox.showerror("Erro de Permiss√£o", 
                                    (
                                        f"N√£o foi poss√≠vel salvar o arquivo {os.path.basename(caminho_arquivo1)}. "
                                        "Verifique se ele est√° aberto em outro programa (como o Excel) e tente novamente."
                                    )
                                )
            return
        else:
            messagebox.showerror("Erro", f"Erro de permiss√£o:\n\n{str(e)}")
            return
    except Exception as e:
        # Para qualquer outro erro
        messagebox.showerror("Erro inesperado!", f"Ocorreu um erro inesperado:\n\n{str(e)}")
        return
    
    # E abro uma janela avisando o usu√°rio de que os arquivos foram salvos.
    messagebox.showinfo("Suesso", 
                        f"Arquivo {caminho_arquivo} criado com sucesso!\n\
                        \nArquivo {caminho_arquivo1} criado com sucesso!\n\
                        \nVerifique a pasta {saidas} para encontr√°-lo.")

"""# Preencher Planilha de Dados"""

# Fun√ß√£o que preenche as planilhas de dados fornecidas pelo usu√°rio, sem a necessidade do mesmo preencher as
# aloca√ß√µes feitas pelo modelo de forma manual.
# Estruturalmente, a fun√ß√£o √© bem semelhante √† de construir a primeira base de dados (a das aulas), com a √∫nica diferen√ßa
# sendo dois campos a mais para inserir a bases de dados feita anteriormente, e a solu√ß√£o dada pelo modelo.
def preencher_planilha_dados():

    # Crio uma nova janela em cima da janela principal da interface.
    nova_janela = tk.Toplevel(root)
    nova_janela.title("Selecionar Arquivo e Inserir Valor")

    # Crio o frame para armazenar os bot√µes e outros campos da nova janela.
    frame = tk.Frame(nova_janela)
    frame.pack(pady=10, padx=10)

    # Defino v√°rias vari√°veis para armazenar os nomes dos arquivos que ser√£o preenchidos.
    arquivo_sme = tk.StringVar(value="Selecione a planilha do SME")
    arquivo_sma = tk.StringVar(value="Selecione a planilha do SMA")
    arquivo_scc = tk.StringVar(value="Selecione a planilha do SCC")
    arquivo_ssc = tk.StringVar(value="Selecione a planilha do SSC")
    arquivo_outros = tk.StringVar(value="Selecione a planilha dos Outros Institutos")
    arquivo_sol = tk.StringVar(value="Selecione a planilha com os Dados da Solu√ß√£o do Modelo")
    arquivo_base = tk.StringVar(value="Selecione a Base de Dados")



    # Defino fun√ß√µes para selecionar arquivos.
    def selecionar_sme():
        # O usu√°rio seleciona o arquivo contendo a base de dados das aulas.
        arquivo = filedialog.askopenfilename(title="Selecione a planilha do SME")

        # Se um arquivo foi selecionado:
        if arquivo:
            # Salvo o caminho do arquivo.
            arquivo_sme.set(arquivo)
    def selecionar_sma():
        arquivo = filedialog.askopenfilename(title="Selecione a planilha do SMA")
        if arquivo:
            arquivo_sma.set(arquivo)
    def selecionar_scc():
        arquivo = filedialog.askopenfilename(title="Selecione a planilha do SCC")
        if arquivo:
            arquivo_scc.set(arquivo)
    def selecionar_ssc():
        arquivo = filedialog.askopenfilename(title="Selecione a planilha do SSC")
        if arquivo:
            arquivo_ssc.set(arquivo)
    def selecionar_outros():
        arquivo = filedialog.askopenfilename(title="Selecione a planilha dos Outros Institutos")
        if arquivo:
            arquivo_outros.set(arquivo)
    def selecionar_sol():
        arquivo = filedialog.askopenfilename(title="Selecione a planilha com os Dados da Solu√ß√£o do Modelo")
        if arquivo:
            arquivo_sol.set(arquivo)
    def selecionar_base():
        arquivo = filedialog.askopenfilename(title="Selecione a Base de Dados")
        if arquivo:
            arquivo_base.set(arquivo)



    # Crio uma legenda para ficar ao lado do bot√£o.
    lbl_sme = tk.Label(frame, text="Selecione a planilha do SME")
    # Defino a posi√ß√£o do texto na janela.
    lbl_sme.grid(row=0, column=0, pady=5, sticky='w')
    # Crio o bot√£o para salvar o arquivo do SME.
    btn_selecionar_sme = tk.Button(frame, textvariable=arquivo_sme, command=selecionar_sme, wraplength=250, width=40)
    # Defino a posi√ß√£o do bot√£o na janela.
    btn_selecionar_sme.grid(row=0, column=1, padx=5, pady=5)

    # As linhas a seguir s√£o an√°logas.
    lbl_sma = tk.Label(frame, text="Selecione a planilha do SMA")
    lbl_sma.grid(row=1, column=0, pady=5, sticky='w')
    btn_selecionar_sma = tk.Button(frame, textvariable=arquivo_sma, command=selecionar_sma, wraplength=250, width=40)
    btn_selecionar_sma.grid(row=1, column=1, padx=5, pady=5)

    lbl_scc = tk.Label(frame, text="Selecione a planilha do SCC")
    lbl_scc.grid(row=2, column=0, pady=5, sticky='w')
    btn_selecionar_scc = tk.Button(frame, textvariable=arquivo_scc, command=selecionar_scc, wraplength=250, width=40)
    btn_selecionar_scc.grid(row=2, column=1, padx=5, pady=5)

    lbl_ssc = tk.Label(frame, text="Selecione a planilha do SSC")
    lbl_ssc.grid(row=3, column=0, pady=5, sticky='w')
    btn_selecionar_ssc = tk.Button(frame, textvariable=arquivo_ssc, command=selecionar_ssc, wraplength=250, width=40)
    btn_selecionar_ssc.grid(row=3, column=1, padx=5, pady=5)

    lbl_outros = tk.Label(frame, text="Selecione a planilha dos Outros Institutos")
    lbl_outros.grid(row=4, column=0, pady=5, sticky='w')
    btn_selecionar_outros = tk.Button(frame, textvariable=arquivo_outros, command=selecionar_outros, wraplength=250, width=40)
    btn_selecionar_outros.grid(row=4, column=1, padx=5, pady=5)

    lbl_sol = tk.Label(frame, text="Selecione a planilha com os Dados da Solu√ß√£o do Modelo")
    lbl_sol.grid(row=5, column=0, pady=5, sticky='w')
    btn_selecionar_sol = tk.Button(frame, textvariable=arquivo_sol, command=selecionar_sol, wraplength=250, width=40)
    btn_selecionar_sol.grid(row=5, column=1, padx=5, pady=5)

    lbl_base = tk.Label(frame, text="Selecione a Base de Dados")
    lbl_base.grid(row=6, column=0, pady=5, sticky='w')
    btn_selecionar_base = tk.Button(frame, textvariable=arquivo_base, command=selecionar_base, wraplength=250, width=40)
    btn_selecionar_base.grid(row=6, column=1, padx=5, pady=5)

    # Defino uma fun√ß√£o que salva os valores das vari√°veis contendo o nome dos arquivos escolhidos.
    def salvar_valores():
        # Todas as condi√ß√µes a seguir seguem a l√≥gica de que, se um arquivo n√£o foi selecionado, uma janela avisando o ocorrido
        # aparece, pedindo para o usu√°rio selecionar um arquivo no campo requerido.

        if not arquivo_sme.get() or arquivo_sme.get() == "Selecione a planilha do SME":
            messagebox.showwarning("Aviso", "Por favor, selecione a planilha do SME.")
            return
        if not arquivo_sma.get() or arquivo_sma.get() == "Selecione a planilha do SMA":
            messagebox.showwarning("Aviso", "Por favor, selecione a planilha do SMA.")
            return
        if not arquivo_scc.get() or arquivo_scc.get() == "Selecione a planilha do SCC":
            messagebox.showwarning("Aviso", "Por favor, selecione a planilha do SCC.")
            return
        if not arquivo_ssc.get() or arquivo_ssc.get() == "Selecione a planilha do SSC":
            messagebox.showwarning("Aviso", "Por favor, selecione a planilha do SSC.")
            return
        if not arquivo_outros.get() or arquivo_outros.get() == "Selecione a planilha dos Outros Institutos":
            messagebox.showwarning("Aviso", "Por favor, selecione a planilha dos Outros Institutos.")
            return
        if not arquivo_sol.get() or arquivo_sol.get() == "Selecione a planilha com os Dados da Solu√ß√£o do Modelo":
            messagebox.showwarning("Aviso", "Por favor, selecione a planilha com os Dados da Solu√ß√£o do Modelo.")
            return
        if not arquivo_base.get() or arquivo_base.get() == "Selecione a Base de Dados":
            messagebox.showwarning("Aviso", "Por favor, selecione a Base de Dados.")
            return

        # Se todos os arquivos tiverem sido selecionados corretamente, crio uma lista com os elencos das disciplinas.
        elenco = [arquivo_sme.get(), arquivo_sma.get(), arquivo_scc.get(), arquivo_ssc.get(), arquivo_outros.get()]

        # E chamo a fun√ß√£o que ir√° realizar o preenchimento de cada um dos arquivos.
        preenchimento(elenco, arquivo_sol.get(), arquivo_base.get(), True)

        # # Com a conclus√£o do preenchimento, aviso o usu√°rio dos novos arquivos preenchidos.
        # messagebox.showinfo("Sucesso!", f"Os seguintes arquivos foram criados utilizando os Dados da Solu√ß√£o do Modelo:\n\
        # - {os.path.basename(arquivo_sme.get()).replace('.xlsx', ' Preenchido.xlsx')}\n\
        # - {os.path.basename(arquivo_sma.get()).replace('.xlsx', ' Preenchido.xlsx')}\n\
        # - {os.path.basename(arquivo_scc.get()).replace('.xlsx', ' Preenchido.xlsx')}\n\
        # - {os.path.basename(arquivo_ssc.get()).replace('.xlsx', ' Preenchido.xlsx')}\n\
        # - {os.path.basename(arquivo_outros.get()).replace('.xlsx', ' Preenchido.xlsx')}\n\
        # - {os.path.basename(arquivo_base.get()).replace('.xlsx', ' Preenchido.xlsx')}\n")

        # E fecho a janela que havia sido criada.
        nova_janela.destroy()

    # Defino uma fun√ß√£o que salva os valores das vari√°veis contendo o nome dos arquivos escolhidos.
    def salvar_valores1():
        # Todas as condi√ß√µes a seguir seguem a l√≥gica de que, se um arquivo n√£o foi selecionado, uma janela avisando o ocorrido
        # aparece, pedindo para o usu√°rio selecionar um arquivo no campo requerido.

        if not arquivo_sme.get() or arquivo_sme.get() == "Selecione a planilha do SME":
            messagebox.showwarning("Aviso", "Por favor, selecione a planilha do SME.")
            return
        if not arquivo_sma.get() or arquivo_sma.get() == "Selecione a planilha do SMA":
            messagebox.showwarning("Aviso", "Por favor, selecione a planilha do SMA.")
            return
        if not arquivo_scc.get() or arquivo_scc.get() == "Selecione a planilha do SCC":
            messagebox.showwarning("Aviso", "Por favor, selecione a planilha do SCC.")
            return
        if not arquivo_ssc.get() or arquivo_ssc.get() == "Selecione a planilha do SSC":
            messagebox.showwarning("Aviso", "Por favor, selecione a planilha do SSC.")
            return
        if not arquivo_outros.get() or arquivo_outros.get() == "Selecione a planilha dos Outros Institutos":
            messagebox.showwarning("Aviso", "Por favor, selecione a planilha dos Outros Institutos.")
            return
        if not arquivo_sol.get() or arquivo_sol.get() == "Selecione a planilha com os Dados da Solu√ß√£o do Modelo":
            messagebox.showwarning("Aviso", "Por favor, selecione a planilha com os Dados da Solu√ß√£o do Modelo.")
            return
        if not arquivo_base.get() or arquivo_base.get() == "Selecione a Base de Dados":
            messagebox.showwarning("Aviso", "Por favor, selecione a Base de Dados.")
            return



        # Se todos os arquivos tiverem sido selecionados corretamente, crio uma lista com os elencos das disciplinas.
        elenco = [arquivo_sme.get(), arquivo_sma.get(), arquivo_scc.get(), arquivo_ssc.get(), arquivo_outros.get()]

        escolhas_preenchimento(elenco, arquivo_sol.get(), arquivo_base.get())


    # Defino um bot√£o e sua posi√ß√£o na janela para chamar a fun√ß√£o que salva os nomes dos arquivos.

    btn_salvar1 = ttk.Button(frame, text="Preencher Planilhas com escolhas do usu√°rio", command=salvar_valores1)
    btn_salvar1.grid(row=7, column=0, pady=10)

    btn_salvar2 = ttk.Button(frame, text="Preencher Planilhas com a Solu√ß√£o Completa", command=salvar_valores)
    btn_salvar2.grid(row=7, column=1, pady=10)

"""## Escolhas de Preenchimento"""

# Fun√ß√£o que define uma janela para o menu de preenchimento dos arquivos.
def escolhas_preenchimento(elenco1, file_path_sol1, file_path_base1):

    elenco = elenco1

    file_path_sol = file_path_sol1

    file_path_base = file_path_base1

    # Crio uma nova janela em cima da janela principal da interface.
    nova_janela1 = tk.Toplevel(root)
    nova_janela1.title("Selecione quais aulas devem ser fixadas")
    nova_janela1.geometry("+250+150")



    # Criando um Frame para conter o Canvas e a Scrollbar
    frame_principal = tk.Frame(nova_janela1)
    frame_principal.pack(fill=tk.BOTH, expand=True)

    # Criando um Canvas dentro do Frame principal
    canvas = tk.Canvas(frame_principal)
    canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

    # Criando uma Scrollbar para o Canvas
    scrollbar = tk.Scrollbar(frame_principal, orient=tk.VERTICAL, command=canvas.yview)
    scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

    # Criando um Frame dentro do Canvas para colocar os checkboxes
    frame_checkboxes = tk.Frame(canvas)

    # Adicionando o Frame ao Canvas
    canvas.create_window((0, 0), window=frame_checkboxes, anchor="nw")

    df = pd.read_excel(file_path_sol)
    # df = pd.read_excel('C:/Users/gabri/Est√°gio/C√≥digos/Endgame/Dados da Solu√ß√£o do Modelo.xlsx')

    labels = ['Disciplina', 'Hor√°rio', 'Sala', 'Inscritos', 'Fixar sala']
    for label in labels:
        tk.Label(frame_checkboxes, text=label).grid(row=0, column=labels.index(label), pady=5, padx=5, sticky='ew')
    ttk.Separator(frame_checkboxes, orient="horizontal").grid(row=1, column=0, columnspan=5, sticky="ew", pady=(0, 10))

    df = df.sort_values(by=['Disciplina'], ignore_index=True)


    vars_checkboxes = []  # Lista para armazenar as vari√°veis dos checkboxes
    for d in df.index:
        tk.Label(frame_checkboxes, text=df.loc[d, 'Disciplina']).grid(row=2+(2*d), column=0, pady=5, padx=5, sticky='ew')
        tk.Label(frame_checkboxes, text=df.loc[d, 'Hor√°rio']).grid(row=2+(2*d), column=1, pady=5, padx=5, sticky='ew')
        tk.Label(frame_checkboxes, text=df.loc[d, 'Sala']).grid(row=2+(2*d), column=2, pady=5, padx=5, sticky='ew')
        tk.Label(frame_checkboxes, text=df.loc[d, 'Inscritos']).grid(row=2+(2*d), column=3, pady=5, padx=5, sticky='ew')
        # tk.Label(frame_checkboxes, text='Fixar').grid(row=d+2, column=4, pady=5, padx=5, sticky='ew')
        ttk.Separator(frame_checkboxes, orient="horizontal").grid(row=3+(2*d), column=0, columnspan=5, sticky="ew", pady=(0, 10))
        var = tk.BooleanVar()
        # checkbox = tk.Checkbutton(frame_checkboxes, text=opcao, variable=var)
        tk.Checkbutton(frame_checkboxes, text='Fixar', variable=var).grid(row=2+(2*d), column=4, pady=5, padx=5, sticky='ew')
        vars_checkboxes.append(var)  # Salvando a vari√°vel para futura refer√™ncia


    # Atualizando o tamanho do Frame dentro do Canvas
    def atualizar_scroll(event):
        canvas.configure(scrollregion=canvas.bbox("all"))

    frame_checkboxes.bind("<Configure>", atualizar_scroll)

    # Configurando a Scrollbar para controlar o Canvas
    canvas.configure(yscrollcommand=scrollbar.set)


    def salvar_valores():

        # print(elenco1, file_path_sol1, file_path_base1)
        elenco = elenco1

        file_path_sol = file_path_sol1

        file_path_base = file_path_base1
        # print(elenco, file_path_sol, file_path_base)
        new_df = pd.DataFrame(columns=df.columns)
        for var in vars_checkboxes:
            if var.get():
                index = vars_checkboxes.index(var)
                new_df.loc[len(new_df)] = df.loc[index]

        try:
            new_df.to_excel(file_path_sol.replace('.xlsx',' com Fixadas.xlsx'), sheet_name="Resultados", index=False)
        except PermissionError as e:
                if e.errno == 13:  # Erro de permiss√£o (arquivo aberto ou bloqueado)
                    messagebox.showerror("Erro de Permiss√£o", 
                                            (
                                                f"N√£o foi poss√≠vel salvar o arquivo {file_path_sol.replace('.xlsx',' com Fixadas.xlsx')}. "
                                                "Verifique se ele est√° aberto em outro programa (como o Excel) e tente novamente."
                                            )
                                        )
                    return
                else:
                    messagebox.showerror("Erro", f"Erro de permiss√£o:\n\n{str(e)}")
                    return
        except Exception as e:
            # Para qualquer outro erro
            messagebox.showerror("Erro inesperado!", f"Ocorreu um erro inesperado:\n\n{str(e)}")
            return

        # Se todos os arquivos tiverem sido selecionados corretamente, crio uma lista com os elencos das disciplinas.
        # elenco = [arquivo_sme.get(), arquivo_sma.get(), arquivo_scc.get(), arquivo_ssc.get(), arquivo_outros.get()]

        # E chamo a fun√ß√£o que ir√° realizar o preenchimento de cada um dos arquivos.
        
        preenchimento(elenco, file_path_sol.replace('.xlsx',' com Fixadas.xlsx'), file_path_base, False)
        

        


        # E fecho a janela que havia sido criada.
        nova_janela1.destroy()


    # Determinar a √∫ltima linha utilizada
    ultima_linha = 2 + 2 * len(df)

    ttk.Button(frame_checkboxes, text="Preencher planilhas com salas fixadas",
               command=salvar_valores).grid(row=ultima_linha, column=3, pady=5, padx=5, sticky='ew')

    nova_janela1.wait_window()

"""## Fun√ß√£o para preencher"""

# Fun√ß√£o que preenche os arquivos fornecidos pelo usu√°rio.
def preenchimento(lista_elenco, file_path_sol, file_path_base, preencher_elenco):
    # Abro a solu√ß√£o dada pelo modelo como um dataframe.
    solucao = pd.read_excel(file_path_sol)


    if preencher_elenco:
        # Para cada elenco na lista de elencos:
        for file_path_elenco in lista_elenco:
            # Leio e salvo o arquivo em uma vari√°vel.
            elenco = pd.read_excel(file_path_elenco)
            # file_path = 'C:/Users/gabri/Est√°gio/C√≥digos/Endgame/Testes/Elenco SME_2025 testando.xlsx'
            # sme = pd.read_excel(file_path)

            # Defino uma vari√°vel com o nome de um cabe√ßalho para ser encontrado, caso o cabe√ßalho n√£o seja a primeira linha da planilha.
            header_name = 'Disciplina (c√≥digo)'

            # Para cada linha e c√©lula da primeira coluna do dataframe:
            for i, valor in enumerate(elenco.loc[:,elenco.columns[0]]):
                # Se o valor da c√©lula for o nome do cabe√ßalho que estou procurando:
                if valor == header_name:
                    # Salvo o n√∫mero da linha do cabe√ßalho.
                    header_row = i+1

                    # E interrompo o loop.
                    break

            # Leio o arquivo da forma correta.
            elenco = pd.read_excel(file_path_elenco, header=header_row)

            # Para cada coluna da planilha:
            for col in range(len(elenco.columns)):
                # Verifico se tem um "\n" no texto do dataframe:
                if "\n" in elenco.columns[col]:
                    # Se houver, substituo ele por um " ".
                    elenco = elenco.rename(columns={elenco.columns[col] : elenco.columns[col].replace("\n", " ")})
                # Verifico se estou na coluna das salas:
                if "Sala" in elenco.columns[col]:
                    # Se estiver, substituo o nome da coluna por apenas "Sala"
                    elenco = elenco.rename(columns={elenco.columns[col] : "Sala"})



            # Como ler o arquivo como um dataframe e salv√°-lo altera a estrutura da planilha, preciso abrir o arquivo como um
            # workbook, e utilizarei o dataframe definido anteriormente para utilizar m√©todos de busca mais eficientes.
            wb = load_workbook(file_path_elenco)
            ws = wb.active

            # Para cada linha do dataframe:
            for d in range(len(elenco)):
                # Garanto que o c√≥digo de uma disciplina n√£o possui espa√ßos.
                elenco.loc[d, 'Disciplina (c√≥digo)'] = str(elenco.loc[d, 'Disciplina (c√≥digo)']).replace(' ', '')

                # Adiciono um tra√ßo '-' e o n√∫mero da turma ao nome da disciplina para ser igual
                # ao utilizado no modelo.
                disciplina = str(elenco.loc[d, 'Disciplina (c√≥digo)']) + '-' + str(elenco.loc[d, 'Turma'])

                # Verifico se a disciplina em quest√£o foi inclu√≠da na solu√ß√£o:
                if disciplina in solucao['Disciplina'].tolist():

                    # Se foi, salvo a linha da disciplina com um acr√©scimo de duas unidades; uma para pular a linha do cabe√ßalho, e a outra para
                    # igualar com os √≠ndices das linhas do workbook.
                    row = d+2

                    # Semelhantemente, salvo o √≠ndice da coluna de salas do dataframe com um acr√©scimo de 1.
                    coluna = elenco.columns.get_loc('Sala')+1

                    # Limpo o valor da c√©lula da sala da disciplina d, utilizando uma soma de √≠ndices para garantir
                    # que a linha est√° correta.
                    ws.cell(row=header_row+row, column=coluna).value = None

                    # Agora, fa√ßo um pequeno filtro das linhas de solu√ß√£o da disciplina, ou seja,
                    # filtro os dados da solu√ß√£o para analisar apenas os que pertencem √†s aulas da disciplina.
                    solucao_filtrada = solucao[solucao['Disciplina'] == disciplina]


                    # Antes de explicar cada linha do trecho seguinte, devo explicar a l√≥gica por tr√°s dele.
                    # Com a solu√ß√£o filtrada, eu tenho, separadamente, os hor√°rios das aulas de uma disciplina e a sala
                    # onde cada uma foi alocada. Dessa forma, eu consigo iterar no comprimento da solu√ß√£o filtrada,
                    # que deve me dar o n√∫mero de colunas de hor√°rio que aquela disciplina possui.
                    # E se eu cruzar essa itera√ß√£o com uma que verifica se uma das aulas corresponde com a atual coluna de hor√°rio,
                    # eu consigo cruzar colocar, em ordem, qual a sala de cada aula.

                    # Para cada linha dessa solu√ß√£o filtrada, que diz respeito a cada aula da disciplina:
                    for i in range(len(solucao_filtrada)):
                        # E para cada aula da disciplina na solu√ß√£o filtrada:
                        for a in solucao_filtrada.index:
                            # Verifico se o hor√°rio da coluna 'Hor√°rio i+1' bate com o hor√°rio da aula 'a':
                            if elenco.loc[d, 'Hor√°rio ' + str(i+1)] == solucao_filtrada.loc[a, 'Hor√°rio']:
                                # Se os hor√°rios batem, verifico se algum outro hor√°rio j√° foi colocado na c√©lula:
                                if ws.cell(row=header_row+row, column=coluna).value:
                                    # Se foi, defino o novo valor da c√©lula como o valor antigo somado com o novo, mas separado por uma v√≠rgula.
                                    novo_valor = str(ws.cell(row=header_row+row, column=coluna).value) + ', ' + str(solucao_filtrada.loc[a, 'Sala'])

                                    # E defino o valor da c√©lula com esse novo valor.
                                    ws.cell(row=header_row+row, column=coluna).value = novo_valor

                                # Como eu havia limpado todas as c√©lulas de sala anteriormente, tenho certeza que n√£o h√° nenhum outro hor√°rio,
                                # ent√£o coloco o primeiro na c√©lula respectiva.
                                else:
                                    ws.cell(row=header_row+row, column=coluna).value = str(solucao_filtrada.loc[a, 'Sala'])


            try:
                # Ap√≥s isso, salvo um novo arquivo de elenco de mesmo nome, mas adicionando 'Preenchido' para saber qual √© qual.
                wb.save(file_path_elenco.replace('.xlsx', ' Preenchido.xlsx'))
            except PermissionError as e:
                if e.errno == 13:  # Erro de permiss√£o (arquivo aberto ou bloqueado)
                    messagebox.showerror("Erro de Permiss√£o", 
                                            (
                                                f"N√£o foi poss√≠vel salvar o arquivo {file_path_sol.replace('.xlsx',' com Fixadas.xlsx')}. "
                                                "Verifique se ele est√° aberto em outro programa (como o Excel) e tente novamente."
                                            )
                                        )
                    return
                else:
                    messagebox.showerror("Erro", f"Erro de permiss√£o:\n\n{str(e)}")
                    return
            except Exception as e:
                # Para qualquer outro erro
                messagebox.showerror("Erro inesperado!", f"Ocorreu um erro inesperado:\n\n{str(e)}")
                return
        
        

    # Com todos os elencos preenchidos, agora resta preencher a base de dados para o modelo.
    # Assim, abro a base de dados como um arquivo Excel.
    base = pd.ExcelFile(file_path_base)

    # Salvo quais as planilhas do arquivo.
    sheet_names = base.sheet_names

    # E leio novamente o arquivo, mas como um dataframe com as planilhas corretas.
    base = pd.read_excel(file_path_base, sheet_name=sheet_names)


    # Para cada planilha de disciplinas, isto √©, para cada planilha ap√≥s a planilha de salas:
    for sheet in sheet_names[1:]:
        # Refa√ßo a mesma l√≥gica feita anteriormente. Verificarei se a disciplina foi alocada em alguma sala, filtrarei o dataframe,
        # e cruzarei os dados da solu√ß√£o com os do dataframe, deixando o mesmo formato e ordem das salas para cada aula das disciplinas.
        for d in range(len(base[sheet])):
            disciplina = base[sheet].loc[d, 'Disciplina (c√≥digo)']

            if disciplina in solucao['Disciplina'].tolist():
                base[sheet].loc[d, 'Sala'] = None
                solucao_filtrada = solucao[solucao['Disciplina'] == disciplina]


                novo_valor = ['0', '0', '0', '0']
                for i in range(4):
                    for a in solucao_filtrada.index:
                        if base[sheet].loc[d, 'Hor√°rio ' + str(i+1)] == solucao_filtrada.loc[a, 'Hor√°rio']:
                            novo_valor[i] = str(solucao_filtrada.loc[a, 'Sala'])

                salas_fixadas = novo_valor[0]
                for s in novo_valor[1:]:
                    salas_fixadas += ', ' + str(s)

                base[sheet].loc[d, 'Sala'] = salas_fixadas

    try:
        # Com o novo dataframe constru√≠do, salvo-o como arquivo Excel com o nome alterado para distin√ß√£o.
        with pd.ExcelWriter(file_path_base.replace('.xlsx', ' Preenchido.xlsx'), engine="openpyxl") as writer:
            for sheet in sheet_names:
                base[sheet].to_excel(writer, sheet_name=sheet, index=False)
    except PermissionError as e:
        if e.errno == 13:  # Erro de permiss√£o (arquivo aberto ou bloqueado)
            messagebox.showerror("Erro de Permiss√£o", 
                                    (
                                        f"N√£o foi poss√≠vel salvar o arquivo {file_path_sol.replace('.xlsx',' com Fixadas.xlsx')}. "
                                        "Verifique se ele est√° aberto em outro programa (como o Excel) e tente novamente."
                                    )
                                )
            return
        else:
            messagebox.showerror("Erro", f"Erro de permiss√£o:\n\n{str(e)}")
            return
    except Exception as e:
        # Para qualquer outro erro
        messagebox.showerror("Erro inesperado!", f"Ocorreu um erro inesperado:\n\n{str(e)}")
        return
    
    if preencher_elenco:
        # Com a conclus√£o do preenchimento, aviso o usu√°rio dos novos arquivos preenchidos.
        messagebox.showinfo("Sucesso!", f"O seguinte arquivo foi criado utilizando os Dados da Solu√ß√£o do Modelo:\n\
        - {os.path.basename(lista_elenco[0].replace('.xlsx', ' Preenchido.xlsx'))}\n\
        - {os.path.basename(lista_elenco[1].replace('.xlsx', ' Preenchido.xlsx'))}\n\
        - {os.path.basename(lista_elenco[2].replace('.xlsx', ' Preenchido.xlsx'))}\n\
        - {os.path.basename(lista_elenco[3].replace('.xlsx', ' Preenchido.xlsx'))}\n\
        - {os.path.basename(lista_elenco[4].replace('.xlsx', ' Preenchido.xlsx'))}\n\
        - {os.path.basename(file_path_base.replace('.xlsx', ' Preenchido.xlsx'))}\n")
    else:
        # Com a conclus√£o do preenchimento, aviso o usu√°rio dos novos arquivos preenchidos.
        messagebox.showinfo("Sucesso!", f"O seguinte arquivo foi criado utilizando os Dados da Solu√ß√£o do Modelo:\n\
        - {os.path.basename(file_path_sol)}\n\
        - {os.path.basename(file_path_base.replace('.xlsx', ' Preenchido.xlsx'))}\n")

import os
from google.colab import drive
from IPython.display import clear_output

# 1. Configura√ß√£o do Google Drive
def setup_drive():
    """Monta o Google Drive e cria a estrutura de pastas"""
    # Monta o Google Drive
    drive.mount('/content/drive')
    
    # Caminho base no Drive (pode ser ajustado)
    drive_path = '/content/drive/MyDrive/Estagio-SVGrad'
    
    # Cria a pasta principal se n√£o existir
    os.makedirs(drive_path, exist_ok=True)
    
    # Cria a estrutura de pastas
    saidas_path = os.path.join(drive_path, "Sa√≠das da Interface")
    subpastas = ["Planilhas de Dados", "Sa√≠das do Modelo"]
    
    os.makedirs(saidas_path, exist_ok=True)
    for subpasta in subpastas:
        os.makedirs(os.path.join(saidas_path, subpasta), exist_ok=True)
    
    return saidas_path

# Iniciar a interface

"""Exibe o menu principal e gerencia as op√ß√µes"""
saidas = setup_drive()
executando = True

while executando:
    clear_output(wait=True)
    print("=== MENU PRINCIPAL ===")
    print("1. Construir Planilha com os dados das Aulas")
    print("2. Construir Planilha com os dados do J√∫piterWeb")
    print("3. Construir Base de Dados do Modelo")
    print("4. Construir Base de Dados de Pior Caso")
    print("5. Verificar Dados e Executar Modelo")
    print("6. Relat√≥rio de Espa√ßos Livres")
    print("7. Preencher planilhas com Dados da Solu√ß√£o")
    print("S. Sair")
    print("======================")
    
    opcao = input("Digite o n√∫mero da op√ß√£o desejada: ").strip().upper()
    
    if opcao == '1':
        planilha_dep(jupiter=False)
        input("\nPressione Enter para continuar...")
    elif opcao == '2':
        planilha_dep(jupiter=True)
        input("\nPressione Enter para continuar...")
    elif opcao == '3':
        base_dados(pior_caso=False)
        input("\nPressione Enter para continuar...")
    elif opcao == '4':
        base_dados(pior_caso=True)
        input("\nPressione Enter para continuar...")
    elif opcao == '5':
        execute()
        input("\nPressione Enter para continuar...")
    elif opcao == '6':
        analise_vazios()
        input("\nPressione Enter para continuar...")
    elif opcao == '7':
        preencher_planilha_dados()
        input("\nPressione Enter para continuar...")
    elif opcao == 'S':
        executando = False
    else:
        print("Op√ß√£o inv√°lida! Tente novamente.")
        input("\nPressione Enter para continuar...")

print("\nObrigado por utilizar a interface!")

