# -*- coding: utf-8 -*-
"""Interface final.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/github/TurnipPudding/Estagio-SVGrad/blob/Testando_proibir_horarios_com_eta/Interface%20final.ipynb

## Imports
"""

import tkinter as tk # Biblioteca Tkinter para fazer a interface.
# Objetos e classes importantes da biblioteca Tkinter para fazer a interface.
from tkinter import ttk, simpledialog, filedialog, messagebox, scrolledtext, Checkbutton, Entry, IntVar, DISABLED, NORMAL
import pandas as pd # Biblioteca Pandas para trabalhar com dataframes e planilhas do Excel.
import subprocess # Biblioteca Subprocess para chamar a execução de scripts/outros códigos em Python.
import os # Biblioteca OS para auxiliar na criação e salvamento de arquivos.
# Biblioteca Openpyxl para trabalhar com planilhas do Excel de forma mais elaborada.
import openpyxl
from openpyxl import Workbook
from openpyxl.styles import PatternFill, Alignment, Border, Side
from openpyxl.utils import get_column_letter
from openpyxl import load_workbook
from openpyxl.formatting.rule import DataBar, FormatObject, Rule
from datetime import datetime, timedelta # Funções para a leitura de horários de aula
import sys
import re # Biblioteca Regex para trabalhar com expressões regulares.

"""# Teste de Interface mais Clara

## Padroniza dataframe
"""

# Função que padroniza os dataframes para terem o mesmo formato.
def padroniza_dataframe(file_name, header_row, ano):
    """
    Função que padroniza os dataframes para terem o mesmo formato.
    Parâmetros:
    - file_name: nome do arquivo a ser lido.
    - header_row: número da linha onde o cabeçalho do arquivo está localizado.
    - ano: ano dos dados fornecidos.
    """
    # Leio o dataframe correto, com a linha do cabeçalho.
    df = pd.read_excel(file_name, header=header_row)
    # Verifico e ajusto os nomes das colunas para evitar problemas de leitura posteriormente.
    # Primeiramente, para cada cabeçalho/coluna 'col' do dataframe.
    for col in range(len(df.columns)):
        # Verifico se tem um "\n" no texto do dataframe.
        if "\n" in df.columns[col]:
            # Se houver, substituo ele por um " ".
            df = df.rename(columns={df.columns[col] : df.columns[col].replace("\n", " ")})
        # Verifico se estou na coluna das salas - "Sala (a definir)".
        if "Sala" in df.columns[col]:
            # Se estiver, substituo o nome da coluna por apenas "Sala".
            df = df.rename(columns={df.columns[col] : "Sala"})

    # Padronizo os valores da coluna 'Deve ser alocada no ICMC?' para evitar problemas de filtragem.
    for idx, row in df.iterrows():
        # Removo espaços e padronizo o valor 'x' para 'X'.
        df.loc[idx, 'Deve ser alocada no ICMC?'] = str(df.loc[idx, 'Deve ser alocada no ICMC?']).replace(' ', '')
        if df.loc[idx, 'Deve ser alocada no ICMC?'] == 'x':
            df.loc[idx, 'Deve ser alocada no ICMC?'] = 'X'
    # Filtro o dataframe para fazer a edição apenas nas disciplinas que importam.
    # Isto é, eu passo a trabalhar apenas com as disciplinas marcadas com um 'X' que devem ser alocadas no ICMC.
    df = df[df['Deve ser alocada no ICMC?'] == 'X']

    # Garante que todas as colunas de horários necessárias existam no dataframe, adicionando-as se necessário.
    # Após editar os cabeçalhos, verifico se existe um cabeçalho chamado "Horário 3" no dataframe.
    if "Horário 3" not in df.columns:
        # Se não houver, eu o adiciono no dataframe. Primeiro, procuro pelo cabeçalho "Horário 2", e insiro a nova coluna ao lado.
        df.insert(df.columns.get_loc("Horário 2") + 1, "Horário 3", pd.NA)

    # Após editar os cabeçalhos, verifico se existe um cabeçalho chamado "Horário 4" no dataframe.
    if "Horário 4" not in df.columns:
        # Se não houver, eu o adiciono no dataframe. Primeiro, procuro pelo cabeçalho "Horário 3", e insiro a nova coluna ao lado.
        df.insert(df.columns.get_loc("Horário 3") + 1, "Horário 4", pd.NA)

    # Padronizo o nome da coluna de observações para evitar problemas de leitura.
    if "observações" in df.columns:
        df = df.rename(columns={"observações" : "Observações"})

    # Garante que a coluna "Observações" exista no dataframe.
    if "Observações" not in df.columns:
        df.insert(df.columns.get_loc("Horário 4") + 1, "Observações", pd.NA)

    # Salvo o nome dos cabeçalhos do dataframe após as edições.
    headers = df.columns

    # Preencho os espaços vazios da coluna de uso de laboratórios com "Não". Dessa forma, o usuário só precisa indicar qual disciplina
    # requer um laboratório.
    df['Utilizará laboratório? (sim ou não)'] = df['Utilizará laboratório? (sim ou não)'].fillna("Não")
    # print(df['Utilizará laboratório? (sim ou não)'])

    # Verifico se há disciplinas sem turma definida e alerto o usuário caso existam.
    # Busco e listo por disciplinas cuja Turma não foi definida.
    turmas0 = df[df['Turma'].isna()].index.tolist()
    # Se existirem tais disciplinas, uma janela é aberta para indicar as linhas do arquivo que possuem turmas vazias.
    if len(turmas0) != 0:
        messagebox.showwarning(f"Aviso!", 
                               (
                                   f"A(s) linha(s) {[d + header_row + 2 for d in turmas0]} do arquivo {file_name} "
                                   f"possuem turmas não identificadas. Verifique qual a turma da disciplina."
                                )
                            )
        return None

    # Adiciono mais duas colunas no dataframe, uma para colocar o número de inscritos das disciplinas, e outra para o ano dos dados.
    # A coluna "Vagas por disciplina" será preenchida posteriormente.
    df.insert(df.columns.get_loc(headers[-1]), "Vagas por disciplina", "")
    # A coluna "Ano dos dados" registra o ano dos dados fornecidos.
    df.insert(df.columns.get_loc(headers[-1]), "Ano dos dados", ano)

    # Realizo a padronização dos horários, corrigindo traços e verificando o formato esperado.
    # Alguns horários das disciplinas podem ter sido definidos com um traço diferente do usual do teclado.
    # Por isso, eu busco em cada coluna de horários por esses possíveis traços errados, pois eles prejudicam a leitura das disciplinas.
    # Para cada coluna de horário:
    for header in ['Horário 1', 'Horário 2', 'Horário 3', 'Horário 4']:
        # Para cada linha do dataframe:
        for d in df.index:
            # Verifico se o traço anormal está na célula em questão.
            if "–" in str(df.loc[d, header]):
                # Se estiver, substituo-o pelo traço normal.
                df.loc[d, header] = df.loc[d, header].replace('–', '-')
            # Verifico se o horário está no formato correto, contendo o traço separador.
            if not pd.isna(df.loc[d, header]) \
                and "-" not in str(df.loc[d, header]) \
                    and not (df.loc[d, header] == ""):
                # print((df.loc[d, header]) == "")
                messagebox.showwarning(f"Aviso! Há um horário de aula não padronizado!",
                                   (
                                       f"Verifique a linha {d+header_row+2} da coluna {header} do arquivo {file_name}.\n"
                                       f"Padrão correto: 'Segunda - 08:10/09:50'\n"
                                       f"Provavelmente, falta um '-' entre o dia da semana e o horário da aula."
                                   )
                                )
                return None
            # Verifico se há mais de um traço, o que pode indicar erro de digitação.
            if not pd.isna(df.loc[d, header]) and len(str(df.loc[d, header]).split("-")) > 2:
                messagebox.showwarning(f"Aviso! Há um horário de aula não padronizado!",
                                   (
                                       f"Verifique a linha {d+header_row+2} da coluna {header} do arquivo {file_name}.\n"
                                       f"Padrão correto: 'Segunda - 08:10/09:50'\n"
                                       f"Provavelmente, há mais de um '-' na célula."
                                   )
                                )
                return None
            # Verifico se há quebra de linha na célula, o que pode prejudicar a leitura.
            if "\n" in str(df.loc[d, header]):
                messagebox.showwarning(f"Aviso! Há um horário de aula não padronizado!",
                                   (
                                       f"Verifique a linha {d+header_row+2} da coluna {header} do arquivo {file_name}.\n"
                                       f"Padrão correto: 'Segunda - 08:10/09:50'\n"
                                       f"Provavelmente, há uma quebra de linha na célula."
                                   )
                                )
                return None

    # Adiciono 4 colunas para anotar possíveis salas onde as aulas ficam PROIBIDAS de serem alocadas.
    # Cada coluna refere-se a uma coluna de horários, fazendo com que as salas listadas em uma coluna afetem apenas a aula de mesma coluna.
    # Ex: Adicionar a sala 3-009 na segunda coluna de proibição faz com que a aula do Horário 2 de uma disciplina não possa ser na 3-009.
    df.insert(df.columns.get_loc(headers[-1]), "Proibir Horário 1", pd.NA)
    df.insert(df.columns.get_loc(headers[-1]), "Proibir Horário 2", pd.NA)
    df.insert(df.columns.get_loc(headers[-1]), "Proibir Horário 3", pd.NA)
    df.insert(df.columns.get_loc(headers[-1]), "Proibir Horário 4", pd.NA)

    # Retorno o dataframe com todas as padronizações necessárias.
    return df

"""## Tooltip"""

# Classe Tooltip utilizada para mostrar textos ao sobrevoar o mouse em alguma parte da interface.
# Permite criar uma pequena janela de texto explicativo ao passar o mouse sobre um widget.
class Tooltip:
    """
    Classe Tooltip para exibir textos explicativos ao sobrevoar o mouse em widgets da interface.
    Parâmetros:
    - widget: widget da interface ao qual o tooltip será associado.
    - text: texto a ser exibido no tooltip.
    """
    def __init__(self, widget, text):
        self.widget = widget  # Widget ao qual o tooltip está associado
        self.text = text      # Texto a ser exibido no tooltip
        self.tooltip_window = None  # Janela do tooltip (inicialmente inexistente)

        # Eventos para mostrar e ocultar o tooltip ao passar o mouse
        widget.bind("<Enter>", self.show_tooltip)
        widget.bind("<Leave>", self.hide_tooltip)

    def show_tooltip(self, event=None):
        # Cria a janela do tooltip ao passar o mouse sobre o widget
        if self.tooltip_window is not None:
            # Se já existe uma janela de tooltip, não faz nada
            return

        # Calcula a posição X e Y do tooltip em relação ao widget
        x = self.widget.winfo_rootx() + 20  # Posição X do tooltip
        y = self.widget.winfo_rooty() + 20  # Posição Y do tooltip

        # Cria uma nova janela de tooltip
        self.tooltip_window = tk.Toplevel(self.widget)
        self.tooltip_window.wm_overrideredirect(True)  # Remove bordas da janela
        self.tooltip_window.geometry(f"+{x}+{y}")

        # Cria o label com o texto do tooltip
        label = tk.Label(
            self.tooltip_window,
            text=self.text,
            background="lightyellow",
            relief="solid",
            borderwidth=1,
            font=("Arial", 10)
        )
        label.pack(ipadx=5, ipady=3)

    def hide_tooltip(self, event=None):
        # Destroi a janela do tooltip ao retirar o mouse do widget
        if self.tooltip_window:
            self.tooltip_window.destroy()
            self.tooltip_window = None

"""## Ler planilhas dos institutos (Base de dados das aulas e do jupiter)"""

def planilha_dep(jupiter):
    """
    Função para criar a base de dados das aulas e a dos dados do JúpiterWeb.
    Parâmetros:
    - jupiter: variável booleana que indica se é para criar a base de dados do Júpiter (True) ou das aulas (False).
    """
    # Crio uma nova janela em cima da janela principal da interface.
    nova_janela = tk.Toplevel(root)

    # Defino o título da janela de acordo com o tipo de base de dados que será criada.
    if not jupiter:
        nova_janela.title("Construir Base de Dados das Aulas")
    else:
        nova_janela.title("Construir Base de Dados do JúpiterWeb")

    # Crio o frame para armazenar os botões e outros campos da nova janela.
    frame = tk.Frame(nova_janela)
    frame.pack(pady=10, padx=10)

    # Defino variáveis para armazenar os nomes dos arquivos necessários para criar a base de dados.
    arquivo_sme = tk.StringVar(value="Selecione a planilha do SME")
    arquivo_sma = tk.StringVar(value="Selecione a planilha do SMA")
    arquivo_scc = tk.StringVar(value="Selecione a planilha do SCC")
    arquivo_ssc = tk.StringVar(value="Selecione a planilha do SSC")
    arquivo_outros = tk.StringVar(value="Selecione a planilha dos Outros Institutos")
    arquivo_salas = tk.StringVar(value="Selecione a planilha dos dados das salas")
    ano_dados = IntVar()  # Variável para o ano dos dados fornecidos
    nome_arquivo = tk.StringVar()  # Variável para o nome da nova base de dados
    lista_outros = []  # Lista para armazenar arquivos de outros institutos

    # Funções para seleção dos arquivos de cada departamento
    def selecionar_sme():
        # Abre o gerenciador de arquivos para selecionar a planilha do SME
        arquivo = filedialog.askopenfilename(title="Selecione a planilha do SME")
        if arquivo:
            arquivo_sme.set(arquivo)
    def selecionar_sma():
        arquivo = filedialog.askopenfilename(title="Selecione a planilha do SMA")
        if arquivo:
            arquivo_sma.set(arquivo)
    def selecionar_scc():
        arquivo = filedialog.askopenfilename(title="Selecione a planilha do SCC")
        if arquivo:
            arquivo_scc.set(arquivo)
    def selecionar_ssc():
        arquivo = filedialog.askopenfilename(title="Selecione a planilha do SSC")
        if arquivo:
            arquivo_ssc.set(arquivo)

    # Se não estiver criando a base de dados do Júpiter, defino funções para os campos extras
    if not jupiter:
        def selecionar_outros():
            arquivo = filedialog.askopenfilename(title="Selecione a planilha dos Outros Institutos")
            if arquivo:
                arquivo_outros.set(arquivo)
        def selecionar_salas():
            arquivo = filedialog.askopenfilename(title="Selecione a planilha dos dados das salas")
            if arquivo:
                arquivo_salas.set(arquivo)

    # Crio os labels e botões para seleção dos arquivos
    lbl_sme = tk.Label(frame, text="Selecione a planilha do SME:")
    lbl_sme.grid(row=0, column=0, pady=5, sticky="w")
    btn_selecionar_sme = tk.Button(frame, textvariable=arquivo_sme, command=selecionar_sme, wraplength=250, width=40)
    btn_selecionar_sme.grid(row=0, column=1, padx=5, pady=5)

    lbl_sma = tk.Label(frame, text="Selecione a planilha do SMA:")
    lbl_sma.grid(row=1, column=0, pady=5, sticky="w")
    btn_selecionar_sma = tk.Button(frame, textvariable=arquivo_sma, command=selecionar_sma, wraplength=250, width=40)
    btn_selecionar_sma.grid(row=1, column=1, padx=5, pady=5)

    lbl_scc = tk.Label(frame, text="Selecione a planilha do SCC:")
    lbl_scc.grid(row=2, column=0, pady=5, sticky="w")
    btn_selecionar_scc = tk.Button(frame, textvariable=arquivo_scc, command=selecionar_scc, wraplength=250, width=40)
    btn_selecionar_scc.grid(row=2, column=1, padx=5, pady=5)

    lbl_ssc = tk.Label(frame, text="Selecione a planilha do SSC:")
    lbl_ssc.grid(row=3, column=0, pady=5, sticky="w")
    btn_selecionar_ssc = tk.Button(frame, textvariable=arquivo_ssc, command=selecionar_ssc, wraplength=250, width=40)
    btn_selecionar_ssc.grid(row=3, column=1, padx=5, pady=5)

    # Campos extras para outros institutos e salas, apenas se não for base do Júpiter
    if not jupiter:
        lbl_outros = tk.Label(frame, text="Selecione a planilha dos Outros Institutos:")
        lbl_outros.grid(row=4, column=0, pady=5, sticky="w")
        btn_selecionar_outros = tk.Button(frame, textvariable=arquivo_outros, command=selecionar_outros, wraplength=250, width=40)
        btn_selecionar_outros.grid(row=4, column=1, padx=5, pady=5)

        lbl_salas = tk.Label(frame, text="Selecione a planilha dos dados das salas:")
        lbl_salas.grid(row=5, column=0, pady=5, sticky="w")
        btn_selecionar_salas = tk.Button(frame, textvariable=arquivo_salas, command=selecionar_salas, wraplength=250, width=40)
        btn_selecionar_salas.grid(row=5, column=1, padx=5, pady=5)

        # Campo para inserir o ano dos dados
        lbl_ano = tk.Label(frame, text="Insira o ano dos dados:")
        lbl_ano.grid(row=6, column=0, sticky="w", pady=5)
        campo_ano = tk.Entry(frame, textvariable=ano_dados)
        campo_ano.grid(row=6, column=1, pady=5)

    # Se for base do Júpiter, crio frame e funções para lista de arquivos extras
    else:
        frame2 = tk.Frame(nova_janela)
        frame2.pack(pady=10, padx=10)

        def add_file():
            file_path = filedialog.askopenfilename(title="Selecione um arquivo")
            if file_path:
                lista_outros.append(file_path)
                update_listbox()

        def remove_selected():
            try:
                selected_index = file_listbox.curselection()[0]
                lista_outros.pop(selected_index)
                update_listbox()
            except IndexError:
                pass

        def update_listbox():
            file_listbox.delete(0, tk.END)
            for file in lista_outros:
                file_listbox.insert(tk.END, file)

        add_file_button = tk.Button(frame2, text="Adicionar Arquivo", command=add_file)
        add_file_button.grid(row=0, column=0, pady=5, sticky="w")

        file_listbox = tk.Listbox(frame2, width=100, height=10)
        file_listbox.grid(row=1, column=0, pady=5)

        remove_file_button = tk.Button(frame2, text="Remover Selecionado", command=remove_selected)
        remove_file_button.grid(row=0, column=0, pady=5, sticky="e")

    # Campo para inserir o nome do arquivo da base de dados
    lbl_arq = tk.Label(frame, text="Insira o nome para a base de dados:")
    lbl_arq.grid(row=7, column=0, sticky="w", pady=5)
    campo_arq = tk.Entry(frame, textvariable=nome_arquivo)
    campo_arq.grid(row=7, column=1, pady=5)

    # Função para salvar os valores dos arquivos selecionados e criar a base de dados
    def salvar_valores():
        # Valida se todos os arquivos obrigatórios foram selecionados
        if not arquivo_sme.get() or arquivo_sme.get() == "Selecione a planilha do SME":
            messagebox.showwarning("Aviso", "Por favor, selecione a planilha do SME.")
            return
        if not arquivo_sma.get() or arquivo_sma.get() == "Selecione a planilha do SMA":
            messagebox.showwarning("Aviso", "Por favor, selecione a planilha do SMA.")
            return
        if not arquivo_scc.get() or arquivo_scc.get() == "Selecione a planilha do SCC":
            messagebox.showwarning("Aviso", "Por favor, selecione a planilha do SCC.")
            return
        if not arquivo_ssc.get() or arquivo_ssc.get() == "Selecione a planilha do SSC":
            messagebox.showwarning("Aviso", "Por favor, selecione a planilha do SSC.")
            return

        # Valida campos extras se não for base do Júpiter
        if not jupiter:
            if not arquivo_outros.get() or arquivo_outros.get() == "Selecione a planilha dos Outros Institutos":
                messagebox.showwarning("Aviso", "Por favor, selecione a planilha dos Outros Institutos.")
                return
            if not arquivo_salas.get() or arquivo_salas.get() == "Selecione a planilha dos dados das salas":
                messagebox.showwarning("Aviso", "Por favor, selecione a planilha dos dados das salas.")
                return
            if not ano_dados.get():
                messagebox.showwarning("Aviso", "Por favor, insira o ano dos dados.")
                return
        else:
            # Valida se arquivos extras foram adicionados
            if len(lista_outros) == 0:
                resposta = messagebox.askyesno("Aviso", "Nenhum arquivo dos outros institutos foi selecionado. Deseja continuar sem eles?")
                if not resposta:
                    messagebox.showwarning("Aviso", "Por favor, selecione a(s) planilha(s) dos Outros Institutos.")
                    return

        # Valida se o nome do arquivo foi fornecido
        if not nome_arquivo.get():
            messagebox.showwarning("Aviso", "Por favor, insira o nome da base de dados.")
            return

        # Chama a função para concatenar os dados e criar a base de dados
        if not jupiter:
            concat_df(arquivo_sme.get(), arquivo_sma.get(), arquivo_scc.get(),
                      arquivo_ssc.get(), arquivo_salas.get(), nome_arquivo.get(), ano_dados.get(), jupiter, arquivo_outros.get())
        else:
            concat_df(arquivo_sme.get(), arquivo_sma.get(), arquivo_scc.get(),
                      arquivo_ssc.get(), None, nome_arquivo.get(), None, jupiter, lista_outros)

        # Após criar a base de dados, fecha a janela de seleção
        nova_janela.destroy()

    # Botão para criar a base de dados
    btn_salvar = tk.Button(nova_janela, text="Criar base de dados", command=salvar_valores)
    btn_salvar.pack(pady=10)

    # Observação sobre a ordem dos botões e widgets na janela
    # Por conta da maneira que os botões, textos e campos podem ser colocados na janela,
    # é possível deixar certos botões com uma ordem, mesmo que "o espaço entre eles deveria estar vazio".
    # Por exemplo: no caso de estar fazendo a base de dados do Júpiter, algumas posições podem estar denotadas como
    # linha 7 depois de linha 5, mas o espaço onde estaria a linha 6 não possui nada. Neste caso, a linha 7 é jogada para cima,
    # preenchendo o lugar da linha 6.
    # Em outras palavras, enquanto a ordem for mantida de menor para maior, mesmo que possa "faltar" definições em determinadas linhas,
    # a ordem e espaço dos objetos e widgets será mantida.

"""### Ler Dataframe"""

# Função que lê um dado arquivo.
def ler_df(caminho_arquivo):
    """
    Função que lê um arquivo de planilha e retorna um dataframe correspondente.
    Aceita arquivos nos formatos .xlsx, .xls e .csv. Caso o arquivo seja incompatível ou ocorra algum erro, exibe uma mensagem de erro.
    Parâmetros:
    - caminho_arquivo: caminho do arquivo a ser lido.
    Retorno:
    - DataFrame lido do arquivo, ou None em caso de erro.
    """
    # Tento ler um arquivo e retorno o dataframe correspondente.
    try:
        # Verifico o tipo de arquivo pelo sufixo e utilizo a leitura adequada.
        if caminho_arquivo.endswith(('.xlsx', '.xls')):
            # Arquivo Excel: uso pd.read_excel
            df = pd.read_excel(caminho_arquivo)
            return df
        elif caminho_arquivo.endswith('.csv'):
            # Arquivo CSV: uso pd.read_csv, pulando linhas ruins e usando separador ponto e vírgula
            df = pd.read_csv(caminho_arquivo, on_bad_lines='skip', sep=';', encoding='latin-1')
            return df
        else:
            # Caso o arquivo fornecido seja incompatível, exibo mensagem de erro ao usuário.
            raise ValueError("Formato de arquivo não suportado!")

    # No caso de algum erro inesperado ocorrer, exibo uma mensagem de erro ao usuário com o nome do erro.
    except Exception as e:
        messagebox.showerror("Erro", f"Erro ao carregar o arquivo:\n{e}")
        return None
    

"""### Concatenar"""

# Função que concatena as planilhas em um único arquivo.
def concat_df(SME, SMA, SCC, SSC, salas, nome_arquivo, ano, jupiter, outros):
    """
    Função que concatena planilhas de diferentes departamentos em um único arquivo Excel.
    Pode ser utilizada para criar a base de dados das aulas ou a base do JúpiterWeb, dependendo do parâmetro 'jupiter'.
    Parâmetros:
    - SME, SMA, SCC, SSC: caminhos dos arquivos dos departamentos principais.
    - salas: caminho do arquivo de dados das salas (usado apenas se jupiter=False).
    - nome_arquivo: nome do arquivo final a ser gerado.
    - ano: ano dos dados (usado apenas se jupiter=False).
    - jupiter: booleano, indica se é para criar a base do JúpiterWeb (True) ou das aulas (False).
    - outros: caminho(s) dos arquivos dos outros institutos (str ou list).
    """
    # Lista para armazenar os dataframes que serão concatenados.
    files = []
    
    if not jupiter:
        # Caso não seja para o JúpiterWeb, leio a planilha de salas separadamente.
        df_salas = ler_df(salas)

        # Lista com os arquivos dos departamentos e outros institutos.
        name_files = [SME, SMA, SCC, SSC, outros]

        # Para cada arquivo de departamento/outros:
        for name in name_files:
            # Leio e salvo o arquivo em uma variável.
            df = ler_df(name)

            # Nome do cabeçalho esperado para identificar a linha correta.
            header_name = 'Disciplina (código)'

            header_found = False
            # Procuro a linha do cabeçalho na primeira coluna do dataframe.
            for i, valor in enumerate(df.loc[:,df.columns[0]]):
                if valor == header_name:
                    header_row = i + 1  # Linha do cabeçalho
                    # Padronizo o dataframe a partir da linha do cabeçalho encontrada.
                    df_padronizado = padroniza_dataframe(name, header_row, ano)
                    # Se o dataframe foi lido corretamente e não está vazio:
                    if not df_padronizado.empty:
                        files.append(df_padronizado)
                    else:
                        # Caso haja erro ou arquivo vazio, exibo mensagem e interrompo.
                        messagebox.showerror(
                            f"Erro no arquivo",
                            (
                                f"O arquivo '{name}' não pode ser lido, está vazio, ou não foram marcadas as "
                                f"disciplinas a serem alocadas. Verifique-o."
                            )
                        )
                        return
                    header_found = True
                    break
            # Se não encontrou o cabeçalho esperado, exibe erro e interrompe.
            if not header_found:
                messagebox.showerror(
                    "Erro de Cabeçalho",
                    (
                        f"A coluna '{header_name}' não foi encontrada no arquivo {os.path.basename(name)}. "
                        "Verifique o cabeçalho do arquivo de entrada."
                    )
                )
                return
        # Nomes das abas das planilhas no arquivo final.
        sheets = ["SME", "SMA", "SCC", "SSC", "Outros"]

    # Para o caso de concatenando os arquivos para a base do Júpiter:
    else:
        # Defino uma lista com os nomes dos arquivos a serem concatenados.
        name_files = [SME, SMA, SCC, SSC]

        # Adiciono os nomes dos arquivos dos outros institutos a essa lista de nomes.
        name_files.extend(outros)

        sheets = []

        
    # Para cada nome de arquivo de outros institutos:
        for name in name_files:
            # Leio e salvo o arquivo em uma variável.
            df = ler_df(name)

            try:
                # Salvo a sigla das disciplinas daquele instituto. Eu considerei como sigla os 3 primeiros caracteres do nome de uma disciplina.
                # Ex: SME0230 pertence ao departamento do SME, 7600005 pertence ao departamento 760, e assim por diante.
                new_name = str(df.loc[0, 'Disciplina'])[:3]

            except KeyError as e:
                coluna_faltando = str(e).strip("'")
                messagebox.showerror("Erro de Cabeçalho", 
                                        (
                                            f"A coluna '{coluna_faltando}' não foi encontrada no arquivo {os.path.basename(name)}. "
                                            "Verifique o cabeçalho do arquivo de entrada."
                                        )
                                    )
                return

            except Exception as e:
                # Caso ocorra algum erro, alerto o usuário.
                messagebox.showerror("Erro inesperado", f"Ocorreu um erro inesperado:\n\n{e}")
                return
        
            # Com o arquivo lido, salvo a sigla do instituto na lista de siglas.
            sheets.append(new_name)

            # Salvo o dataframe em na lista dos arquivos que serão concatenados.
            files.append(df)


    # Com todos os dados obtidos e padronizados, verifico se o nome da base de dados termina com '.xlsx':
    if not nome_arquivo.endswith(".xlsx"):
        # Em caso negativo, adiciono essa terminologia.
        nome_arquivo = nome_arquivo + ".xlsx"


    # Com todos os dados obtidos e padronizados, verifico se o nome da base de dados termina com '.xlsx':
    if not nome_arquivo.endswith(".xlsx"):
        # Em caso negativo, adiciono essa terminologia.
        nome_arquivo = nome_arquivo + ".xlsx"

    try:
        # Para finalmente concatenar os arquivos lidos, defino o nome da base de dados com o nome disponível.
        with pd.ExcelWriter(os.path.join(saidas, nome_arquivo), engine="openpyxl") as writer:
            # Caso a base sendo definida não for a do Júpiter, preciso incluir a planilha de salas no arquivo.
            if not jupiter:
                df_salas.to_excel(writer, sheet_name="Salas", index=False)
    
            # Incluo todas as planilhas com as aulas dos departamentos no arquivo.
            for sh in range(len(files)):
                files[sh].to_excel(writer, sheet_name=sheets[sh], index=False)
    
        # Com o processo terminado, mostro uma mensagem confirmando que o arquivo foi criado com sucesso.
        messagebox.showinfo("Sucesso!", f"Arquivo {nome_arquivo} criado com sucesso!\nVerifique a pasta {saidas} para encontrá-lo.")

    except PermissionError as e:
        if e.errno == 13:  # Erro de permissão (arquivo aberto ou bloqueado)
            messagebox.showerror("Erro de Permissão", 
                                    (
                                        f"Não foi possível salvar o arquivo {nome_arquivo}. "
                                        "Verifique se ele está aberto em outro programa (como o Excel) e tente novamente."
                                    )
                                )
            return
        else:
            messagebox.showerror("Erro", f"Erro de permissão:\n\n{str(e)}")
            return

    except KeyError as e:
        coluna_faltando = str(e).strip("'")
        messagebox.showerror("Erro de Cabeçalho", 
                                        (
                                            f"A coluna '{coluna_faltando}' não foi encontrada no arquivo {os.path.basename(name)}. "
                                            "Verifique o cabeçalho do arquivo de entrada."
                                        )
                                    )
        return
    
    except Exception as e:
        # Para qualquer outro erro
        messagebox.showerror("Erro inesperado!", f"Ocorreu um erro inesperado:\n\n{str(e)}")
        return

"""## Construir base de dados completa"""

def base_dados(pior_caso):
    """
    Função que cria a base de dados completa, cruzando os dados das aulas com os dados do JúpiterWeb ou realizando a análise de pior caso.
    Parâmetros:
    - pior_caso: booleano. Se False, cria a base de dados cruzando aulas e JúpiterWeb. Se True, faz a análise de pior caso entre dois anos distintos.
    O usuário seleciona os arquivos necessários via interface gráfica, e o resultado é salvo em um arquivo Excel.
    """

    # Cria uma nova janela para a interface de seleção dos arquivos.
    nova_janela = tk.Toplevel(root)

    # Define o título da janela conforme o tipo de base de dados a ser criada.
    if not pior_caso:
        nova_janela.title("Construir Base de Dados do Modelo")
    else:
        nova_janela.title("Construir Base de Dados de Pior Caso")

    # Frame para armazenar os botões e campos da janela.
    frame = tk.Frame(nova_janela)
    frame.pack(pady=10, padx=10)

    # Variáveis para armazenar os caminhos dos arquivos selecionados.
    if not pior_caso:
        arquivo_base = tk.StringVar(value="Selecione a planilha dos dados das aulas")
        arquivo_jptr = tk.StringVar(value="Selecione a planilha dos dados do júpiter")
        arquivo_ing = tk.StringVar(value="Selecione a planilha dos dados dos ingressantes")
        arquivo_esp = tk.StringVar(value="Selecione a planilha com os inscritos das disciplinas com espelho")
    else:
        arquivo_base1 = tk.StringVar(value="Selecione a base de dados mais recente")
        arquivo_base2 = tk.StringVar(value="Selecione a base de dados mais antiga")

    nome_arquivo = tk.StringVar()  # Nome do arquivo final

    # Funções para seleção dos arquivos, adaptadas conforme o tipo de base.
    def selecionar_um():
        if not pior_caso:
            arquivo = filedialog.askopenfilename(title="Selecione a planilha dos dados das aulas")
            if arquivo:
                arquivo_base.set(arquivo)
        else:
            arquivo = filedialog.askopenfilename(title="Selecione a base de dados mais recente")
            if arquivo:
                arquivo_base1.set(arquivo)
    def selecionar_dois():
        if not pior_caso:
            arquivo = filedialog.askopenfilename(title="Selecione a planilha dos dados do júpiter")
            if arquivo:
                arquivo_jptr.set(arquivo)
        else:
            arquivo = filedialog.askopenfilename(title="Selecione a base de dados mais antiga")
            if arquivo:
                arquivo_base2.set(arquivo)

    # Funções extras para seleção dos arquivos dos ingressantes e espelho, apenas se não for pior caso.
    if not pior_caso:
        def selecionar_tres():
            arquivo = filedialog.askopenfilename(title="Selecione a planilha dos dados dos ingressantes")
            if arquivo:
                arquivo_ing.set(arquivo)
        def selecionar_quatro():
            arquivo = filedialog.askopenfilename(title="Selecione a planilha com os inscritos das disciplinas com espelho")
            if arquivo:
                arquivo_esp.set(arquivo)

    # Criação dos labels e botões para seleção dos arquivos.
    if not pior_caso:
        lbl_base = tk.Label(frame, text="Selecione a planilha dos dados das aulas")
        lbl_base.grid(row=0, column=0, pady=5, sticky="w")
        btn_selecionar_base = tk.Button(frame, textvariable=arquivo_base, command=selecionar_um, wraplength=250, width=40)
        btn_selecionar_base.grid(row=0, column=1, padx=5, pady=5)

        lbl_jptr = tk.Label(frame, text="Selecione a planilha dos dados do júpiter")
        lbl_jptr.grid(row=1, column=0, pady=5, sticky="w")
        btn_selecionar_jptr = tk.Button(frame, textvariable=arquivo_jptr, command=selecionar_dois, wraplength=250, width=40)
        btn_selecionar_jptr.grid(row=1, column=1, padx=5, pady=5)

        lbl_ing = tk.Label(frame, text="Selecione a planilha dos dados dos ingressantes")
        lbl_ing.grid(row=2, column=0, pady=5, sticky="w")
        btn_selecionar_ing = tk.Button(frame, textvariable=arquivo_ing, command=selecionar_tres, wraplength=250, width=40)
        btn_selecionar_ing.grid(row=2, column=1, padx=5, pady=5)

        lbl_esp = tk.Label(frame, text="Selecione a planilha com os inscritos das disciplinas com espelho")
        lbl_esp.grid(row=3, column=0, pady=5, sticky="w")
        btn_selecionar_esp = tk.Button(frame, textvariable=arquivo_esp, command=selecionar_quatro, wraplength=250, width=40)
        btn_selecionar_esp.grid(row=3, column=1, padx=5, pady=5)
    else:
        lbl_base1 = tk.Label(frame, text="Selecione a base de dados mais recente")
        lbl_base1.grid(row=0, column=0, pady=5, sticky="w")
        btn_selecionar_base1 = tk.Button(frame, textvariable=arquivo_base1, command=selecionar_um, wraplength=250, width=40)
        btn_selecionar_base1.grid(row=0, column=1, padx=5, pady=5)

        lbl_base2 = tk.Label(frame, text="Selecione a base de dados mais antiga")
        lbl_base2.grid(row=1, column=0, pady=5, sticky="w")
        btn_selecionar_base2 = tk.Button(frame, textvariable=arquivo_base2, command=selecionar_dois, wraplength=250, width=40)
        btn_selecionar_base2.grid(row=1, column=1, padx=5, pady=5)

    # Campo para inserir o nome do arquivo final.
    lbl_arq = tk.Label(frame, text="Insira o nome para a nova base de dados:")
    lbl_arq.grid(row=4, column=0, sticky="w", pady=5)
    campo_arq = tk.Entry(frame, textvariable=nome_arquivo)
    campo_arq.grid(row=4, column=1, pady=5)

    # Função que salva os valores dos arquivos e executa a criação da base de dados.
    def salvar_valores():
        # Validação dos campos obrigatórios, conforme o tipo de base.
        if not pior_caso:
            if not arquivo_base.get() or arquivo_base.get() == "Selecione a planilha dos dados das aulas":
                messagebox.showwarning("Aviso", "Por favor, selecione a planilha dos dados das aulas.")
                return
            if not arquivo_jptr.get() or arquivo_jptr.get() == "Selecione a planilha dos dados do júpiter":
                messagebox.showwarning("Aviso", "Por favor, selecione a planilha dos dados do júpiter.")
                return
            if not arquivo_ing.get() or arquivo_ing.get() == "Selecione a planilha dos dados dos ingressantes":
                messagebox.showwarning("Aviso", "Por favor, selecione a planilha dos dados dos ingressantes.")
                return
            if not arquivo_esp.get() or arquivo_esp.get() == "Selecione a planilha com os inscritos das disciplinas com espelho":
                messagebox.showwarning("Aviso", "Por favor, selecione a planilha com os inscritos das disciplinas com espelho.")
                return
        else:
            if not arquivo_base1.get() or arquivo_base1.get() == "Selecione a base de dados mais recente":
                messagebox.showwarning("Aviso", "Por favor, selecione a primeira base de dados.")
                return
            if not arquivo_base2.get() or arquivo_base2.get() == "Selecione a base de dados mais antiga":
                messagebox.showwarning("Aviso", "Por favor, selecione a segunda base de dados.")
                return

        # Validação do nome do arquivo final.
        nome = nome_arquivo.get()
        if not nome:
            messagebox.showwarning("Aviso", "Por favor, insira o nome da nova base de dados.")
            return
        if not nome.endswith(".xlsx"):
            nome = nome + ".xlsx"

        if not pior_caso:
            # Executa o script para cruzar os dados das aulas com os do JúpiterWeb.
            try:
                file1 = arquivo_base.get()
                file2 = arquivo_jptr.get()
                file3 = arquivo_ing.get()
                file4 = arquivo_esp.get()
                subprocess.run(
                    [sys.executable, "jupiter sheet maker.py", file1, file2, file3, file4, nome],
                    check=True,
                    capture_output=True,
                    text=True
                )
                # Mensagem de sucesso ao usuário.
                messagebox.showinfo("Sucesso!", f"Base de dados para o modelo criada com sucesso. Verifique o arquivo {nome}.")
            except subprocess.CalledProcessError as e:
                # Tratamento de erros específicos do subprocess.
                if e.returncode == 1:
                    msg = e.stderr.strip() if e.stderr else "Erro desconhecido."
                    messagebox.showerror("Erro", f"Erro ao executar o script. Verifique os arquivos de entrada.\n\n{msg}")
                elif e.returncode == 2:
                    msg = e.stderr.strip() if e.stderr else "Erro desconhecido."
                    messagebox.showerror("Erro", f"Erro de permissão. Verifique se o arquivo {nome} está aberto em outro programa.\n\n{msg}")
                elif e.returncode == 4:
                    msg = e.stderr.strip() if e.stderr else "Erro desconhecido."
                    messagebox.showerror("Erro", f"Erro ao executar o script:\n\n{msg}")
                else:
                    messagebox.showerror("Erro", f"Erro inesperado: {e}")
                return
            except Exception as e:
                # Tratamento de erros inesperados.
                messagebox.showerror("Erro", f"Erro inesperado: {e}")
                return
        else:
            # Realiza a análise de pior caso entre dois anos distintos.
            try:
                df1 = pd.read_excel(arquivo_base1.get(), sheet_name=["Salas", "SME", "SMA", "SCC", "SSC", "Outros"])
                df2 = pd.read_excel(arquivo_base2.get(), sheet_name=["Salas", "SME", "SMA", "SCC", "SSC", "Outros"])
                df_pior_caso = base_pior_caso(df1, df2, ["Salas", "SME", "SMA", "SCC", "SSC", "Outros"])
                with pd.ExcelWriter(os.path.join(saidas, nome), engine="openpyxl") as writer:
                    for sh, df_sh in df_pior_caso.items():
                        df_sh.to_excel(writer, sheet_name=sh, index=False)
                messagebox.showinfo("Sucesso!", f"Arquivo {nome} criado com sucesso!\nVerifique a pasta {saidas} para encontrá-lo.")
            except PermissionError as e:
                if e.errno == 13:
                    messagebox.showerror(
                        "Erro de Permissão",
                        (
                            f"Não foi possível salvar o arquivo {nome_arquivo}. "
                            "Verifique se ele está aberto em outro programa (como o Excel) e tente novamente."
                        )
                    )
                    return
                else:
                    messagebox.showerror("Erro", f"Erro de permissão:\n\n{str(e)}")
                    return
            except Exception as e:
                messagebox.showerror("Erro inesperado!", f"Ocorreu um erro inesperado:\n\n{str(e)}")
                return
        # Fecha a janela após a criação da base de dados.
        nova_janela.destroy()

    # Botão para executar a função de salvar valores e criar a base de dados.
    btn_salvar = tk.Button(nova_janela, text="Criar base de dados", command=salvar_valores)
    btn_salvar.pack(pady=10)


    # Cria uma nova janela sobre a janela principal da interface para seleção dos arquivos necessários.
    nova_janela = tk.Toplevel(root)

    # Define o título da janela de acordo com o tipo de base de dados que será criada.
    if not pior_caso:
        # Se não for análise de pior caso, título padrão para base do modelo.
        nova_janela.title("Construir Base de Dados do Modelo")
    else:
        # Se for análise de pior caso, título específico.
        nova_janela.title("Construir Base de Dados de Pior Caso")

        # Cria o frame para organizar os botões e campos na nova janela.
        frame = tk.Frame(nova_janela)
        frame.pack(pady=10, padx=10)

    # Variáveis para armazenar os caminhos dos arquivos selecionados, mudam conforme o tipo de base.
    if not pior_caso:
        # Para base do modelo: arquivos das aulas, JúpiterWeb, ingressantes e disciplinas com espelho.
        arquivo_base = tk.StringVar(value="Selecione a planilha dos dados das aulas")  # Planilha das aulas
        arquivo_jptr = tk.StringVar(value="Selecione a planilha dos dados do júpiter")  # Planilha do JúpiterWeb
        arquivo_ing = tk.StringVar(value="Selecione a planilha dos dados dos ingressantes")  # Planilha dos ingressantes
        arquivo_esp = tk.StringVar(value="Selecione a planilha com os inscritos das disciplinas com espelho")  # Planilha dos espelhos
    else:
        # Para análise de pior caso: duas bases de dados de anos diferentes.
        arquivo_base1 = tk.StringVar(value="Selecione a base de dados mais recente")  # Base mais recente
        arquivo_base2 = tk.StringVar(value="Selecione a base de dados mais antiga")   # Base mais antiga

    # Variável para armazenar o nome do arquivo final gerado.
    nome_arquivo = tk.StringVar()

    # Funções para seleção dos arquivos, adaptadas conforme o tipo de base.
    def selecionar_um():
        # Seleciona o primeiro arquivo necessário.
        if not pior_caso:
            # Seleciona a planilha das aulas.
            arquivo = filedialog.askopenfilename(title="Selecione a planilha dos dados das aulas")
            if arquivo:
                # Salva o caminho do arquivo selecionado.
                arquivo_base.set(arquivo)
        else:
            # Seleciona a base de dados mais recente para pior caso.
            arquivo = filedialog.askopenfilename(title="Selecione a base de dados mais recente")
            if arquivo:
                arquivo_base1.set(arquivo)

    def selecionar_dois():
        # Seleciona o segundo arquivo necessário.
        if not pior_caso:
            # Seleciona a planilha do JúpiterWeb.
            arquivo = filedialog.askopenfilename(title="Selecione a planilha dos dados do júpiter")
            if arquivo:
                arquivo_jptr.set(arquivo)
        else:
            # Seleciona a base de dados mais antiga para pior caso.
            arquivo = filedialog.askopenfilename(title="Selecione a base de dados mais antiga")
            if arquivo:
                arquivo_base2.set(arquivo)

    # Funções extras para seleção dos arquivos dos ingressantes e espelho, apenas se não for pior caso.
    if not pior_caso:
        def selecionar_tres():
            # Seleciona a planilha dos ingressantes.
            arquivo = filedialog.askopenfilename(title="Selecione a planilha dos dados dos ingressantes")
            if arquivo:
                arquivo_ing.set(arquivo)
        def selecionar_quatro():
            # Seleciona a planilha dos inscritos das disciplinas com espelho.
            arquivo = filedialog.askopenfilename(title="Selecione a planilha com os inscritos das disciplinas com espelho")
            if arquivo:
                arquivo_esp.set(arquivo)


    # Adiciona os widgets de seleção de arquivos na janela, conforme o tipo de base de dados.
    if not pior_caso:
        # Para base do modelo:
        # Label e botão para selecionar a planilha dos dados das aulas.
        lbl_base = tk.Label(frame, text="Selecione a planilha dos dados das aulas")
        lbl_base.grid(row=0, column=0, pady=5, sticky="w")
        btn_selecionar_base = tk.Button(frame, textvariable=arquivo_base, command=selecionar_um, wraplength=250, width=40)
        btn_selecionar_base.grid(row=0, column=1, padx=5, pady=5)

        # Label e botão para selecionar a planilha dos dados do JúpiterWeb.
        lbl_jptr = tk.Label(frame, text="Selecione a planilha dos dados do júpiter")
        lbl_jptr.grid(row=1, column=0, pady=5, sticky="w")
        btn_selecionar_jptr = tk.Button(frame, textvariable=arquivo_jptr, command=selecionar_dois, wraplength=250, width=40)
        btn_selecionar_jptr.grid(row=1, column=1, padx=5, pady=5)

        # Label e botão para selecionar a planilha dos dados dos ingressantes.
        lbl_ing = tk.Label(frame, text="Selecione a planilha dos dados dos ingressantes")
        lbl_ing.grid(row=2, column=0, pady=5, sticky="w")
        btn_selecionar_ing = tk.Button(frame, textvariable=arquivo_ing, command=selecionar_tres, wraplength=250, width=40)
        btn_selecionar_ing.grid(row=2, column=1, padx=5, pady=5)

        # Label e botão para selecionar a planilha dos inscritos das disciplinas com espelho.
        lbl_esp = tk.Label(frame, text="Selecione a planilha com os inscritos das disciplinas com espelho")
        lbl_esp.grid(row=3, column=0, pady=5, sticky="w")
        btn_selecionar_esp = tk.Button(frame, textvariable=arquivo_esp, command=selecionar_quatro, wraplength=250, width=40)
        btn_selecionar_esp.grid(row=3, column=1, padx=5, pady=5)
    else:
        # Para análise de pior caso:
        # Label e botão para selecionar a base de dados mais recente.
        lbl_base1 = tk.Label(frame, text="Selecione a base de dados mais recente")
        lbl_base1.grid(row=0, column=0, pady=5, sticky="w")
        btn_selecionar_base1 = tk.Button(frame, textvariable=arquivo_base1, command=selecionar_um, wraplength=250, width=40)
        btn_selecionar_base1.grid(row=0, column=1, padx=5, pady=5)

        # Label e botão para selecionar a base de dados mais antiga.
        lbl_base2 = tk.Label(frame, text="Selecione a base de dados mais antiga")
        lbl_base2.grid(row=1, column=0, pady=5, sticky="w")
        btn_selecionar_base2 = tk.Button(frame, textvariable=arquivo_base2, command=selecionar_dois, wraplength=250, width=40)
        btn_selecionar_base2.grid(row=1, column=1, padx=5, pady=5)

    # Campo para o usuário inserir o nome do arquivo final da base de dados.
    # Label explicativo e campo de entrada para o nome do arquivo.
    lbl_arq = tk.Label(frame, text="Insira o nome para a nova base de dados:")
    lbl_arq.grid(row=4, column=0, sticky="w", pady=5)
    campo_arq = tk.Entry(frame, textvariable=nome_arquivo)
    campo_arq.grid(row=4, column=1, pady=5)


    # Defino uma função que salva os valores das variáveis contendo o nome dos arquivos escolhidos.

    def salvar_valores():
        """
        Função responsável por validar os arquivos selecionados, executar a criação da base de dados e tratar erros.
        Realiza validação dos campos obrigatórios, executa o script de cruzamento ou análise de pior caso,
        e exibe mensagens de sucesso ou erro conforme o resultado.
        """
        # Validação dos campos obrigatórios conforme o tipo de base de dados.
        if not pior_caso:
            # Para base do modelo: verifica se todos os arquivos foram selecionados corretamente.
            # Se algum arquivo não foi selecionado, exibe aviso e interrompe o processo.
            if not arquivo_base.get() or arquivo_base.get() == "Selecione a planilha dos dados das aulas":
                messagebox.showwarning("Aviso", "Por favor, selecione a planilha dos dados das aulas.")
                return
            if not arquivo_jptr.get() or arquivo_jptr.get() == "Selecione a planilha dos dados do júpiter":
                messagebox.showwarning("Aviso", "Por favor, selecione a planilha dos dados do júpiter.")
                return
            if not arquivo_ing.get() or arquivo_ing.get() == "Selecione a planilha dos dados dos ingressantes":
                messagebox.showwarning("Aviso", "Por favor, selecione a planilha dos dados dos ingressantes.")
                return
            if not arquivo_esp.get() or arquivo_esp.get() == "Selecione a planilha com os inscritos das disciplinas com espelho":
                messagebox.showwarning("Aviso", "Por favor, selecione a planilha com os inscritos das disciplinas com espelho.")
                return
        else:
            # Para análise de pior caso: verifica se ambos os arquivos foram selecionados.
            if not arquivo_base1.get() or arquivo_base1.get() == "Selecione a base de dados mais recente":
                messagebox.showwarning("Aviso", "Por favor, selecione a primeira base de dados.")
                return
            if not arquivo_base2.get() or arquivo_base2.get() == "Selecione a base de dados mais antiga":
                messagebox.showwarning("Aviso", "Por favor, selecione a segunda base de dados.")
                return

        # Validação do nome do arquivo final.
        nome = nome_arquivo.get()
        if not nome:
            # Se o usuário não forneceu um nome, exibe aviso e interrompe.
            messagebox.showwarning("Aviso", "Por favor, insira o nome da nova base de dados.")
            return
        # Garante que o nome do arquivo termine com '.xlsx'.
        if not nome.endswith(".xlsx"):
            nome = nome + ".xlsx"

        if not pior_caso:
            # Executa o script para cruzar os dados das aulas com os do JúpiterWeb.
            try:
                file1 = arquivo_base.get()
                file2 = arquivo_jptr.get()
                file3 = arquivo_ing.get()
                file4 = arquivo_esp.get()
                # Chama o script externo para gerar a base de dados cruzada.
                subprocess.run(
                    [sys.executable, "jupiter sheet maker.py", file1, file2, file3, file4, nome],
                    check=True,
                    capture_output=True,
                    text=True
                )
                # Exibe mensagem de sucesso ao usuário.
                messagebox.showinfo("Sucesso!", f"Base de dados para o modelo criada com sucesso. Verifique o arquivo {nome}.")
            except subprocess.CalledProcessError as e:
                # Tratamento de erros específicos do subprocess.
                if e.returncode == 1:
                    msg = e.stderr.strip() if e.stderr else "Erro desconhecido."
                    messagebox.showerror("Erro", f"Erro ao executar o script. Verifique os arquivos de entrada.\n\n{msg}")
                elif e.returncode == 2:
                    msg = e.stderr.strip() if e.stderr else "Erro desconhecido."
                    messagebox.showerror("Erro", f"Erro de permissão. Verifique se o arquivo {nome} está aberto em outro programa.\n\n{msg}")
                elif e.returncode == 4:
                    msg = e.stderr.strip() if e.stderr else "Erro desconhecido."
                    messagebox.showerror("Erro", f"Erro ao executar o script:\n\n{msg}")
                else:
                    messagebox.showerror("Erro", f"Erro inesperado: {e}")
                return
            except Exception as e:
                # Tratamento de erros inesperados.
                messagebox.showerror("Erro", f"Erro inesperado: {e}")
                return
        else:
            # Realiza a análise de pior caso entre dois anos distintos.
            try:
                # Lê os dois dataframes fornecidos pelo usuário.
                df1 = pd.read_excel(arquivo_base1.get(), sheet_name=["Salas", "SME", "SMA", "SCC", "SSC", "Outros"])
                df2 = pd.read_excel(arquivo_base2.get(), sheet_name=["Salas", "SME", "SMA", "SCC", "SSC", "Outros"])
                # Chama a função que faz um dataframe com o maior número de inscritos de cada ano.
                df_pior_caso = base_pior_caso(df1, df2, ["Salas", "SME", "SMA", "SCC", "SSC", "Outros"])
                # Salva a base de pior caso em um arquivo Excel.
                with pd.ExcelWriter(os.path.join(saidas, nome), engine="openpyxl") as writer:
                    for sh, df_sh in df_pior_caso.items():
                        df_sh.to_excel(writer, sheet_name=sh, index=False)
                # Exibe mensagem de sucesso ao usuário.
                messagebox.showinfo("Sucesso!", f"Arquivo {nome} criado com sucesso!\nVerifique a pasta {saidas} para encontrá-lo.")
            except PermissionError as e:
                # Tratamento de erro de permissão (arquivo aberto ou bloqueado).
                if e.errno == 13:
                    messagebox.showerror(
                        "Erro de Permissão",
                        (
                            f"Não foi possível salvar o arquivo {nome_arquivo}. "
                            "Verifique se ele está aberto em outro programa (como o Excel) e tente novamente."
                        )
                    )
                    return
                else:
                    messagebox.showerror("Erro", f"Erro de permissão:\n\n{str(e)}")
                    return
            except Exception as e:
                # Tratamento de outros erros inesperados.
                messagebox.showerror("Erro inesperado!", f"Ocorreu um erro inesperado:\n\n{str(e)}")
                return
        # Após criar a base de dados, fecha a janela de seleção.
        nova_janela.destroy()

    # Botão para executar a função de salvar valores e criar a base de dados.
    btn_salvar = tk.Button(nova_janela, text="Criar base de dados", command=salvar_valores)
    btn_salvar.pack(pady=10)

"""### Pior caso"""


# Função que faz a análise de pior caso.
# Note que df1 deve sempre ser a base de dados mais recente, enquanto df2 deve sempre ser a base de dados mais antiga.
def base_pior_caso(df1, df2, sheets):
    """
    Realiza a análise de pior caso entre duas bases de dados de anos distintos.
    Para cada disciplina presente nas planilhas, compara o número de inscritos entre os anos e atualiza para o maior valor encontrado.
    Parâmetros:
    - df1: base de dados mais recente (dict de DataFrames por sheet)
    - df2: base de dados mais antiga (dict de DataFrames por sheet)
    - sheets: lista de nomes das planilhas a serem analisadas
    Retorno:
    - df1 atualizado com os maiores valores de inscritos e ano dos dados.
    """
    try:
        # Para cada planilha (sheet) na base de dados mais recente, exceto a primeira (geralmente 'Salas').
        for sh in sheets[1:]:
            # Obtém os DataFrames correspondentes à mesma planilha em ambos os anos.
            df1_sh = df1[sh]
            df2_sh = df2[sh]

            # Extrai as listas de disciplinas de cada base.
            l1 = df1_sh['Disciplina (código)'].tolist()
            l2 = df2_sh['Disciplina (código)'].tolist()

            # Para cada disciplina presente na base mais recente:
            for d in l1:
                # Se a disciplina também existe na base mais antiga:
                if d in l2:
                    # Compara o número de inscritos entre os anos.
                    inscritos_recente = df1[sh].loc[l1.index(d), 'Vagas por disciplina']
                    inscritos_antigo = df2[sh].loc[l2.index(d), 'Vagas por disciplina']
                    # Se o valor antigo for maior, atualiza na base mais recente.
                    if inscritos_recente < inscritos_antigo:
                        df1[sh].loc[l1.index(d), 'Vagas por disciplina'] = inscritos_antigo
                        df1[sh].loc[l1.index(d), 'Ano dos dados'] = df2[sh].loc[l2.index(d), 'Ano dos dados']
    except KeyError as e:
        # Caso falte alguma coluna esperada, exibe mensagem de erro ao usuário.
        coluna_faltando = str(e).strip("'")
        messagebox.showerror("Erro de Cabeçalho", 
            (f"A coluna '{coluna_faltando}' não foi encontrada em um dos arquivos. "
             "Verifique o cabeçalho dos arquivos de entrada.")
        )
        return
    except Exception as e:
        # Para qualquer outro erro inesperado, exibe mensagem ao usuário.
        messagebox.showerror("Erro inesperado", f"Ocorreu um erro inesperado:\n\n{e}")
        return
    # Retorna a base de dados atualizada após a análise de pior caso.
    return df1

"""## Executar"""


def execute():
    """
    Função responsável por abrir uma janela para seleção da base de dados, verificação dos dados e execução do modelo.
    Permite ao usuário:
    - Selecionar o arquivo da base de dados (completa ou de pior caso)
    - Executar o script de verificação de dados
    - Abrir o menu de configuração e execução do modelo
    """
    # Cria uma nova janela sobre a principal para as opções de execução.
    nova_janela = tk.Toplevel(root)
    nova_janela.geometry("+200+200")
    nova_janela.title("Verificar Dados e Executar Modelo")

    # Frame para organizar os botões e campos na nova janela.
    frame = tk.Frame(nova_janela)
    frame.pack(pady=10, padx=10)

    # Variável que armazena o caminho do arquivo selecionado pelo usuário.
    # Inicialmente, exibe texto padrão até que o usuário selecione um arquivo.
    arquivo_selecionado1 = tk.StringVar(value="Selecione uma base de dados")

    def selecionar_arquivo1():
        """
        Abre o diálogo para o usuário selecionar o arquivo da base de dados.
        Atualiza a variável arquivo_selecionado1 com o caminho do arquivo escolhido.
        """
        arquivo = filedialog.askopenfilename(title="Selecione uma base de dados")
        if arquivo:
            arquivo_selecionado1.set(arquivo)

    # Botão para o usuário escolher a base de dados.
    # O texto do botão é atualizado conforme o arquivo selecionado.
    btn_selecionar1 = tk.Button(
        frame,
        textvariable=arquivo_selecionado1,
        command=selecionar_arquivo1,
        wraplength=250,
        width=40
    )
    btn_selecionar1.grid(row=0, column=0, padx=5, pady=5)

    # Linha de separação horizontal entre seleção de arquivo e verificação de dados.
    vd_separator = ttk.Separator(frame, orient="horizontal")
    vd_separator.grid(row=2, column=0, sticky="ew", pady=(0, 10))

    # Botão para abrir o menu de verificação de dados.
    # Chama o script 'verificar_dados.py' usando o arquivo selecionado.
    vd1 = ttk.Button(
        frame,
        text="Selecionar Verificação de Dados",
        command=lambda: roda_script(
            "verificar_dados.py",
            arquivo_selecionado1.get(),
            "", "", "", "", "", ""
        )
    )
    vd1.grid(row=4, column=0, pady=5)

    # Linha de separação horizontal entre verificação de dados e execução do modelo.
    em_separator = ttk.Separator(frame, orient="horizontal")
    em_separator.grid(row=5, column=0, sticky="ew", pady=(0, 10))

    # Botão para abrir o menu de configuração e execução do modelo.
    # Chama a função Novo_edit_config passando o arquivo selecionado.
    em = ttk.Button(
        frame,
        text="Selecionar Modelo",
        command=lambda: Novo_edit_config(file_name=arquivo_selecionado1.get())
    )
    em.grid(row=6, column=0, pady=5)

"""### Roda Script"""


def roda_script(script, nome, peso_x, peso_y, peso_v, peso_z, alpha, pref):
    """
    Executa um script Python externo com parâmetros fornecidos pelo usuário e exibe a saída em uma janela dedicada.
    Parâmetros:
    - script: nome do script Python a ser executado
    - nome: caminho do arquivo da base de dados
    - peso_x, peso_y, peso_v, peso_z, alpha, pref: parâmetros do modelo a serem passados ao script
    Abre uma janela para mostrar a saída do script (prints, erros, etc) em tempo real.
    Em caso de erro, exibe mensagens apropriadas ao usuário.
    """
    # Cria uma nova janela para exibir a saída do script.
    output_window = tk.Toplevel(root)
    output_window.title("Saída do Script")
    output_text = scrolledtext.ScrolledText(output_window, width=120, height=40)
    output_text.pack()

    try:
        # Executa o script externo usando subprocess, passando todos os parâmetros necessários.
        process = subprocess.Popen(
            [sys.executable, script, nome, peso_x, peso_y, peso_v, peso_z, alpha, pref],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True
        )

        # Lê e exibe a saída do script linha por linha, atualizando a interface em tempo real.
        for line in iter(process.stdout.readline, ""):
            if line.strip():
                output_text.insert(tk.END, line)  # Adiciona a linha ao final da janela de saída
                output_text.see(tk.END)           # Rola automaticamente até o final
                root.update()                     # Atualiza a interface para mostrar a linha mais recente

        # Captura possíveis erros enviados para stderr após o término da execução.
        stderr = process.communicate()[1]
        if stderr:
            # Se houve erro, exibe no final da janela de saída.
            output_text.insert(tk.END, "\n[ERRO]:\n" + stderr)
            output_text.see(tk.END)

    except subprocess.CalledProcessError as e:
        # Tratamento de erros específicos do subprocess.
        if e.returncode == 1:
            messagebox.showerror("Erro", f"Erro ao executar o script. Verifique os arquivos de entrada.\n\nErro: {e}")
        elif e.returncode == 2:
            messagebox.showerror("Erro", f"Erro de permissão. Verifique se o arquivo {nome} está aberto em outro programa.\n\nErro: {e}")
        else:
            messagebox.showerror("Erro", f"Erro inesperado: {e}")
        return
    except Exception as e:
        # Tratamento de erros inesperados.
        messagebox.showerror("Erro", f"Erro inesperado: {e}")
        return

"""### Novo Edit Configs"""


def Novo_edit_config(file_name):
    """
    Abre uma janela para o usuário configurar os parâmetros do modelo ou da verificação antes de executar o script.
    Permite escolher entre valores recomendados ou personalizados para cada parâmetro do modelo.
    Parâmetros:
    - file_name: nome da base de dados selecionada pelo usuário.
    Se nenhum arquivo for selecionado, exibe um aviso e interrompe o processo.
    """
    # Verifica se foi fornecida uma base de dados válida.
    if file_name == "Selecione uma base de dados":
        messagebox.showwarning("Aviso", "Por favor, selecione uma base de dados.")
        return

    # Cria uma nova janela para configuração dos parâmetros.
    configs = tk.Toplevel(root)
    configs.geometry("+360+150")
    configs.title("Personalizar parâmetros")

    # Frame para organizar os botões e campos na janela de configuração.
    frame2 = tk.Frame(configs)
    frame2.pack(pady=10, padx=10)

    # Variáveis de controle para os checkboxes de cada parâmetro (recomendado/personalizado).
    var11 = IntVar()  # Peso de alocação recomendado
    var12 = IntVar()  # Peso de alocação personalizado
    var21 = IntVar()  # Peso de troca de sala recomendado
    var22 = IntVar()  # Peso de troca de sala personalizado
    var31 = IntVar()  # Peso de agrupamento recomendado
    var32 = IntVar()  # Peso de agrupamento personalizado
    var41 = IntVar()  # Peso de superlotação recomendado
    var42 = IntVar()  # Peso de superlotação personalizado
    var51 = IntVar()  # Índice de superlotação recomendado
    var52 = IntVar()  # Índice de superlotação personalizado
    var61 = IntVar()  # Peso de salas preferencialmente vazias recomendado
    var62 = IntVar()  # Peso de salas preferencialmente vazias personalizado

    def atualizar_estado():
        """
        Atualiza o estado dos checkboxes e campos de entrada conforme as escolhas do usuário.
        Desabilita o campo personalizado quando o recomendado está marcado e vice-versa.
        Garante que apenas uma opção por parâmetro esteja ativa e que o campo personalizado só seja habilitado se selecionado.
        """
        # Peso de alocação
        if var11.get():
            checkbox12.config(state=DISABLED)
        else:
            checkbox12.config(state=NORMAL)
        if var12.get():
            checkbox11.config(state=DISABLED)
            peso_x.config(state=NORMAL)
        else:
            checkbox11.config(state=NORMAL)
            peso_x.delete(0, "end")
            peso_x.config(state=DISABLED)

        # Peso de troca de sala
        if var21.get():
            checkbox22.config(state=DISABLED)
        else:
            checkbox22.config(state=NORMAL)
        if var22.get():
            checkbox21.config(state=DISABLED)
            peso_y.config(state=NORMAL)
        else:
            checkbox21.config(state=NORMAL)
            peso_y.delete(0, "end")
            peso_y.config(state=DISABLED)

        # Peso de agrupamento
        if var31.get():
            checkbox32.config(state=DISABLED)
        else:
            checkbox32.config(state=NORMAL)
        if var32.get():
            checkbox31.config(state=DISABLED)
            peso_v.config(state=NORMAL)
        else:
            checkbox31.config(state=NORMAL)
            peso_v.delete(0, "end")
            peso_v.config(state=DISABLED)

        # Peso de superlotação
        if var41.get():
            checkbox42.config(state=DISABLED)
        else:
            checkbox42.config(state=NORMAL)
        if var42.get():
            checkbox41.config(state=DISABLED)
            peso_z.config(state=NORMAL)
        else:
            checkbox41.config(state=NORMAL)
            peso_z.delete(0, "end")
            peso_z.config(state=DISABLED)

        # Índice de superlotação
        if var51.get():
            checkbox52.config(state=DISABLED)
        else:
            checkbox52.config(state=NORMAL)
        if var52.get():
            checkbox51.config(state=DISABLED)
            alpha.config(state=NORMAL)
        else:
            checkbox51.config(state=NORMAL)
            alpha.delete(0, "end")
            alpha.config(state=DISABLED)

        # Peso de salas preferencialmente vazias
        if var61.get():
            checkbox62.config(state=DISABLED)
        else:
            checkbox62.config(state=NORMAL)
        if var62.get():
            checkbox61.config(state=DISABLED)
            pref.config(state=NORMAL)
        else:
            checkbox61.config(state=NORMAL)
            pref.delete(0, "end")
            pref.config(state=DISABLED)

    
    # Defino uma linha puramente estética no topo da janela.
    # Em seguida, defino uma legenda e um botão ao lado, ambos desabilitados, apenas para servir como
    # instruções e mostrar as configurações recomendadas dos parâmetros.
    ttk.Separator(frame2, orient="horizontal").grid(row=0, column=0, columnspan=3, sticky="ew", pady=(0, 10))
    lbl = tk.Label(frame2, text="Selecione e/ou digite os valores que deseja para os parâmetros.", state=DISABLED)
    lbl.grid(row=1,column=0,sticky='w')
    btnl = ttk.Button(frame2, text="Recomendações - Configurações Recomendadas", state=DISABLED)
    btnl.grid(row=1,column=1,sticky='e')
    Tooltip(btnl, "Recomendado:\n\
    Peso de alocação: 1\n\
    Peso de troca de sala: 500\n\
    Peso de agrupamento: 1\n\
    Peso de superlotação: 10\n\
    Índice de superlotação: 0.85\n\
    Peso de salas preferencialmente vazias: 1\n\
    Quantidade de alunos da pós: 20")

    # Semelhantemente, os próximos 'blocos de código' seguem a mesma lógica.
    # Crio uma linha para separar o espaço de cada parâmetro.
    # Incluo uma legenda com uma Tooltip para explicar o propósito do parâmetro.
    # Crio uma checkbox para marcar a configuração padrão daquele parâmetro sempre primeiro.
    # Crio, após ele, um checkbox para marcar a configuração personalizada com um campo desabilitado ao lado dele.
    # Ele precisa estar desabilitado inicialmente, ou é possível inserir um valor mesmo sem marcar um checkbox.
    ttk.Separator(frame2, orient="horizontal").grid(row=2, column=0, columnspan=3, sticky="ew", pady=(0, 10))
    lblx = tk.Label(frame2, text="Defina um peso de alocação:")
    lblx.grid(row=3, column=0, sticky='w', pady=5)
    checkbox11 = Checkbutton(frame2, text="Recomendado: 1", variable=var11, command=atualizar_estado)
    checkbox11.grid(row=3, column=1, sticky='w', pady=5)
    checkbox12 = Checkbutton(frame2, text="Personalizado: ", variable=var12, command=atualizar_estado)
    checkbox12.grid(row=3, column=2, sticky='w', pady=5)
    peso_x = Entry(frame2, state=DISABLED)
    peso_x.grid(row=4, column=2, sticky='e', pady=5)
    Tooltip(lblx, "O peso de alocação refere-se ao peso da variável x_as no modelo. \n\
    Quanto mais alto, mais importante será essa variável,\n\
    logo, o modelo pode deixar de alocar de forma ótima se o peso for baixo.\n\
    Por exemplo, ele pode entender que é mais importante agrupar \n\
    os cursos, do que usar o maior espaço possível.")

    ttk.Separator(frame2, orient="horizontal").grid(row=5, column=0, columnspan=3, sticky="ew", pady=(0, 10))
    lbly = tk.Label(frame2, text="Defina um peso de troca de sala:")
    lbly.grid(row=6,column=0,sticky='w',pady=5)
    checkbox21 = Checkbutton(frame2, text="Recomendado: 500", variable=var21, command=atualizar_estado)
    checkbox21.grid(row=6, column=1, sticky='w', pady=5)
    checkbox22 = Checkbutton(frame2, text="Personalizado: ", variable=var22, command=atualizar_estado)
    checkbox22.grid(row=6, column=2, sticky='w', pady=5)
    peso_y = Entry(frame2, state=DISABLED)
    peso_y.grid(row=7,column=2,sticky='e',pady=5)
    Tooltip(lbly, "O peso de troca de sala refere-se ao peso da variável y_t no modelo. \n\
    Quanto mais alto, mais importante será essa variável,\n\
    logo, o modelo pode deixar de manter aulas de uma \n\
    turma/disciplina alocadas na mesma sala se o peso for baixo.\n\
    Por exemplo, ele pode entender que é mais importante preencher \n\
    uma sala o máximo possível sem verificar quais são elas.")


    ttk.Separator(frame2, orient="horizontal").grid(row=8, column=0, columnspan=3, sticky="ew", pady=(0, 10))
    lblv = tk.Label(frame2, text="Defina um peso de agrupamento:")
    lblv.grid(row=9,column=0,sticky='w',pady=5)
    checkbox31 = Checkbutton(frame2, text="Recomendado: 1", variable=var31, command=atualizar_estado)
    checkbox31.grid(row=9, column=1, sticky='w', pady=5)
    checkbox32 = Checkbutton(frame2, text="Personalizado: ", variable=var32, command=atualizar_estado)
    checkbox32.grid(row=9, column=2, sticky='w', pady=5)
    peso_v = Entry(frame2, state=DISABLED)
    peso_v.grid(row=10,column=2,sticky='e',pady=5)
    Tooltip(lblv, "O peso de agrupamento refere-se ao peso da variável v_cssl no modelo. \n\
    Quanto mais alto, mais importante será essa variável,\n\
    logo, o modelo pode deixar de tentar agrupar as aulas de \n\
    um curso próximas umas das outras se o peso for baixo.\n\
    Por exemplo, ele pode entender que é mais importante \n\
    acomodar os alunos numa sala, do que agrupar os cursos.")

    ttk.Separator(frame2, orient="horizontal").grid(row=11, column=0, columnspan=3, sticky="ew", pady=(0, 10))
    lblz = tk.Label(frame2, text="Defina um peso de superlotação:")
    lblz.grid(row=12,column=0,sticky='w',pady=5)
    checkbox41 = Checkbutton(frame2, text="Recomendado: 10", variable=var41, command=atualizar_estado)
    checkbox41.grid(row=12, column=1, sticky='w', pady=5)
    checkbox42 = Checkbutton(frame2, text="Personalizado: ", variable=var42, command=atualizar_estado)
    checkbox42.grid(row=12, column=2, sticky='w', pady=5)
    peso_z = Entry(frame2, state=DISABLED)
    peso_z.grid(row=13,column=2,sticky='e',pady=5)
    Tooltip(lblz, "O peso de superlotação refere-se ao peso da variável z_as no modelo. \n\
    Quanto mais alto, mais importante será essa variável,\n\
    logo, o modelo pode deixar de tentar acomodar melhor os \n\
    alunos em uma sala se o peso for baixo.\n\
    Por exemplo, ele pode entender que é mais importante \n\
    preencher uma sala o máximo possível, do que deixar alguns lugares desocupados \n\
    para acomodar melhor os alunos, ou para receber alunos vindos do requerimento.")

    ttk.Separator(frame2, orient="horizontal").grid(row=14, column=0, columnspan=3, sticky="ew", pady=(0, 10))
    lbla = tk.Label(frame2, text="Defina um índice de superlotação (valor entre 0 e 1, utilizando '.'):")
    lbla.grid(row=15,column=0,sticky='w',pady=5)
    checkbox51 = Checkbutton(frame2, text="Recomendado: 0.85", variable=var51, command=atualizar_estado)
    checkbox51.grid(row=15, column=1, sticky='w', pady=5)
    checkbox52 = Checkbutton(frame2, text="Personalizado: ", variable=var52, command=atualizar_estado)
    checkbox52.grid(row=15, column=2, sticky='w', pady=5)
    alpha = Entry(frame2, state=DISABLED)
    alpha.grid(row=16,column=2,sticky='e',pady=5)
    Tooltip(lbla, "O índice de superlotação refere-se à porcentagem usada pela variável z_as no modelo. \n\
    Em outras palavras, é o quanto uma aula preenche uma sala \n\
    para que o modelo tente colocar essa aula em uma sala maior, \n\
    garantindo uma melhor acomodação para os alunos e espaço para \n\
    alunos vindos do requerimento. Quanto mais alto, mais o modelo \n\
    prioriza preencher o máximo possível de uma sala. Um valor baixo \n\
    faz com que as salas maiores sejam preenchidas com mais facilidade, \n\
    e um valor alto fará o mesmo, mas para as salas menores.")

    ttk.Separator(frame2, orient="horizontal").grid(row=17, column=0, columnspan=3, sticky="ew", pady=(0, 10))
    lbl_pref = tk.Label(frame2, text="Defina um peso de salas preferencialmente vazias:")
    lbl_pref.grid(row=18,column=0,sticky='w',pady=5)
    checkbox61 = Checkbutton(frame2, text="Recomendado: 500", variable=var61, command=atualizar_estado)
    checkbox61.grid(row=18, column=1, sticky='w', pady=5)
    checkbox62 = Checkbutton(frame2, text="Personalizado: ", variable=var62, command=atualizar_estado)
    checkbox62.grid(row=18, column=2, sticky='w', pady=5)
    pref = Entry(frame2, state=DISABLED)
    pref.grid(row=19,column=2,sticky='e',pady=5)
    Tooltip(lbl_pref, "O peso de salas preferencialmente vazias refere-se à importância de determinadas salas ficarem desocupadas no modelo. \n\
    Quanto mais alto, maior a chance de essas salas não serem utilizadas,\n\
    logo, o modelo pode tentar alocar aulas em salas indesejadas \n\
    se o peso for baixo.\n\
    Por exemplo, ele pode entender que é mais importante \n\
    preencher uma sala que poderia ser usada para alguma outra função, por ela ser mais fácil de ser preenchida, \n\
    do que mantê-la desocupada para a pós.")


    def executar_configs_perso():
        """
        Função responsável por validar as configurações personalizadas dos parâmetros do modelo antes de executar o script.
        Para cada parâmetro, verifica se ao menos uma opção (recomendado ou personalizado) foi selecionada e se, no caso de personalizado,
        um valor foi fornecido. Exibe mensagens de aviso caso algum campo obrigatório esteja faltando.
        Se todas as validações forem aprovadas, executa o script com os valores definidos pelo usuário.
        """
        # Validação do peso de alocação: obrigatório selecionar uma opção.
        if not var11.get() and not var12.get():
            messagebox.showwarning("Aviso", "Por favor, defina um peso de alocação.")
            return
        elif var11.get():
            aux_x = '1'  # Valor recomendado
        else:
            aux_x = peso_x.get()  # Valor personalizado

        # Validação do peso de troca de sala: obrigatório selecionar uma opção.
        if not var21.get() and not var22.get():
            messagebox.showwarning("Aviso", "Por favor, defina um peso de troca de sala.")
            return
        elif var21.get():
            aux_y = '500'  # Valor recomendado
        else:
            aux_y = peso_y.get()  # Valor personalizado

        # Para cada parâmetro, se personalizado estiver marcado mas o campo estiver vazio, exibe aviso.
        if var12.get() and not peso_x.get():
            messagebox.showwarning("Aviso", "Por favor, digite um peso de alocação.")
            return
        elif var11.get():
            aux_x = '1'
        else:
            aux_x = peso_x.get()

        if var22.get() and not peso_y.get():
            messagebox.showwarning("Aviso", "Por favor, digite um peso de troca de sala.")
            return
        elif var21.get():
            aux_y = '500'
        else:
            aux_y = peso_y.get()

        if var32.get() and not peso_v.get():
            messagebox.showwarning("Aviso", "Por favor, digite um peso de agrupamento.")
            return
        elif var31.get():
            aux_v = '1'
        else:
            aux_v = peso_v.get()

        if var42.get() and not peso_z.get():
            messagebox.showwarning("Aviso", "Por favor, digite um peso de superlotação.")
            return
        elif var41.get():
            aux_z = '10'
        else:
            aux_z = peso_z.get()

        if var52.get() and not alpha.get():
            messagebox.showwarning("Aviso", "Por favor, digite um índice de superlotação.")
            return
        elif var51.get():
            aux_a = '0.85'
        else:
            aux_a = alpha.get()

        if var62.get() and not pref.get():
            messagebox.showwarning("Aviso", "Por favor, digite um peso de salas preferencialmente vazias.")
            return
        elif var61.get():
            aux_p = '500'
        else:
            aux_p = pref.get()

        # Se todas as validações passaram, executa o script com os parâmetros definidos.
        roda_script(
            script="Modelo Universal-Copy1.py",
            nome=file_name,
            peso_x=aux_x,
            peso_y=aux_y,
            peso_v=aux_v,
            peso_z=aux_z,
            alpha=aux_a,
            pref=aux_p
        )

    # Linha horizontal para separar os parâmetros dos botões de execução.
    ttk.Separator(frame2, orient="horizontal").grid(row=23, column=0, columnspan=2, sticky="w", pady=(0, 10))

    # Botão para executar o modelo com os parâmetros recomendados.
    # Chama diretamente roda_script com os valores padrão para cada parâmetro.
    ttk.Button(
        frame2,
        text="Executar com Recomendados",
        command=lambda: roda_script(
            script="Modelo Universal-Copy1.py",
            nome=file_name,
            peso_x='1',
            peso_y='500',
            peso_v="",
            peso_z='10',
            alpha='0.85',
            pref='500'
        )
    ).grid(row=24, column=0, sticky='w', pady=5)

    # Botão para executar o modelo com os parâmetros personalizados.
    # Chama executar_configs_perso, que valida os campos e executa o script com os valores definidos pelo usuário.
    ttk.Button(
        frame2,
        text="Executar com Personalizados",
        command=executar_configs_perso
    ).grid(row=24, column=2, sticky='w', pady=5)


"""## Análise de Espaços Livres (colocar nos arquivos de modelo)"""


# Função que cria uma janela para seleção dos arquivos necessários para gerar a análise dos espaços livres após a alocação do modelo.
def analise_vazios():
    """
    Abre uma janela para o usuário selecionar os arquivos de solução do modelo e dos dados das salas,
    além de definir os nomes dos arquivos de saída para a visualização dos espaços livres.
    Realiza validação dos campos obrigatórios e chama a função de análise após a confirmação dos dados.
    """
    # Cria uma nova janela sobre a principal para a interface de análise de espaços livres.
    nova_janela = tk.Toplevel(root)
    nova_janela.title("Análise de Espaços Livres")

    # Frame para organizar os botões e campos na nova janela.
    frame = tk.Frame(nova_janela)
    frame.pack(pady=10, padx=10)

    # Variáveis para armazenar os caminhos dos arquivos selecionados e nomes dos arquivos de saída.
    visu = tk.StringVar(value="Selecione a planilha de Visualização Completa da Solução do modelo")  # Solução do modelo
    salas = tk.StringVar(value="Selecione a planilha dos dados das salas")  # Dados das salas
    caminho_arquivo = tk.StringVar()  # Nome do arquivo de visualização
    caminho_arquivo1 = tk.StringVar()  # Nome do arquivo de planilha de espaços livres

    def selecionar_arquivo1():
        """
        Abre o diálogo para o usuário selecionar o arquivo de solução do modelo.
        Atualiza a variável visu com o caminho do arquivo escolhido.
        """
        arquivo = filedialog.askopenfilename(title="Selecione a planilha de Visualização Completa da Solução do modelo")
        if arquivo:
            visu.set(arquivo)

    def selecionar_arquivo2():
        """
        Abre o diálogo para o usuário selecionar o arquivo de dados das salas.
        Atualiza a variável salas com o caminho do arquivo escolhido.
        """
        arquivo = filedialog.askopenfilename(title="Selecione a planilha dos dados das salas")
        if arquivo:
            salas.set(arquivo)

    def salvar_valores():
        """
        Valida os campos obrigatórios e chama a função de análise dos espaços livres.
        Exibe avisos caso algum campo não tenha sido preenchido corretamente.
        """
        # Validação dos campos obrigatórios.
        if not visu.get() or visu.get() == "Selecione a planilha de Visualização Completa da Solução do modelo":
            messagebox.showwarning("Aviso", "Por favor, selecione a planilha de Visualização Completa da Solução do modelo.")
            return
        if not salas.get() or salas.get() == "Selecione a planilha dos dados das salas":
            messagebox.showwarning("Aviso", "Por favor, selecione a planilha dos dados das salas.")
            return
        if not caminho_arquivo.get():
            messagebox.showwarning("Aviso", "Por favor, dê um nome para o arquivo de Visualização de Espaços Livres.")
            return
        if not caminho_arquivo1.get():
            messagebox.showwarning("Aviso", "Por favor, dê um nome para o arquivo de Planilha de Espaços Livres.")
            return

        # Se todos os campos estão preenchidos, chama a função de análise e fecha a janela.
        criar_visualizacao_de_vazias(
            visu.get(),
            salas.get(),
            caminho_arquivo.get(),
            caminho_arquivo1.get()
        )
        nova_janela.destroy()

    # Label e botão para selecionar o arquivo de solução do modelo.
    lbl_visu = tk.Label(frame, text="Selecione a de Dados da Solução do modelo")
    lbl_visu.grid(row=0, column=0, pady=5, sticky="w")
    btn_selecionar_visu = tk.Button(frame, textvariable=visu, command=selecionar_arquivo1, wraplength=250, width=40)
    btn_selecionar_visu.grid(row=0, column=1, padx=5, pady=5)

    # Label e botão para selecionar o arquivo de dados das salas.
    lbl_salas = tk.Label(frame, text="Selecione a planilha dos dados das salas")
    lbl_salas.grid(row=1, column=0, pady=5, sticky="w")
    btn_selecionar_salas = tk.Button(frame, textvariable=salas, command=selecionar_arquivo2, wraplength=250, width=40)
    btn_selecionar_salas.grid(row=1, column=1, padx=5, pady=5)

    # Label e campo para inserir o nome do arquivo de visualização de espaços livres.
    lbl_cam = tk.Label(frame, text="Digite um nome para a Visualização de Espaços Livres:")
    lbl_cam.grid(row=2, column=0, pady=5, sticky="w")
    campo_cam = tk.Entry(frame, textvariable=caminho_arquivo)
    campo_cam.grid(row=2, column=1, pady=5)

    # Label e campo para inserir o nome do arquivo de planilha de espaços livres.
    lbl_cam1 = tk.Label(frame, text="Digite um nome para a Planilha de Espaços Livres:")
    lbl_cam1.grid(row=3, column=0, pady=5, sticky="w")
    campo_cam1 = tk.Entry(frame, textvariable=caminho_arquivo1)
    campo_cam1.grid(row=3, column=1, pady=5)

    # Botão para gerar a análise de espaços livres, chamando a função de validação e análise.
    ttk.Button(frame, text="Gerar Análise de Espaços Livres", command=salvar_valores).grid(row=4, column=0, sticky='ew')

"""### Criar Visualização em cima de Visualização"""


# Função que faz a análise dos espaços livres restantes após a alocação feita pelo modelo.
def criar_visualizacao_de_vazias(file_path, file_path_salas, caminho_arquivo, caminho_arquivo1):
    """
    Analisa a planilha de solução do modelo e os dados das salas para identificar os horários e salas que permaneceram livres após a alocação.
    Gera dois arquivos: uma visualização dos espaços livres e uma planilha detalhada dos horários vagos por sala e dia.
    Parâmetros:
    - file_path: caminho da planilha de solução do modelo
    - file_path_salas: caminho da planilha de dados das salas
    - caminho_arquivo: nome do arquivo de visualização a ser gerado
    - caminho_arquivo1: nome do arquivo de planilha de espaços livres a ser gerado
    """
    # Carrega a planilha de solução do modelo.
    wb = load_workbook(file_path)
    ws = wb.active

    # Define o intervalo de horários para análise (de 07:00 até 23:30, de 30 em 30 minutos).
    start_time = datetime.strptime("07:00", "%H:%M")
    end_time = datetime.strptime("23:30", "%H:%M")
    horarios = []
    current_time = start_time
    while current_time <= end_time:
        horarios.append(current_time.strftime("%H:%M"))
        current_time += timedelta(minutes=30)
    sala_colunas = len(horarios)  # Número de colunas de horários

    # Lista de dias da semana presentes na visualização.
    dias_semana = ["Segunda", "Terça", "Quarta", "Quinta", "Sexta", "Sábado"]

    # Define as coordenadas iniciais para análise das tabelas de cada sala.
    start_row = 1  # Primeira linha da tabela
    start_column = 2  # Primeira coluna da tabela
    end_row = 1 # Última linha da tabela
    end_column = 1 + sala_colunas # Última coluna da tabela
    start = start_row + 2  # Linha para os dias da semana
    space_between = 3  # Espaço entre tabelas de salas

    # Preenchimento amarelo para identificar espaços livres.
    yellow_fill = PatternFill(start_color="00E3DE00", end_color="00E3DE00", fill_type="solid")

    # Calcula o número de salas utilizadas na solução do modelo.
    n_salas = int((ws.max_row+1) / (2 + len(dias_semana) + space_between))

    # Carrega os dados das salas.
    salas = pd.read_excel(file_path_salas)

    # Lista para armazenar as salas utilizadas na alocação.
    salas1 = []

    # DataFrame para registrar os horários vagos por sala e dia.
    df_vazio = pd.DataFrame(columns=["Sala", "Dia da semana", "Horário vago"])

    def get_cell_color(cell):
        """
        Retorna o código da cor de preenchimento da célula, ignorando células amarelas (espaços livres).
        """
        fill = cell.fill
        if fill and fill.start_color.index != "00E3DE00":  # Ignora células amarelas
            return fill.start_color.index
        return None  # Sem cor definida

    # Para cada sala utilizada pelo modelo, analisa os horários livres e registra os intervalos disponíveis.
    for i in range(n_salas+1):
        # Obtém o nome da sala atual na tabela da planilha.
        sala = ws.cell(row=start_row, column=start_column).value
        salas1.append(sala)  # Adiciona à lista de salas usadas

        # Para cada linha referente aos dias da semana na tabela da sala:
        for row in ws.iter_rows(min_row=start, max_row=start+5):
            # Inicializa a coluna de início do intervalo livre como None.
            start_col = None

            # Percorre cada célula da linha (cada horário):
            for col_idx, cell in enumerate(row, start=1):
                cell_color = get_cell_color(cell)  # Identifica a cor da célula

                # Se a célula for branca (horário livre):
                if cell_color == "00000000":
                    # Se não for célula mesclada e não for coluna de dia da semana:
                    if type(cell) != openpyxl.cell.cell.MergedCell:
                        # Se não for, verifico se a coluna inicial está como vazia,
                        # e se a célula atual não faz parte da coluna de dias da semana:
                        if start_col is None and cell.value not in dias_semana:
                            # Se for o caso, salvo a coluna inicial na variável.
                            # O workbook sempre considera a primeira coluna como 1, e como o primeiro "elemento" da lista de horários está na
                            # coluna 2, então para traduzir corretamente a coluna da célula vazia, preciso tirar 2 para o índice ficar compatível
                            start_col = cell.column - 2

                # Se a cor da célula atual não for branca:
                else:
                    # Se a célula não for mesclada, trata como início de intervalo ocupado:
                    if type(cell) != openpyxl.cell.cell.MergedCell:
                        # Se ela não for, quer dizer que estou analisando a primeira célula de um intervalo ocupado, isto é,
                        # estou analisando a célula do topo esquerdo da mesclagem, que é a única que pode ter seu valor alterado.
                        # Assim, limpo o que estiver dentro da célula.
                        cell.value = ""

                        # E mudo a cor de seu preenchimento para o amarelo definido anteriormente.
                        cell.fill = yellow_fill

                    # Agora, verifico se a coluna inicial é diferente de vazio, ou seja, se ela já foi definida;
                    # e verifico se a distância entre a coluna atual e a coluna inicial é maior ou igual que 1,
                    # certificando que não estou olhando para a mesma coluna:
                    if start_col is not None and col_idx - start_col >= 1:
                        # Se isso for verdade, adiciono uma linha no dataframe contendo os horários disponíveis até então.
                        # Na ordem, esta a sala que estou analisando, o dia da semana com o horário disponível, e
                        # o intervalo de tempo livre do dia em questão.
                        # Como estou analisando linha por linha, a coluna do segundo valor sempre é 1, pois refere-se
                        # à coluna de dias da semana; e eu preciso subtrair o valor 2 de col_idx para ignorar a primeira coluna
                        # da tabela (-1), e para igualar com o índice usual (já que col_idx sempre começa com o valor 1).
                        df_vazio.loc[len(df_vazio)] = [
                            f"{sala}",
                            f"{ws.cell(row=cell.row, column=1).value}",
                            f"{horarios[start_col]} - {horarios[col_idx-2]}"
                        ]

                    # Após estes processos, defino novamente a coluna de início como vazia para definir um novo intervalo.
                    start_col = None

            # Ao final da linha, garante que o último intervalo livre seja registrado:
            if start_col is not None and start_col < len(row):
                df_vazio.loc[len(df_vazio)] = [
                    f"{sala}",
                    f"{ws.cell(row=cell.row, column=1).value}",
                    f"{horarios[start_col]} - {horarios[col_idx-2]}"
                ]

        # Atualiza as coordenadas para a próxima sala na planilha.
        start_row = start_row + 2 + len(dias_semana) + space_between
        end_row = start_row
        start = start_row + 2


    # Após analisar os espaços livres das salas utilizadas, verifica-se quais salas ficaram totalmente de fora da alocação.
    # Para isso, percorre cada sala presente na planilha de salas original:
    for sala in salas['Sala'].tolist():
        # Se a sala não está na lista de salas utilizadas na alocação:
        if sala not in salas1:
            # Tratamento especial para laboratórios do bloco 6:
            # Se a sala avulsa (ex: '6-303') não foi usada, mas a sala conjunta ('6-303/6-304') foi utilizada,
            # ignora a sala avulsa para evitar duplicidade na análise de espaços livres.
            if sala == '6-303' and '6-303/6-304' in salas1:
                continue
            elif sala == '6-304' and '6-303/6-304' in salas1:
                continue
            elif sala == '6-305' and '6-305/6-306' in salas1:
                continue
            elif sala == '6-306' and '6-305/6-306' in salas1:
                continue
            else:
                # Caso a sala realmente não tenha sido utilizada, registra todos os horários como livres para todos os dias da semana.
                # Isso garante que salas não alocadas apareçam como totalmente disponíveis na planilha de espaços livres.
                weekdays = ['Segunda', 'Terça', 'Quarta', 'Quinta', 'Sexta', 'Sábado']
                
                for i in range(len(weekdays)):
                    last_line = df_vazio.shape[0] + 1
                    df_vazio.loc[last_line, 'Sala'] = f"{sala}"
                    df_vazio.loc[last_line, 'Dia da semana'] = weekdays[i]
                    df_vazio.loc[last_line, 'Horário vago'] = "07:00 - 23:30"

    # Garanto que o nome do arquivo de visualização termine com '.xlsx'.
    if not caminho_arquivo.endswith(".xlsx"):
        caminho_arquivo = caminho_arquivo + ".xlsx"

    # Garanto que o nome da nova base de dados termina com '.xlsx':
    if not caminho_arquivo1.endswith(".xlsx"):
        caminho_arquivo1 = caminho_arquivo1 + ".xlsx"

    try:
        # Tenta salvar o arquivo de visualização dos espaços livres (workbook modificado).
        wb.save(os.path.join(saidas, caminho_arquivo))
    
    except PermissionError as e:
        # Se ocorrer erro de permissão (arquivo aberto ou bloqueado), exibe mensagem específica ao usuário.
        if e.errno == 13:
            messagebox.showerror("Erro de Permissão", 
                                    (
                                        f"Não foi possível salvar o arquivo {os.path.basename(caminho_arquivo)}. "
                                        "Verifique se ele está aberto em outro programa (como o Excel) e tente novamente."
                                    )
                                )
            return
        else:
            # Para outros erros de permissão, exibe mensagem genérica.
            messagebox.showerror("Erro", f"Erro de permissão:\n\n{str(e)}")
            return
    except Exception as e:
        # Para qualquer outro erro inesperado, exibe mensagem genérica.
        messagebox.showerror("Erro inesperado!", f"Ocorreu um erro inesperado:\n\n{str(e)}")
        return
    

    try:
        # Tenta salvar o DataFrame de horários vagos como arquivo Excel.
        df_vazio.to_excel(os.path.join(saidas, caminho_arquivo1), sheet_name="Resultados", index=False)
    except PermissionError as e:
        # Se ocorrer erro de permissão (arquivo aberto ou bloqueado), exibe mensagem específica ao usuário.
        if e.errno == 13:
            messagebox.showerror("Erro de Permissão", 
                                    (
                                        f"Não foi possível salvar o arquivo {os.path.basename(caminho_arquivo1)}. "
                                        "Verifique se ele está aberto em outro programa (como o Excel) e tente novamente."
                                    )
                                )
            return
        else:
            # Para outros erros de permissão, exibe mensagem genérica.
            messagebox.showerror("Erro", f"Erro de permissão:\n\n{str(e)}")
            return
    except Exception as e:
        # Para qualquer outro erro inesperado, exibe mensagem genérica.
        messagebox.showerror("Erro inesperado!", f"Ocorreu um erro inesperado:\n\n{str(e)}")
        return
    
    # Ao final, informa ao usuário que os arquivos foram salvos com sucesso e indica a pasta de saída.
    messagebox.showinfo("Suesso", 
                        f"Arquivo {caminho_arquivo} criado com sucesso!\n\
                        \nArquivo {caminho_arquivo1} criado com sucesso!\n\
                        \nVerifique a pasta {saidas} para encontrá-lo.")

"""# Preencher Planilha de Dados"""

# Função que preenche as planilhas de dados fornecidas pelo usuário, sem a necessidade do mesmo preencher as
# alocações feitas pelo modelo de forma manual.
# Estruturalmente, a função é bem semelhante à de construir a primeira base de dados (a das aulas), com a única diferença
# sendo dois campos a mais para inserir a bases de dados feita anteriormente, e a solução dada pelo modelo.
def preencher_planilha_dados():
    """
    Abre uma janela para o usuário preencher planilhas de dados automaticamente, sem necessidade de edição manual das alocações.
    Permite ao usuário escolher entre preenchimento completo (todas as informações disponíveis) ou parcial (selecionando quais alocações manter).
    O usuário pode selecionar arquivos de base de dados, solução do modelo e arquivos adicionais para preenchimento.
    Realiza validações dos campos obrigatórios e chama funções auxiliares para executar o preenchimento conforme as escolhas do usuário.
    """
    preencher_completo = messagebox.askyesno("Preencher Planilha de Dados",
        "Deseja preencher a planilha de dados com todas as informações disponíveis? \n\n"
        "Caso não, você poderá escolher quais alocações serão mantidas."
    )

    # if preencher_completo:
    # Crio uma nova janela em cima da janela principal da interface.
    nova_janela = tk.Toplevel(root)
    nova_janela.title("Selecionar Arquivo e Inserir Valor")

    # Crio o frame para armazenar os botões e outros campos da nova janela.
    frame = tk.Frame(nova_janela)
    frame.pack(pady=10, padx=10)

    # Se for para preencher com todos os dados da solução, crio frame e funções para lista de arquivos extras
    if preencher_completo:
        frame2 = tk.Frame(nova_janela)
        frame2.pack(pady=10, padx=10)

        def add_file():
            file_path = filedialog.askopenfilename(title="Selecione um arquivo")
            if file_path:
                lista_outros.append(file_path)
                update_listbox()

        def remove_selected():
            try:
                selected_index = file_listbox.curselection()[0]
                lista_outros.pop(selected_index)
                update_listbox()
            except IndexError:
                pass

        def update_listbox():
            file_listbox.delete(0, tk.END)
            for file in lista_outros:
                file_listbox.insert(tk.END, file)  # Adiciona os arquivos novamente

        add_file_button = tk.Button(frame2, text="Adicionar Arquivo", command=add_file)
        add_file_button.grid(row=0, column=0, pady=5, sticky="w")

        file_listbox = tk.Listbox(frame2, width=100, height=10)
        file_listbox.grid(row=1, column=0, pady=5)

        remove_file_button = tk.Button(frame2, text="Remover Selecionado", command=remove_selected)
        remove_file_button.grid(row=0, column=0, pady=5, sticky="e")

    lista_outros = []  # Lista para armazenar arquivos de outros institutos

    # Variável de controle para a checkbox que habilita/desabilita a seleção da base de dados principal.
    var_base = tk.BooleanVar(value=False)  # True se o usuário deseja preencher a base de dados principal.
    # Variável que armazena o caminho do arquivo da base de dados selecionada.
    arquivo_base = tk.StringVar(value="Selecione a Base de Dados")
    # Variável que armazena o caminho do arquivo da solução do modelo selecionada.
    arquivo_sol = tk.StringVar(value="Selecione a Solução do Modelo")

    def selecionar_base():
        """
        Abre o diálogo para o usuário selecionar o arquivo da base de dados principal.
        Atualiza a variável arquivo_base com o caminho selecionado.
        """
        arquivo = filedialog.askopenfilename(title="Selecione a Base de Dados")
        if arquivo:
            arquivo_base.set(arquivo)

    def atualizar_estado():
        """
        Habilita ou desabilita o botão de seleção da base de dados conforme o estado da checkbox.
        Se desabilitado, reseta o valor da variável para o texto padrão.
        """
        if var_base.get():
            btn_selecionar_base.config(state=NORMAL)
        else:
            btn_selecionar_base.config(state=DISABLED)
            btn_selecionar_base.config(text="Selecione a Base de Dados")
            arquivo_base.set("Selecione a Base de Dados")

    def selecionar_sol():
        """
        Abre o diálogo para o usuário selecionar o arquivo da solução do modelo.
        Atualiza a variável arquivo_sol com o caminho selecionado.
        """
        arquivo = filedialog.askopenfilename(title="Selecione Solução do Modelo")
        if arquivo:
            arquivo_sol.set(arquivo)

    # Label para instruir o usuário a selecionar o arquivo da solução do modelo.
    lbl_sol = tk.Label(frame, text="Selecione a Solução do Modelo")
    lbl_sol.grid(row=0, column=0, pady=5, sticky="w")
    # Botão para abrir o diálogo de seleção do arquivo da solução do modelo.
    btn_selecionar_sol = tk.Button(frame, textvariable=arquivo_sol, command=selecionar_sol, wraplength=250, width=40)
    btn_selecionar_sol.grid(row=0, column=1, sticky='w', padx=5, pady=5)

    if preencher_completo:
        # Checkbox para o usuário indicar se deseja preencher a base de dados principal.
        checkbox11 = Checkbutton(frame, text="Preencherá a Base de Dados?", variable=var_base, command=atualizar_estado)
        checkbox11.grid(row=1, column=0, sticky='w', pady=5)

        # Botão para selecionar o arquivo da base de dados principal (inicialmente desabilitado).
        btn_selecionar_base = tk.Button(frame, textvariable=arquivo_base, command=selecionar_base, wraplength=250, width=40, state=DISABLED)
        btn_selecionar_base.grid(row=1, column=1, sticky='w', padx=5, pady=5)
    else:
        # Label e botão para seleção da base de dados do modelo (caso preenchimento parcial).
        lbl_base = tk.Label(frame, text="Selecione a Base de Dados do Modelo")
        lbl_base.grid(row=1, column=0, pady=5, sticky="w")
        btn_selecionar_base = tk.Button(frame, textvariable=arquivo_base, command=selecionar_base, wraplength=250, width=40)
        btn_selecionar_base.grid(row=1, column=1, sticky='w', padx=5, pady=5)


    def salvar_valores():
        """
        Realiza a validação dos campos obrigatórios e executa o preenchimento das planilhas conforme as escolhas do usuário.
        Exibe avisos caso algum campo obrigatório não tenha sido preenchido corretamente.
        Chama funções auxiliares para realizar o preenchimento completo ou parcial.
        """
        # Validação: arquivo da solução do modelo é obrigatório.
        if not arquivo_sol.get() or arquivo_sol.get() == "Selecione a Solução do Modelo":
            messagebox.showwarning("Aviso", "Selecione uma Solução do Modelo.")
            return

        # Se não houver nenhum arquivo extra para preenchimento:
        if not lista_outros:
            # Se o usuário marcou para preencher a base de dados principal:
            if var_base.get():
                # Validação: arquivo da base de dados é obrigatório.
                if not arquivo_base.get() or arquivo_base.get() == "Selecione a Base de Dados":
                    messagebox.showwarning("Aviso", "Selecione uma Base de Dados ou desative sua seleção.")
                    return
                else:
                    # Preenchimento completo: chama função para preencher todas as planilhas selecionadas.
                    if preencher_completo:
                        preenchimento(lista_outros, arquivo_sol.get(), arquivo_base.get(), False)
                    else:
                        # Preenchimento parcial: permite ao usuário escolher quais alocações manter.
                        escolhas_preenchimento(arquivo_sol.get(), arquivo_base.get())
            else:
                # Se for preenchimento completo, exige base de dados ou arquivos extras.
                if preencher_completo:
                    messagebox.showwarning("Aviso", "Selecione uma Base de Dados, ou adicione arquivos para o preenchimento.")
                    return
                else:
                    # Se for preenchimento parcial, exige base de dados.
                    if not arquivo_base.get() or arquivo_base.get() == "Selecione a Base de Dados":
                        messagebox.showwarning("Aviso", "Selecione uma Base de Dados.")
                        return
                    else:
                        escolhas_preenchimento(arquivo_sol.get(), arquivo_base.get())
        # Se houver pelo menos um arquivo extra para preenchimento:
        else:
            # Se o usuário marcou para preencher a base de dados principal:
            if var_base.get():
                # Validação: arquivo da base de dados é obrigatório.
                if not arquivo_base.get() or arquivo_base.get() == "Selecione a Base de Dados":
                    messagebox.showwarning("Aviso", "Selecione uma Base de Dados ou desative sua seleção.")
                    return
            else:
                # Se não marcou, pergunta se deseja continuar apenas com os arquivos extras.
                resposta = messagebox.askyesno("Aviso", "Você não selecionou uma Base de Dados. Deseja continuar preenchendo os arquivos selecionados?")
                if not resposta:
                    messagebox.showwarning("Aviso", "Selecione uma Base de Dados ou desative sua seleção.")
                    return
                if preencher_completo:
                    preenchimento(lista_outros, arquivo_sol.get(), "", False)
                    return
                else:
                    messagebox.showwarning("Aviso", "Selecione uma Base de Dados ou desative sua seleção.")
                    return
            # Se chegou até aqui, pode executar o preenchimento completo ou parcial.
            if preencher_completo:
                preenchimento(lista_outros, arquivo_sol.get(), arquivo_base.get(), False)
                return
            else:
                escolhas_preenchimento(arquivo_sol.get(), arquivo_base.get())
                return
            
    # Botão para executar o preenchimento das planilhas com os dados da solução, conforme o modo escolhido.
    if preencher_completo:
        btn_salvar = ttk.Button(frame2, text="Preencher Planilhas com os Dados da Solução", command=salvar_valores)
        btn_salvar.grid(row=2, column=0, pady=10)
    else:
        btn_salvar = ttk.Button(frame, text="Preencher Planilhas com os Dados da Solução", command=salvar_valores)
        btn_salvar.grid(row=2, column=0, pady=10)
    

"""## Escolhas de Preenchimento"""

# Função que define uma janela para o menu de preenchimento dos arquivos.
def escolhas_preenchimento(file_path_sol, file_path_base):
    """
    Abre uma janela para o usuário selecionar quais alocações da solução do modelo devem ser mantidas na planilha de dados.
    Exibe uma lista de aulas com checkboxes para o usuário marcar as que deseja fixar.
    Após a seleção, salva as escolhas em um novo arquivo Excel e chama a função de preenchimento.
    Realiza tratamento de erros ao salvar o arquivo e exibe mensagens apropriadas ao usuário.
    Parâmetros:
    - file_path_sol: caminho da planilha de solução do modelo
    - file_path_base: caminho da planilha de base de dados do modelo
    """
    # Cria uma nova janela modal sobre a principal para seleção das aulas a serem fixadas.
    nova_janela1 = tk.Toplevel(root)
    nova_janela1.title("Selecione quais aulas devem ser fixadas")
    nova_janela1.geometry("+250+150")

    # Frame principal para conter o Canvas e a Scrollbar (permite rolagem para listas grandes)
    frame_principal = tk.Frame(nova_janela1)
    frame_principal.pack(fill=tk.BOTH, expand=True)

    # Canvas para permitir rolagem vertical dos checkboxes
    canvas = tk.Canvas(frame_principal)
    canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

    # Scrollbar vertical conectada ao Canvas
    scrollbar = tk.Scrollbar(frame_principal, orient=tk.VERTICAL, command=canvas.yview)
    scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

    # Frame dentro do Canvas para organizar os checkboxes e labels
    frame_checkboxes = tk.Frame(canvas)
    canvas.create_window((0, 0), window=frame_checkboxes, anchor="nw")

    # Lê a planilha de solução do modelo para exibir as aulas disponíveis
    df = pd.read_excel(file_path_sol)

    # Cabeçalhos das colunas exibidas na interface
    labels = ['Disciplina', 'Horário', 'Sala', 'Inscritos', 'Fixar sala']
    for label in labels:
        tk.Label(frame_checkboxes, text=label).grid(row=0, column=labels.index(label), pady=5, padx=5, sticky='ew')
    # Linha de separação estética após os cabeçalhos
    ttk.Separator(frame_checkboxes, orient="horizontal").grid(row=1, column=0, columnspan=5, sticky="ew", pady=(0, 10))

    # Ordena as aulas por disciplina para facilitar a visualização
    df = df.sort_values(by=['Disciplina'], ignore_index=True)


    vars_checkboxes = []  # Lista para armazenar as variáveis dos checkboxes de cada aula
    for d in df.index:
        # Exibe os dados de cada aula em uma linha: Disciplina, Horário, Sala, Inscritos
        tk.Label(frame_checkboxes, text=df.loc[d, 'Disciplina']).grid(row=2+(2*d), column=0, pady=5, padx=5, sticky='ew')
        tk.Label(frame_checkboxes, text=df.loc[d, 'Horário']).grid(row=2+(2*d), column=1, pady=5, padx=5, sticky='ew')
        tk.Label(frame_checkboxes, text=df.loc[d, 'Sala']).grid(row=2+(2*d), column=2, pady=5, padx=5, sticky='ew')
        tk.Label(frame_checkboxes, text=df.loc[d, 'Inscritos']).grid(row=2+(2*d), column=3, pady=5, padx=5, sticky='ew')
        # Checkbox para o usuário indicar se deseja fixar a sala para esta aula
        var = tk.BooleanVar()
        tk.Checkbutton(frame_checkboxes, text='Fixar', variable=var).grid(row=2+(2*d), column=4, pady=5, padx=5, sticky='ew')
        vars_checkboxes.append(var)  # Salva a variável para referência posterior
        # Linha de separação entre aulas para melhor organização visual
        ttk.Separator(frame_checkboxes, orient="horizontal").grid(row=3+(2*d), column=0, columnspan=5, sticky="ew", pady=(0, 10))


    # Função para atualizar a área de rolagem do Canvas conforme o conteúdo muda
    def atualizar_scroll(event):
        canvas.configure(scrollregion=canvas.bbox("all"))

    frame_checkboxes.bind("<Configure>", atualizar_scroll)
    # Conecta a Scrollbar ao Canvas
    canvas.configure(yscrollcommand=scrollbar.set)


    def salvar_valores():
        """
        Coleta as escolhas do usuário (quais aulas devem ser fixadas), salva em um novo arquivo Excel,
        e chama a função de preenchimento para processar os dados conforme as escolhas.
        Em caso de erro ao salvar, exibe mensagens apropriadas ao usuário.
        """
        # Cria um novo DataFrame apenas com as aulas marcadas para fixar
        new_df = pd.DataFrame(columns=df.columns)
        for var in vars_checkboxes:
            if var.get():
                index = vars_checkboxes.index(var)
                new_df.loc[len(new_df)] = df.loc[index]

        # Tenta salvar o novo arquivo Excel com as escolhas do usuário
        try:
            new_df.to_excel(file_path_sol.replace('.xlsx',' com Escolhas.xlsx'), sheet_name="Resultados", index=False)
        except PermissionError as e:
            if e.errno == 13:  # Erro de permissão (arquivo aberto ou bloqueado)
                messagebox.showerror("Erro de Permissão", 
                    (f"Não foi possível salvar o arquivo {os.path.basename(file_path_sol.replace('.xlsx',' com Escolhas.xlsx'))}. "
                     "Verifique se ele está aberto em outro programa (como o Excel) e tente novamente."))
                return
            else:
                messagebox.showerror("Erro", f"Erro de permissão:\n\n{str(e)}")
                return
        except Exception as e:
            # Para qualquer outro erro inesperado
            messagebox.showerror("Erro inesperado!", f"Ocorreu um erro inesperado:\n\n{str(e)}")
            return

        # Chama a função de preenchimento para processar os arquivos conforme as escolhas feitas
        preenchimento("", file_path_sol.replace('.xlsx',' com Escolhas.xlsx'), file_path_base, True)
        # Fecha a janela após o processamento
        nova_janela1.destroy()


    # Determina a última linha utilizada para posicionar o botão de execução
    ultima_linha = 2 + 2 * len(df)

    # Botão para executar o preenchimento das planilhas com as escolhas feitas pelo usuário
    ttk.Button(frame_checkboxes, text="Preencher planilhas com salas fixadas",
               command=salvar_valores).grid(row=ultima_linha, column=3, pady=5, padx=5, sticky='ew')

    # Mantém a janela aberta até que seja fechada pelo usuário ou pelo processamento
    nova_janela1.wait_window()

"""## Função para preencher"""

# Função que preenche os arquivos fornecidos pelo usuário.
def preenchimento(lista_elenco, file_path_sol, file_path_base, preencher_parcial):
    """
    Função que preenche as planilhas de dados fornecidas pelo usuário com as alocações feitas pelo modelo.
    Parâmetros:
    - lista_elenco: lista de caminhos dos arquivos de elenco a serem preenchidos
    - file_path_sol: caminho da planilha de solução do modelo
    - file_path_base: caminho da planilha de base de dados do modelo
    - preencher_parcial: booleano indicando se o preenchimento é parcial (True) ou
    """
    # Abre a solução gerada pelo modelo como um DataFrame para cruzamento de dados.
    solucao = pd.read_excel(file_path_sol)

    if lista_elenco:
        # Para cada arquivo de elenco na lista:
        for file_path_elenco in lista_elenco:
            # Lê o arquivo de elenco como DataFrame.
            elenco = pd.read_excel(file_path_elenco)

            # Define o nome do cabeçalho a ser localizado (caso não esteja na primeira linha).
            header_name = 'Disciplina (código)'

            # Procura a linha do cabeçalho correto na primeira coluna do DataFrame.
            for i, valor in enumerate(elenco.loc[:,elenco.columns[0]]):
                if valor == header_name:
                    header_row = i+1  # Salva o índice da linha do cabeçalho.
                    break  # Interrompe a busca ao encontrar o cabeçalho.

            # Lê novamente o arquivo, agora com o cabeçalho correto.
            elenco = pd.read_excel(file_path_elenco, header=header_row)

            # Padroniza os nomes das colunas do DataFrame:
            for col in range(len(elenco.columns)):
                # Substitui quebras de linha por espaço nos nomes das colunas.
                if "\n" in elenco.columns[col]:
                    elenco = elenco.rename(columns={elenco.columns[col] : elenco.columns[col].replace("\n", " ")})
                # Renomeia qualquer coluna relacionada a sala para apenas "Sala".
                if "Sala" in elenco.columns[col]:
                    elenco = elenco.rename(columns={elenco.columns[col] : "Sala"})

            # Como a manipulação direta do DataFrame pode alterar a estrutura do arquivo Excel,
            # é necessário abrir o arquivo como workbook para editar células específicas.
            wb = load_workbook(file_path_elenco)
            ws = wb.active

            # Itera sobre cada linha do DataFrame de elenco para atualizar as alocações de sala.
            for d in range(len(elenco)):
                # Remove espaços do código da disciplina para padronização.
                elenco.loc[d, 'Disciplina (código)'] = str(elenco.loc[d, 'Disciplina (código)']).replace(' ', '')

                # Monta o nome da disciplina no formato utilizado pelo modelo (ex: "ABC-1").
                if not pd.isna(elenco.loc[d, 'Turma']):
                    disciplina = str(elenco.loc[d, 'Disciplina (código)']) + '-' + str(int(elenco.loc[d, 'Turma']))

                    # Verifica se a disciplina está presente na solução do modelo.
                    if disciplina in solucao['Disciplina'].tolist():
                        # Calcula a linha correta no workbook (considerando cabeçalho e índice do DataFrame).
                        row = d+2
                        # Calcula o índice da coluna de salas no workbook.
                        coluna = elenco.columns.get_loc('Sala')+1

                        # Limpa o valor da célula de sala antes de preencher com os dados da solução.
                        ws.cell(row=header_row+row, column=coluna).value = None

                        # Filtra a solução para obter apenas as aulas da disciplina atual.
                        solucao_filtrada = solucao[solucao['Disciplina'] == disciplina]


                        # Antes de explicar cada linha do trecho seguinte, devo explicar a lógica por trás dele.
                        # Com a solução filtrada, eu tenho, separadamente, os horários das aulas de uma disciplina e a sala
                        # onde cada uma foi alocada. Dessa forma, eu consigo iterar no comprimento da solução filtrada,
                        # que deve me dar o número de colunas de horário que aquela disciplina possui.
                        # E se eu cruzar essa iteração com uma que verifica se uma das aulas corresponde com a atual coluna de horário,
                        # eu consigo cruzar colocar, em ordem, qual a sala de cada aula.

                        # Para cada horário da disciplina, verifica se corresponde a uma alocação na solução.
                        for i in range(len(solucao_filtrada)):
                            for a in solucao_filtrada.index:
                                # Se o horário do elenco bate com o horário da solução, preenche a célula de sala.
                                if elenco.loc[d, 'Horário ' + str(i+1)] == solucao_filtrada.loc[a, 'Horário']:
                                    # Se já existe valor na célula, concatena com vírgula (caso haja mais de uma sala).
                                    if ws.cell(row=header_row+row, column=coluna).value:
                                        novo_valor = str(ws.cell(row=header_row+row, column=coluna).value) + ', ' + str(solucao_filtrada.loc[a, 'Sala'])
                                        ws.cell(row=header_row+row, column=coluna).value = novo_valor
                                    else:
                                        # Se não existe valor, insere a primeira sala alocada.
                                        ws.cell(row=header_row+row, column=coluna).value = str(solucao_filtrada.loc[a, 'Sala'])


            try:
                # Salva o novo arquivo de elenco preenchido, adicionando 'Preenchido' ao nome para identificação.
                wb.save(file_path_elenco.replace('.xlsx', ' Preenchido.xlsx'))
            except PermissionError as e:
                # Se o arquivo estiver aberto ou bloqueado, exibe mensagem específica ao usuário.
                if e.errno == 13:
                    messagebox.showerror("Erro de Permissão", 
                        (f"Não foi possível salvar o arquivo {os.path.basename(file_path_elenco.replace('.xlsx',' Preenchido.xlsx'))}. "
                         "Verifique se ele está aberto em outro programa (como o Excel) e tente novamente."))
                    return
                else:
                    # Para outros erros de permissão, exibe mensagem genérica.
                    messagebox.showerror("Erro", f"Erro de permissão:\n\n{str(e)}")
                    return
            except Exception as e:
                # Para qualquer outro erro inesperado, exibe mensagem genérica.
                messagebox.showerror("Erro inesperado!", f"Ocorreu um erro inesperado:\n\n{str(e)}")
                return
        
        
    if file_path_base:
        # Após preencher os elencos, preenche a base de dados principal do modelo.
        base = pd.ExcelFile(file_path_base)
        sheet_names = base.sheet_names  # Lista de planilhas presentes no arquivo.
        base = pd.read_excel(file_path_base, sheet_name=sheet_names)  # Lê todas as planilhas como DataFrames.

        # Para cada planilha de disciplinas (exceto a primeira, que é de salas):
        for sheet in sheet_names[1:]:
            # Para cada linha da planilha, cruza os dados da solução para preencher as salas corretamente.
            for d in range(len(base[sheet])):
                disciplina = base[sheet].loc[d, 'Disciplina (código)']
                if disciplina in solucao['Disciplina'].tolist():
                    base[sheet].loc[d, 'Sala'] = None
                    solucao_filtrada = solucao[solucao['Disciplina'] == disciplina]
                    # Monta a lista de salas alocadas para cada horário da disciplina.
                    novo_valor = ['0', '0', '0', '0']
                    for i in range(4):
                        for a in solucao_filtrada.index:
                            if base[sheet].loc[d, 'Horário ' + str(i+1)] == solucao_filtrada.loc[a, 'Horário']:
                                novo_valor[i] = str(solucao_filtrada.loc[a, 'Sala'])
                    # Concatena as salas em uma única string separada por vírgula.
                    salas_fixadas = novo_valor[0]
                    for s in novo_valor[1:]:
                        salas_fixadas += ', ' + str(s)
                    base[sheet].loc[d, 'Sala'] = salas_fixadas

        try:
            # Salva o novo arquivo Excel com nome alterado para distinguir preenchimento total/parcial.
            if not preencher_parcial:
                with pd.ExcelWriter(file_path_base.replace('.xlsx', ' Preenchido.xlsx'), engine="openpyxl") as writer:
                    for sheet in sheet_names:
                        base[sheet].to_excel(writer, sheet_name=sheet, index=False)
            else:
                with pd.ExcelWriter(file_path_base.replace('.xlsx', ' Parcial.xlsx'), engine="openpyxl") as writer:
                    for sheet in sheet_names:
                        base[sheet].to_excel(writer, sheet_name=sheet, index=False)
        except PermissionError as e:
            # Se o arquivo estiver aberto ou bloqueado, exibe mensagem específica ao usuário.
            if e.errno == 13 and not preencher_parcial:
                messagebox.showerror("Erro de Permissão", 
                    (f"Não foi possível salvar o arquivo {os.path.basename(file_path_base.replace('.xlsx',' Preenchido.xlsx'))}. "
                     "Verifique se ele está aberto em outro programa (como o Excel) e tente novamente."))
                return
            elif e.errno == 13 and preencher_parcial:
                messagebox.showerror("Erro de Permissão", 
                    (f"Não foi possível salvar o arquivo {os.path.basename(file_path_base.replace('.xlsx',' Parcial.xlsx'))}. "
                     "Verifique se ele está aberto em outro programa (como o Excel) e tente novamente."))
                return
            else:
                # Para outros erros de permissão, exibe mensagem genérica.
                messagebox.showerror("Erro", f"Erro de permissão:\n\n{str(e)}")
                return
        except Exception as e:
            # Para qualquer outro erro inesperado, exibe mensagem genérica.
            messagebox.showerror("Erro inesperado!", f"Ocorreu um erro inesperado:\n\n{str(e)}")
            return
        
    # Ao final do processo, informa ao usuário quais arquivos foram criados com sucesso.
    if lista_elenco:
        text_message = "O(s) seguinte(s) arquivo(s) foi(ram) criado(s) utilizando os Dados da Solução do Modelo:\n"
        for file_path_elenco in lista_elenco:
            # Adiciona à mensagem o nome dos arquivos de elenco preenchidos.
            text_message += f"- {os.path.basename(file_path_elenco.replace('.xlsx', ' Preenchido.xlsx'))}\n"
        if file_path_base:
            text_message += f"- {os.path.basename(file_path_base.replace('.xlsx', ' Preenchido.xlsx'))}\n"
        messagebox.showinfo("Sucesso!", text_message)
    else:
        if not preencher_parcial:
            # Mensagem para preenchimento total da base de dados.
            text_message = "O seguinte arquivo foi criado utilizando os Dados da Solução do Modelo:\n"
            text_message += f"- {os.path.basename(file_path_base.replace('.xlsx', ' Preenchido.xlsx'))}\n"
            messagebox.showinfo("Sucesso!", text_message)
        else:
            # Mensagem para preenchimento parcial.
            text_message = "O seguinte arquivo foi criado utilizando os Dados da Solução do Modelo:\n"
            text_message += f"- {os.path.basename(file_path_sol)}\n"
            text_message += f"- {os.path.basename(file_path_base.replace('.xlsx', ' Parcial.xlsx'))}\n"
            messagebox.showinfo("Sucesso!", text_message)
    


def funcao_visualizacao(dfv, space_between, start_row, start_column, end_row, end_column, start, salas1, dias_semana, horarios, ws, aulas):
    """
    Gera a visualização dos horários alocados para cada sala, preenchendo a planilha Excel com as disciplinas e horários.
    Para cada sala, utiliza os dados do DataFrame de solução para preencher os horários e disciplinas alocadas.
    Parâmetros:
        dfv: DataFrame com os dados de alocação das aulas
        space_between: número de linhas entre tabelas de salas
        start_row, start_column, end_row, end_column: coordenadas iniciais/finais para cada tabela de sala
        start: linha inicial para os dias da semana
        salas1: lista de salas utilizadas
        dias_semana: lista dos dias da semana
        horarios: lista dos horários disponíveis
        ws: worksheet do Excel a ser preenchida
        aulas: contador de aulas alocadas
    Retorna:
        Número total de aulas alocadas na planilha
    """

    # Função interna para padronizar o formato dos horários das aulas para facilitar a visualização e evitar inconsistências.
    def padronizar_horario_intranet(horario):
        """
        Padroniza o formato do horário recebido, ajustando espaços, separadores e arredondando horários conforme regras de alocação.
        Parâmetros:
            horario: string no formato 'Dia-HoraInicio/HoraFim', podendo conter espaços ou 'h' como separador
        Retorna:
            String padronizada no formato 'Dia - HH:MM/HH:MM', com horários ajustados para facilitar a visualização e evitar sobreposições.
        """
        # Remove espaços do horário, se houver.
        if ' ' in horario:
            horario = str(horario).replace(' ', '')
        # Substitui 'h' por ':', se houver, para uniformizar o formato.
        if 'h' in horario:
            horario = str(horario).replace('h', ':')
        # Separa o dia do intervalo de horário.
        dia, intervalo = horario.split('-')
        # Separa o horário de início e fim da aula.
        start, end = intervalo.split('/')
        # Converte os horários para objetos datetime para facilitar manipulação.
        start_dt = datetime.strptime(start, "%H:%M")
        end_dt = datetime.strptime(end, "%H:%M")

        # Ajusta o horário de início: para horários antes das 18h, zera os minutos (ex: 8:10 vira 8:00).
        if start_dt.hour < 18:
            start_dt = start_dt.replace(minute=0)
        # Horários de início a partir das 18h permanecem como estão.

        # Ajusta o horário de fim conforme regras específicas:
        if end_dt.hour <= 18:
            # Se minutos < 30, arredonda para hora anterior com 30 minutos (ex: 18:00 vira 17:30).
            if end_dt.minute < 30:
                end_dt = end_dt.replace(minute=30, hour=end_dt.hour - 1)
            # Se minutos > 30, fixa em 30 minutos (ex: 09:50 vira 09:30).
            elif end_dt.minute > 30:
                end_dt = end_dt.replace(minute=30)
        else:
            # Para horários de fim após 18h:
            # Se minutos entre 1 e 29, fixa em 0 minutos (ex: 19:10 vira 19:00).
            if end_dt.minute < 30 and end_dt.minute > 0:
                end_dt = end_dt.replace(minute=0)
            # Se minutos > 30, fixa em 30 minutos (ex: 20:40 vira 20:30).
            elif end_dt.minute > 30:
                end_dt = end_dt.replace(minute=30)
            # Se minutos = 0, considera que a aula termina meia hora antes (ex: 19:00 vira 18:30).
            else:
                end_dt = end_dt.replace(minute=30, hour=end_dt.hour - 1)

        # Retorna o horário padronizado para visualização.
        return str(f'{dia} - {start_dt.strftime("%H:%M")}/{end_dt.strftime("%H:%M")}')

    def preencher_planilha(start_row, start_column, end_row, end_column, start, sala, dias_semana, horarios, aula, disciplina, ws, aulas):
        """
        Preenche a planilha Excel com os nomes das disciplinas alocadas em cada sala, organizando visualmente por dia e horário.
        Parâmetros:
            start_row, start_column, end_row, end_column: coordenadas para mesclagem e posicionamento da tabela da sala
            start: linha inicial para os dias da semana
            sala: nome ou número da sala a ser preenchida
            dias_semana: lista dos dias da semana
            horarios: lista dos horários disponíveis
            aula: lista dos horários das aulas alocadas na sala
            disciplina: lista dos códigos das disciplinas alocadas
            ws: worksheet do Excel a ser preenchida
            aulas: contador de aulas já alocadas
        Retorna:
            Número total de aulas alocadas após o preenchimento
        """
        # Preenchimento verde para identificar células de disciplinas alocadas.
        green_fill = PatternFill(start_color="99CC00", end_color="99CC00", fill_type="solid")

        # Estilo de borda fina para delimitar células da tabela.
        thin_border = Border(
            left=Side(style="thin"),
            right=Side(style="thin"),
            top=Side(style="thin"),
            bottom=Side(style="thin")
        )

        # Mescla células para exibir o nome/número da sala no topo da tabela.
        ws.merge_cells(start_row=start_row, start_column=start_column, end_row=end_row, end_column=end_column)
        ws.cell(row=start_row, column=start_column).value = sala
        ws.cell(row=start_row, column=start_column).alignment = Alignment(horizontal="center", vertical="center")
        # Aplica borda em todas as células mescladas do cabeçalho da sala.
        for col in range(1, end_column):
            ws.cell(row=start_row, column=col+1).border = thin_border

        # Preenche a primeira coluna da tabela com os dias da semana e aplica borda.
        for i, dia in enumerate(dias_semana, start=start):
            ws.cell(row=i, column=start_column-1).value = dia
            ws.cell(row=i, column=start_column-1).border = thin_border

        # Preenche o cabeçalho de horários nas colunas correspondentes e aplica borda/alinhamento.
        for j, horario in enumerate(horarios, start=start_column):
            ws.cell(row=start_row+1, column=j).value = horario
            ws.cell(row=start_row+1, column=j).alignment = Alignment(horizontal="center", vertical="center")
            ws.cell(row=start_row+1, column=j).border = thin_border

        # Aplica borda em todas as células da tabela de horários/dias.
        for row in range(start, start + len(dias_semana)):
            for col in range(start_column, start_column + len(horarios)):
                ws.cell(row=row, column=col).border = thin_border

        # Preenche as células com as disciplinas alocadas, mesclando conforme o intervalo de cada aula.
        for h in aula:
            # Separa o dia e o intervalo da aula (ex: 'Terça - 08:00/09:30').
            dia_h, int_h = h.split(' - ')
            start_h, end_h = int_h.split('/')
            # Para cada dia da semana, verifica se corresponde ao dia da aula.
            for i, dia in enumerate(dias_semana, start=start):
                if ws.cell(row=i, column=start_column-1).value == dia_h:
                    # Identifica os índices das colunas de início e fim do intervalo da aula.
                    index_start = horarios.index(start_h)
                    index_end = horarios.index(end_h)
                    # Mescla as células do intervalo e preenche com o nome da disciplina.
                    ws.merge_cells(start_row=i, start_column=index_start+2, end_row=i, end_column=index_end+2)
                    merged_cell = ws.cell(row=i, column=index_start+2)
                    merged_cell.value = disciplina[aula.index(h)]
                    merged_cell.fill = green_fill
                    merged_cell.alignment = Alignment(horizontal="center", vertical="center")
                    # Incrementa o contador de aulas alocadas.
                    aulas += 1
        # Retorna o número total de aulas alocadas na planilha.
        return aulas


    def ajusta_largura(ws):
        """
        Ajusta automaticamente a largura de cada coluna da planilha Excel com base no maior conteúdo presente,
        garantindo melhor visualização dos dados e evitando cortes de texto. Considera células mescladas e ignora erros de leitura.
        Parâmetros:
            ws: worksheet do Excel a ser ajustada
        """
        for col in ws.columns:
            max_length = 0  # Comprimento máximo encontrado na coluna
            # Verifica se a primeira célula é mesclada (MergedCell), pois ela não possui column_letter
            if type(col[0]) == openpyxl.cell.cell.MergedCell:
                # Usa a célula abaixo para obter a letra da coluna
                column = col[1].column_letter
            else:
                column = col[0].column_letter
            # Percorre todas as células da coluna para encontrar o maior comprimento de texto
            for cell in col:
                try:
                    # Atualiza o comprimento máximo se o valor da célula for maior
                    if len(str(cell.value)) > max_length:
                        max_length = len(str(cell.value))
                except:
                    # Ignora erros de leitura em células mescladas ou vazias
                    pass
            # Ajusta a largura da coluna proporcional ao maior conteúdo encontrado
            ws.column_dimensions[column].width = (max_length) * 1.1

    

    

    # Para cada sala utilizada na solução, preenche a tabela correspondente na planilha
    for sala in salas1:
        # Filtra as aulas alocadas para a sala atual
        df_filtrado = dfv[dfv['Sala'] == sala]
        # Lista dos horários das aulas (padronizados)
        aula = df_filtrado['Horário'].apply(lambda x: padronizar_horario_intranet(x)).tolist()
        # Lista dos códigos das disciplinas alocadas
        disciplina = df_filtrado['Disciplina'].tolist()
        # Preenche a tabela da sala na planilha e atualiza o contador de aulas
        aulas = preencher_planilha(start_row, start_column, end_row, end_column, start, sala, dias_semana, horarios, aula, disciplina, ws, aulas)
        # Atualiza as coordenadas para posicionar a próxima tabela de sala
        start_row = start_row + 2 + len(dias_semana) + space_between
        end_row = start_row
        start = start_row + 2

    # Após preencher todas as salas, ajusta a largura das colunas para melhor visualização
    ajusta_largura(ws)

    return aulas
    

def visualizacao_completa(dfv, salas1, horarios, sala_colunas, dias_semana):
    """
    Gera uma planilha Excel com a visualização completa da solução de alocação de aulas por sala e horário.
    Cria uma tabela para cada sala, preenchendo os horários e disciplinas alocadas, e salva o arquivo na pasta de saída.
    Parâmetros:
        dfv: DataFrame com os dados de alocação das aulas
        salas1: lista de salas utilizadas
        horarios: lista dos horários disponíveis
        sala_colunas: número de colunas de horários
        dias_semana: lista dos dias da semana
    """
    # Cria o workbook e a worksheet ativa para a visualização dos horários
    wb = Workbook()
    ws = wb.active
    ws.title = "Horário de Aulas"

    # Define as coordenadas iniciais para a primeira tabela de sala
    start_row = 1  # Linha de início da tabela
    start_column = 2  # Coluna de início da tabela
    end_row = 1  # Linha de término da tabela
    end_column = 1 + sala_colunas  # Coluna de término da tabela
    start = start_row + 2  # Linha para os dias da semana
    space_between = 3  # Espaço entre tabelas de salas
    aulas = 0  # Contador de aulas alocadas

    # Chama a função que preenche todas as tabelas de salas na planilha
    aulas = funcao_visualizacao(
        dfv, space_between, start_row, start_column, end_row, end_column, start, salas1, dias_semana, horarios, ws, aulas
    )

    # Define o nome e caminho do arquivo de saída
    full_name = "Visualização completa da Solução.xlsx"
    file_path = os.path.join(saidas, full_name)

    # Tenta salvar o arquivo Excel, tratando erros de permissão e outros imprevistos
    try:
        wb.save(file_path)
    except PermissionError as e:
        if e.errno == 13:
            # Erro de permissão: arquivo provavelmente está aberto em outro programa
            messagebox.showerror(
                "Erro de Permissão",
                (
                    f"O arquivo '{full_name}' está aberto em algum programa (como o Excel). "
                    "Feche o arquivo e tente novamente."
                    f"\n\nDetalhes do erro: {e}"
                )
            )
            return
        else:
            messagebox.showerror("Erro", f"Ocorreu um erro inesperado ao criar o arquivo '{full_name}': {e}")
            return
    except Exception as e:
        messagebox.showerror("Erro", f"Ocorreu um erro inesperado ao criar o arquivo '{full_name}': {e}")
        return

    # Informa ao usuário que o arquivo foi criado com sucesso e o número de aulas alocadas
    messagebox.showinfo(
        "Sucesso!",
        f"O arquivo '{full_name}' foi criado com sucesso!\nNúmero de aulas alocadas: {aulas}"
    )
    return

    
def visualizacao_curso(dfv, salas1, horarios, sala_colunas, dias_semana):
    """
    Gera uma planilha Excel com a visualização dos horários alocados por curso, criando uma aba para cada currículo.
    Para cada curso, preenche as tabelas de salas com as disciplinas e horários alocados, e salva o arquivo na pasta de saída.
    Parâmetros:
        dfv: DataFrame com os dados de alocação das aulas
        salas1: lista de salas utilizadas (será sobrescrita para cada curso)
        horarios: lista dos horários disponíveis
        sala_colunas: número de colunas de horários
        dias_semana: lista dos dias da semana
    """
    # Cria o workbook para a visualização por curso
    wb = Workbook()
    # Lista dos currículos/cursos para gerar uma aba para cada um
    curriculos = ['BMACC', 'BMA', 'LMA', 'MAT-NG', 'BECD', 'BCC', 'BSI', 'BCDados']
    aulas = 0  # Contador de aulas alocadas
    for c in curriculos:
        # Cria uma nova aba para o curso atual
        ws = wb.create_sheet(title=c)

        # Define as coordenadas iniciais para a primeira tabela de sala
        start_row = 1  # Linha de início da tabela
        start_column = 2  # Coluna de início da tabela
        end_row = 1  # Linha de término da tabela
        end_column = 1 + sala_colunas  # Coluna de término da tabela
        start = start_row + 2  # Linha para os dias da semana
        space_between = 3  # Espaço entre tabelas de salas

        # Filtra o DataFrame para o curso atual
        df_filtrado = dfv[dfv['Cursos'].str.contains(c, na=False)]
        # Lista das salas utilizadas para o curso
        salas1 = df_filtrado['Sala'].unique().tolist()

        # Preenche as tabelas de salas na aba do curso
        aulas = funcao_visualizacao(
            df_filtrado, space_between, start_row, start_column, end_row, end_column, start, salas1, dias_semana, horarios, ws, aulas
        )

    # Remove a primeira aba criada automaticamente (vazia)
    wb.remove(wb.active)
    full_name = "Visualização por Curso.xlsx"
    file_path = os.path.join(saidas, full_name)

    # Tenta salvar o arquivo Excel, tratando erros de permissão e outros imprevistos
    try:
        wb.save(file_path)
    except PermissionError as e:
        if e.errno == 13:
            # Erro de permissão: arquivo provavelmente está aberto em outro programa
            messagebox.showerror(
                "Erro de Permissão",
                (
                    f"O arquivo '{full_name}' está aberto em algum programa (como o Excel). "
                    "Feche o arquivo e tente novamente."
                    f"\n\nDetalhes do erro: {e}"
                )
            )
            return
        else:
            messagebox.showerror("Erro", f"Ocorreu um erro inesperado ao criar o arquivo '{full_name}': {e}")
            return
    except Exception as e:
        messagebox.showerror("Erro", f"Ocorreu um erro inesperado ao criar o arquivo '{full_name}': {e}")
        return

    # Informa ao usuário que o arquivo foi criado com sucesso e o número de aulas alocadas
    messagebox.showinfo(
        "Sucesso!",
        f"O arquivo '{full_name}' foi criado com sucesso!\nNúmero de aulas alocadas: {aulas}"
    )
    return

    
def visualizacao_dep(dfv, salas1, horarios, sala_colunas, dias_semana):
    """
    Gera uma planilha Excel com a visualização dos horários alocados por departamento, criando uma aba para cada departamento do ICMC
    e uma aba especial para disciplinas de outros departamentos. Para cada departamento, preenche as tabelas de salas com as disciplinas
    e horários alocados, e salva o arquivo na pasta de saída.
    Parâmetros:
        dfv: DataFrame com os dados de alocação das aulas
        salas1: lista de salas utilizadas (será sobrescrita para cada departamento)
        horarios: lista dos horários disponíveis
        sala_colunas: número de colunas de horários
        dias_semana: lista dos dias da semana
    """
    # Cria o workbook para a visualização por departamento
    wb = Workbook()
    # Lista dos departamentos do ICMC e uma categoria para disciplinas externas
    departamentos = ['SME', 'SMA', 'SCC', 'SSC', 'Outras']
    aulas = 0  # Contador de aulas alocadas
    for d in departamentos:
        # Cria uma nova aba para o departamento atual
        ws = wb.create_sheet(title=d)

        # Define as coordenadas iniciais para a primeira tabela de sala
        start_row = 1  # Linha de início da tabela
        start_column = 2  # Coluna de início da tabela
        end_row = 1  # Linha de término da tabela
        end_column = 1 + sala_colunas  # Coluna de término da tabela
        start = start_row + 2  # Linha para os dias da semana
        space_between = 3  # Espaço entre tabelas de salas
        aulas = 0  # Reinicia o contador para cada aba

        # Filtra o DataFrame para o departamento atual
        if d == 'Outras':
            # Filtra disciplinas que não pertencem aos departamentos do ICMC
            filtro = ~(
                dfv['Disciplina'].str.startswith('SME', na=False) |
                dfv['Disciplina'].str.startswith('SMA', na=False) |
                dfv['Disciplina'].str.startswith('SCC', na=False) |
                dfv['Disciplina'].str.startswith('SSC', na=False)
            )
            df_filtrado = dfv[filtro]
        else:
            # Filtra disciplinas do departamento atual
            df_filtrado = dfv[dfv['Disciplina'].str.startswith(d, na=False)]

        # Lista das salas utilizadas para o departamento
        salas1 = df_filtrado['Sala'].unique().tolist()

        # Preenche as tabelas de salas na aba do departamento
        aulas = funcao_visualizacao(
            df_filtrado, space_between, start_row, start_column, end_row, end_column, start, salas1, dias_semana, horarios, ws, aulas
        )

    # Remove a primeira aba criada automaticamente (vazia)
    wb.remove(wb.active)
    full_name = "Visualização por Departamento.xlsx"
    file_path = os.path.join(saidas, full_name)

    # Tenta salvar o arquivo Excel, tratando erros de permissão e outros imprevistos
    try:
        wb.save(file_path)
    except PermissionError as e:
        if e.errno == 13:
            # Erro de permissão: arquivo provavelmente está aberto em outro programa
            messagebox.showerror(
                "Erro de Permissão",
                (
                    f"O arquivo '{full_name}' está aberto em algum programa (como o Excel). "
                    "Feche o arquivo e tente novamente."
                    f"\n\nDetalhes do erro: {e}"
                )
            )
            return
        else:
            messagebox.showerror("Erro", f"Ocorreu um erro inesperado ao criar o arquivo '{full_name}': {e}")
            return
    except Exception as e:
        messagebox.showerror("Erro", f"Ocorreu um erro inesperado ao criar o arquivo '{full_name}': {e}")
        return

    # Informa ao usuário que o arquivo foi criado com sucesso e o número de aulas alocadas
    messagebox.showinfo(
        "Sucesso!",
        f"O arquivo '{full_name}' foi criado com sucesso!\nNúmero de aulas alocadas: {aulas}"
    )
    return

def planilhas_sti(file_path):
    """
    Gera planilhas CSV para o sistema da intranet a partir da planilha de alocação criada pelo modelo.
    Extrai, organiza e converte os dados para o formato exigido pelo STI, criando uma planilha geral e uma para cada sala.
    Parâmetros:
        file_path: caminho da planilha de alocação criada pelo modelo
    """
    file_list = []

    # Lê a planilha de alocação criada pelo modelo
    sti = pd.read_excel(file_path)

    # Função auxiliar para extrair o horário de início e fim das aulas
    def extrair_horarios(horario):
        # Remove espaços extras e deixa minúsculo para uniformizar
        horario = horario.strip().lower()
        # Expressão regular para identificar o padrão: dia da semana e dois horários
        pattern = r"(\bseg(?:unda)?\b|\bter(?:ça)?\b|\bqua(?:rta)?\b|\bqui(?:nta)?\b|\bsex(?:ta)?\b|\bs[áa]b(?:ado)?\b|\bdom(?:ingo)?\b)\s*-?\s*(\d{2}:\d{2})\s*[/-]?\s*(\d{2}:\d{2})"
        match = re.search(pattern, horario)
        if match:
            dia = match.group(1).capitalize()  # Dia da semana
            horario_inicio = match.group(2)    # Horário de início
            horario_fim = match.group(3)       # Horário de fim
            # Retorna os valores como formato padrão
            return f"{dia} - {horario_inicio}", f"{dia} - {horario_fim}"
        else:
            return None, None

    # Padroniza os nomes das salas para o STI (separando salas conjuntas)
    Sala = []
    for i in sti['Sala']:
        if i != '6-305/6-306' and i != '6-303/6-304':
            Sala.append(i)
        elif i == '6-305/6-306':
            Sala.append('6-305')
        else:
            Sala.append('6-303')

    # Organiza os dados para o formato exigido pelo STI
    dados_organizados = {
        'Sala': Sala,
        'Disciplina': sti['Disciplina'],
        'Descrição': sti['Nomes'],
        'Aula': ["Aula" for i in range(len(sti['Sala']))],
        'Dia e hora início': sti['Hora de Início'],
        'Dia e hora fim': sti['Hora de Fim'],
        'Docente': sti['NUSP'],
        'Compartilhada com outra sala?': ["S" if (sti['Sala'][i] == '6-305/6-306' or sti['Sala'][i] == '6-303/6-304') else "N" for i in range(len(sti['Sala']))]
    }

    # Converte o dicionário para um DataFrame
    sti_planilha = pd.DataFrame(dados_organizados)

    # Caminho do arquivo geral a ser criado
    full_name = "Planilha da Intranet Completa.csv"
    pasta_dados = saidas
    file_path = os.path.join(pasta_dados, full_name)

    # Salva o arquivo geral, tratando erros de permissão e outros imprevistos
    try:
        sti_planilha.to_csv(file_path, index=False, sep=';', encoding='latin-1')
        file_list.append(full_name)
    except PermissionError as e:
        if e.errno == 13:
            # Erro de permissão: arquivo provavelmente está aberto em outro programa
            messagebox.showerror(
                "Erro de Permissão",
                (
                    f"O arquivo '{full_name}' está aberto em algum programa (como o Excel). "
                    "Feche o arquivo e tente novamente."
                    f"\n\nDetalhes do erro: {e}"
                )
            )
            return
        else:
            messagebox.showerror("Erro", f"Ocorreu um erro inesperado ao criar o arquivo '{full_name}': {e}")
            return
    except Exception as e:
        messagebox.showerror("Erro", f"Ocorreu um erro inesperado ao criar o arquivo '{full_name}': {e}")
        return

    # Para cada sala, cria um arquivo separado com os dados daquela sala
    for sala in sti_planilha['Sala'].unique():
        sti_planilha_aux = sti_planilha[sti_planilha['Sala'] == sala]
        full_name = f"Planilha da Intranet - {sala}.csv"
        file_path = os.path.join(pasta_dados, full_name)
        try:
            sti_planilha_aux.to_csv(file_path, index=False, sep=';', encoding='latin-1')
            file_list.append(full_name)
        except PermissionError as e:
            if e.errno == 13:
                # Erro de permissão: arquivo provavelmente está aberto em outro programa
                messagebox.showerror(
                    "Erro de Permissão",
                    (
                        f"O arquivo '{full_name}' está aberto em algum programa (como o Excel). "
                        "Feche o arquivo e tente novamente."
                        f"\n\nDetalhes do erro: {e}"
                    )
                )
                return
            else:
                messagebox.showerror("Erro", f"Ocorreu um erro inesperado ao criar o arquivo '{full_name}': {e}")
                return
        except Exception as e:
            messagebox.showerror("Erro", f"Ocorreu um erro inesperado ao criar o arquivo '{full_name}': {e}")
            return

    # Informa ao usuário que os arquivos foram criados com sucesso
    messagebox.showinfo(
        "Sucesso!",
        f"Os seguintes arquivos foram criados na pasta {saidas}:\n\n" + "\n".join(file_list)
    )
    return

def menu_relatorios(func):
    """
    Cria uma janela para seleção de arquivo e geração de relatório.
    Permite ao usuário escolher o arquivo com os dados da solução do modelo e chama a função de visualização correspondente.
    Parâmetros:
        func (str): Nome da função de visualização a ser chamada ('visualizacao_completa', 'visualizacao_curso', 'visualizacao_dep', 'planilhas_sti').
    Fluxo:
        - Abre janela para seleção do arquivo de dados.
        - Valida seleção do arquivo.
        - Gera lista de horários e salas a partir do arquivo.
        - Chama a função de visualização/exportação conforme selecionado.
        - Fecha a janela após execução.
    """
    # Cria janela secundária para seleção de arquivo e geração do relatório.
    menu = tk.Toplevel(root)
    menu.title("Visualização Completa da Solução")
    menu.geometry("+250+150")

    frame2 = tk.Frame(menu)
    frame2.pack(pady=10, padx=10)

    # Variável para armazenar o caminho do arquivo selecionado pelo usuário.
    arquivo_selecionado = tk.StringVar(value="Selecione o arquivo com os Dados da solução do Modelo")
    
    def selecionar_arquivo():
        """Abre diálogo para seleção do arquivo de dados e salva o caminho na variável."""
        arquivo = filedialog.askopenfilename(title="Selecione o arquivo com os Dados da solução do Modelo")
        if arquivo:
            arquivo_selecionado.set(arquivo)

    # Legenda e botão para seleção do arquivo de dados.
    lbl_arquivo = tk.Label(frame2, text="Selecione o arquivo com os Dados da solução do Modelo")
    lbl_arquivo.grid(row=0, column=0, pady=5, sticky='w')
    btn_selecionar_arquivo = tk.Button(frame2, textvariable=arquivo_selecionado, command=selecionar_arquivo, wraplength=250, width=40)
    btn_selecionar_arquivo.grid(row=0, column=1, padx=5, pady=5)

    def salvar_valores(func):
        """
        Valida seleção do arquivo, prepara dados e chama a função de visualização/exportação.
        - Exibe aviso se nenhum arquivo foi selecionado.
        - Gera lista de horários de 30 em 30 minutos entre 07:00 e 23:30.
        - Lê o arquivo Excel selecionado e ordena por sala.
        - Extrai lista de salas e prepara parâmetros para visualização.
        - Chama a função correspondente ao tipo de relatório.
        - Fecha a janela após execução.
        """
        # Validação da seleção do arquivo
        if not arquivo_selecionado.get() or arquivo_selecionado.get() == "Selecione o arquivo com os Dados da solução do Modelo":
            messagebox.showwarning("Aviso", "Por favor, selecione o arquivo com os Dados da solução do Modelo.")
            return

        # Gera intervalo de horários para visualização (07:00 até 23:30, de 30 em 30 minutos)
        start_time = datetime.strptime("07:00", "%H:%M")
        end_time = datetime.strptime("23:30", "%H:%M")
        horarios = []
        current_time = start_time
        while current_time <= end_time:
            horarios.append(current_time.strftime("%H:%M"))
            current_time += timedelta(minutes=30)

        # Lê o arquivo Excel selecionado
        dfv = pd.read_excel(arquivo_selecionado.get())
        # Ordena o DataFrame por sala
        dfv = dfv.sort_values(by='Sala')
        # Extrai lista de salas únicas
        salas1 = dfv['Sala'].unique().tolist()
        # Quantidade de colunas de horários
        sala_colunas = len(horarios)
        # Dias da semana para visualização
        dias_semana = ["Segunda", "Terça", "Quarta", "Quinta", "Sexta", "Sábado"]

        # Chama a função de visualização/exportação conforme parâmetro
        if func == "visualizacao_completa":
            visualizacao_completa(dfv, salas1, horarios, sala_colunas, dias_semana)
        elif func == "visualizacao_curso":
            visualizacao_curso(dfv, salas1, horarios, sala_colunas, dias_semana)
        elif func == "visualizacao_dep":
            visualizacao_dep(dfv, salas1, horarios, sala_colunas, dias_semana)
        elif func == "planilhas_sti":
            planilhas_sti(arquivo_selecionado.get())

        # Fecha a janela após execução
        menu.destroy()
    # Defino um botão e sua posição na janela para chamar a função que salva os nomes dos arquivos.
    ttk.Button(frame2, text="Gerar Visualização", command=lambda: salvar_valores(func)).grid(row=1, column=0, columnspan=2, pady=10)

    
def gerar_relatorios():
    """
    Abre uma janela secundária com opções de geração de relatórios.
    Permite ao usuário escolher entre diferentes tipos de visualização e exportação dos dados da solução do modelo.
    Cada botão chama a função correspondente para gerar o relatório desejado.
    """
    # Cria uma nova janela modal sobre a principal para o menu de relatórios.
    nova_janela = tk.Toplevel(root)
    nova_janela.geometry("+200+200")
    nova_janela.title("Menu para Geração de Relatórios")

    # Frame para organizar os botões de relatório.
    frame = tk.Frame(nova_janela)
    frame.pack(pady=10, padx=10)

    # Botão para gerar relatório de espaços livres após alocação do modelo.
    ttk.Button(frame, text="Relatório de Espaços Livres", command=analise_vazios).grid(column=0, row=0, sticky="w", pady=5)
    # Botão para visualização completa da solução (por sala e horário).
    ttk.Button(frame, text="Visualização Completa da Solução", command=lambda: menu_relatorios(func="visualizacao_completa")).grid(column=0, row=1, sticky="w", pady=5)
    # Botão para visualização por curso (aba para cada currículo).
    ttk.Button(frame, text="Visualização por Curso", command=lambda: menu_relatorios(func="visualizacao_curso")).grid(column=0, row=2, sticky="w", pady=5)
    # Botão para visualização por departamento (aba para cada departamento).
    ttk.Button(frame, text="Visualização por Departamento", command=lambda: menu_relatorios(func="visualizacao_dep")).grid(column=0, row=3, sticky="w", pady=5)
    # Botão para exportar planilhas no formato exigido pela intranet/STI.
    ttk.Button(frame, text="Gerar Planilhas para a Intranet", command=lambda: menu_relatorios(func="planilhas_sti")).grid(column=0, row=4, sticky="w", pady=5)



"""
# Bloco principal da interface gráfica
# Inicializa a janela principal, cria pastas de saída e define os botões de ação.
# Cada botão chama uma função específica para manipulação ou visualização dos dados.
"""

# Nome da pasta de saída principal
nome_pasta = "Saídas da Interface"
# Caminho completo da pasta de saída
caminho_pasta = os.path.join(os.getcwd(), nome_pasta)
# Cria a pasta principal se não existir
if not os.path.exists(caminho_pasta):
    os.makedirs(caminho_pasta)
# Caminho da pasta principal
pasta_principal = os.path.join(os.getcwd(), "Saídas da Interface")
# Subpastas para organizar os arquivos gerados
subpastas = ["Planilhas de Dados", "Saídas do Modelo"]
# Cria cada subpasta dentro da pasta principal
for nome in subpastas:
    caminho_subpasta = os.path.join(pasta_principal, nome)
    if not os.path.exists(caminho_subpasta):
        os.makedirs(caminho_subpasta)
# Caminho para salvar planilhas de dados
saidas = os.path.join(os.getcwd(), "Saídas da Interface", "Planilhas de Dados")

# Inicializa a janela principal da interface gráfica
root = tk.Tk()
root.title("Menu Principal")
# Frame principal para os botões de ação
frm = ttk.Frame(root, padding=10)
frm.grid()

# Botão para construir planilha com dados das aulas (base principal)
ttk.Button(frm, text="Construir Planilha com os dados das Aulas", command=lambda: planilha_dep(jupiter=False)).grid(column=0, row=0, sticky="w", pady=5)
# Botão para construir planilha com dados do JúpiterWeb
ttk.Button(frm, text="Construir Planilha com os dados do JúpiterWeb", command=lambda: planilha_dep(jupiter=True)).grid(column=0, row=1, sticky="w", pady=5)
# Botão para construir base de dados do modelo (caso padrão)
ttk.Button(frm, text="Construir Base de Dados do Modelo", command=lambda: base_dados(pior_caso=False)).grid(column=0,row=2,sticky="w", pady=5)
# Botão para construir base de dados de pior caso
ttk.Button(frm, text="Construir Base de Dados de Pior Caso", command=lambda: base_dados(pior_caso=True)).grid(column=0,row=3,sticky="w", pady=5)
# Botão para verificar dados e executar o modelo
ttk.Button(frm, text="Verificar Dados e Executar Modelo", command=execute).grid(column=0,row=4,sticky="w", pady=5)
# Botão para abrir o menu de geração de relatórios
ttk.Button(frm, text="Gerar Relatórios", command=gerar_relatorios).grid(column=0,row=5,sticky="w",pady=5)
# Botão para preencher planilhas com dados da solução do modelo
ttk.Button(frm, text="Preencher planilhas com Dados da Solução", command=preencher_planilha_dados).grid(column=0, row=6, sticky="w", pady=5)
# Botão para sair da interface
ttk.Button(frm, text="Sair", command=root.destroy).grid(column=0, row=7, sticky="w", pady=5)

# Inicia o loop principal da interface gráfica
root.mainloop()

