# -*- coding: utf-8 -*-
"""Modelo 4.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1fA3THXK_UckcmPRFI-r7EXJ5KMl7VmQz

## Import das bibliotecas
"""

# !pip install mip
# Imports das bibliotecas e funções utilizadas
import pandas as pd # Leitura de dados
import time # Cálculo de tempo
from mip import Model, xsum, minimize, BINARY, INTEGER, CONTINUOUS, OptimizationStatus # Biblioteca com linguagem de modelagem
import re
import os
import sys # Implementação de saídas de erro
import traceback # Implementação de inspeção para auxiliar nas saídas de erro.
from itertools import permutations # Função para criar uma lista de permutações
from datetime import datetime, timedelta # Funções para a leitura de horários de aula
import openpyxl # Biblioteca para a elaboração de planilhas mais detalhadas
# Métodos e funções para auxiliar na criação de planilhas mais elaboradas
from openpyxl import Workbook
from openpyxl.styles import PatternFill, Alignment, Border, Side
from openpyxl.utils import get_column_letter
from openpyxl import load_workbook
from openpyxl.formatting.rule import DataBar, FormatObject, Rule

"""## Leitura dos dados"""

sheets = ["SME", "SMA", "SCC", "SSC", "Outros"] # Planilhas a serem lidas no arquivo com os dados de cada departamento
# sheet_names = df_completo.sheet_names
# Diferentes arquivos de teste que foram utilizados
# file_path = 'C:/Users/gabri/Estágio/Dados/Dados_das_salas_copia.xlsx'
# file_path = 'C:/Users/gabri/Estágio/Dados/Dados_das_salas_atualizado_copia.xlsx'
# file_path = 'C:/Users/gabri/Estágio/Dados/Dados_das_salas_atualizado_copia_com_fixadas.xlsx'
# file_path = 'C:/Users/gabri/Estágio/Dados/Dados das salas semigual ao 202401.xlsx'
# file_path = 'C:/Users/gabri/Estágio/Dados/Dados das salas 2025 copia.xlsx'
# file_path = 'C:/Users/gabri/Estágio/Dados/Dados das salas 2025 pior caso.xlsx'
file_path = sys.argv[1]

# Criação e mescla do dataframe (dados das aulas)
df = pd.read_excel(file_path, sheet_name=sheets)

# df = pd.read_excel(file_path, sheet_name=sheet_names[1:])
df = pd.concat(df.values(), ignore_index=True)

# print(df)
# Dataframe com os dados das salas
salas = pd.read_excel(file_path, sheet_name="Salas")
# print(salas)
# Lista da capacidade de cada sala do dataframe
cap_s = salas['Lugares'].tolist()
# print(cap_s)
# Lista do tamanho de cada disciplina (número de inscritos)
tam_t = df['Vagas por disciplina'].tolist()
# print(tam_t)

print('Base de Dados lida.')

"""## Tratamento dos Dados"""

# Função para converter horário no formato 'HH:MM' para valor decimal em horas
def horario_para_decimal(horario):
    # Se, por algum acaso, houver um horário definido como 20h40, ele é convertido para 20:40
    if 'h' in horario:
        horario = horario.replace('h',':')
    # Separo e identifico os componentes daquele horário, ou seja, salvo o valor de horas e o de minutos
    horas, minutos = map(int, horario.split(':'))
    # Retorno um valor numérico daquele horário seguindo a ideia de "porcentagem" de hora.
    # Ex: 40 minutos são dois terços de uma hora (40/60 = 2/3), logo, 20:40 pode ser traduzido como 20 + 40/60 = 20.67
    return horas + minutos / 60

# Função para processar a célula no formato 'Dia - HH:MM/HH:MM'
def processar_horario(celula):
#     print(celula)
    # Verifico se a célula que está sendo analisada possui um horário definido (se há algo escrito nela e separado por um traço "-")
    if isinstance(celula, str) and "-" in celula:
        # Deleto qualquer espaço " " da célula para garantir uma leitura organizada,
        # já que algumas vezes pode haver mais de um espaço, ou a ausência dos mesmos
        celula = str(celula).replace(' ', '')
        # print(celula)
        # Separo e salvo o dia da semana o qual a aula é dada, e o horário do dia que ela é ministrada
        dia, horarios = celula.split('-')
        # Separo o horário de início e de término daquela aula
        inicio, fim = horarios.split('/')
        # Salvo o horário do ínicio e do fim daquela aula
        start_a = horario_para_decimal(inicio)
        end_a = horario_para_decimal(fim)
        # Retorno o dia e os horários daquela aula
        return dia, start_a, end_a
    else:
        # Se a célula é vazia ou não possui o traço "-", é uma célula irregular com horário não definido, logo, retorno valor 0
        return 0, 0, 0

# Lista das colunas de horários
colunas_horarios = ['Horário 1', 'Horário 2', 'Horário 3', 'Horário 4']
result = []
# Processar cada coluna de horários
# Para cada coluna de horários
for coluna in colunas_horarios:
    # Aplico o processamento e tradução do horário
    resultados = df[coluna].apply(processar_horario).to_list()
    # Adiciono numa lista os horários traduzidos de cada coluna
    result.extend(resultados)

# Crio um dataframe com os dados padronizados de todas as aulas
A = pd.DataFrame(result, columns=['Dia', 'start_a', 'end_a'])
# Salvo as colunas do dataframe em listas separadas
dia_a = A['Dia'].to_list()
start_a = A['start_a'].to_list()
end_a = A['end_a'].to_list()
# print(A)
# print(len(A))
# print(start_a)

# Para cada célula vazia na coluna 'Sala' do dataframe principal, eu coloco o valor da célula como 0
for s in range(len(df['Sala'])):
    if pd.isna(df.loc[s, 'Sala']):
        df.loc[s, 'Sala'] = 0

# if sys.argv[7]:
#     # Variável com o número suposto de alunos da pós.
#     qtd_pos = int(sys.argv[7])
#     for d in range(len(tam_t)):
#         # print(f"Valor de tam_t: {tam_t[d]}")
#         # print(f"Valor do dataframe: {df.loc[d, 'Vagas por disciplina']}")
#         if not pd.isna(df.loc[d, 'Observações']):
#             if 'Espelho' in df.loc[d, 'Observações'] or 'espelho' in df.loc[d, 'Observações']:
#                 print(
#                     f"Número de inscritos na disciplina {df.loc[d, 'Disciplina (código)']} (espelhada com a pós): {df.loc[d, 'Vagas por disciplina']}"
#                     f"\nAdicionando número de inscritos da pós fornecido pelo usuário."
#                 )
#                 # print(df.loc[d, 'Vagas por disciplina'])
#                 # print(tam_t[d])
#                 tam_t[d] += qtd_pos
#                 df.loc[d, 'Vagas por disciplina'] += qtd_pos
#                 print(
#                     f"Número de inscritos na disciplina {df.loc[d, 'Disciplina (código)']} (espelhada com a pós): {df.loc[d, 'Vagas por disciplina']}"
#                 )
#             # print(tam_t[d])

for d in range(len(tam_t)):
    if pd.isna(df.loc[d, 'Turma']):
        df.loc[d, 'Turma'] = 1

"""## Dados de Entrada"""

# Faço uma lista de índices de cada turma/disciplina do dataframe principal, então a primeira disciplina é 0, a segunda 1, etc.
T = range(len(df['Disciplina (código)']))
# print(T[38]) # retorna um índice que equivale à posição de uma disciplina na lista
# print(df['Disciplina (código)'][T[38]]) # retorna a sigla da disciplina (o índice equivale a linha - 2)

# Faço uma lista de índices de cada sala do dataframe principal, então a primeira sala é 0, a segunda 1, etc.
S = range(len(salas['Sala']))
# print(salas['Sala'][S[2]]) # retorna uma sala

# Faço uma lista de quais salas são de laboratório (salvo como índices)
sigma_s = [1 if salas['Laboratório'][s] == 'Sim' else 0 for s in S]
# print(sigma_s) # sigma_s = 1 se a sala s eh de laboratório

# Faço uma lista de quais turmas/disciplinas requisitaram aula em laboratório
tal_t = [0 if df['Utilizará laboratório? (sim ou não)'][t] == 'Não' else 1 for t in T]
# print(tal_t) # tal_t = 1 se a turma/disciplina t precisar de laboratório

# Para não precisar chamar o mesmo método que calcula o comprimento das listas mais importantes, eu salvo eles em variáveis
lenT = len(T)
lenA = len(A)
lenS = len(S)

# Lista dos cursos, ou currículos, do ICMC
curriculos = ['BMACC', 'BMA', 'LMA', 'MAT-NG', 'BECD', 'BCC', 'BSI', 'BCDados']
# Faço o mesmo esquema de salvar o comprimento da lista de cursos
lenC = len(curriculos)
# Crio uma dicionário em formato de matriz para identificar quais turmas/disciplinas são ministradas para cada curso do instituto
# Inicio todos os valores da matriz como 0 para atualizá-los
Y_tc = {(t,c): 0 for t in range(lenT) for c in range(lenC)}
# Para cada turma/disciplina
for t in range(lenT):
    # Analiso a célula de curso daquela turma/disciplina
    celula = df.loc[t, 'Curso(s)']
    # Se houver uma vírgula na célula, provavelmente é por ter mais de um curso que possui essa turma/disciplina
    if ',' in celula:
        # print(df['Curso(s)'][int(a % lenT)].split(', '))
        # Para cada ', ' na célula, esperasse que haja um outro curso, ou seja, se a célula for 'BMACC, BMA, LMA',
        # o valor da variável 'c' será 'BMACC', 'BMA' e 'LMA'
        for c in celula.split(', '):
            # Se aquela curso está na lista dos cursos do instituto
            if c in curriculos:
                # Altero o valor da minha matriz, identificando que aquela turma/disciplina é ministrada para algum curso do ICMC
                Y_tc.update({(t,curriculos.index(c)): 1})
    else:
        # Se há um único curso para o qual aquela turma/disciplina é ministrada, verifico se é um dos cursos do ICMC
        if celula in curriculos:
            # Altero o valor da minha matriz, identificando que aquela turma/disciplina é ministrada para algum curso do ICMC
            Y_tc.update({(t,curriculos.index(celula)): 1})

# print(Y_tc)

"""## Dados de Preprocessamento"""

# A variável A_t é uma lista onde cada elemento é uma lista dos índices das aulas de uma determinada turma/disciplina
# Ex: Se A_t[0] é dada por [0, 1, 2], então as aulas 0, 1 e 2 são da turma/disciplina 0
A_t = []
# Para cada turma/disciplina
for t in range(lenT):
    # Adiciono uma lista com os índices de cada aula daquela turma/disciplina
    # O cálculo feito trabalha no fato de que lenA = n * lenT, pois lenT é o número de turmas/disciplinas,
    # e LenA é o número de turmas/disciplinas multiplicado pelo número de colunas de horários.
    # Ex: Suponha que tenhamos 4 colunas de horário e 4 turmas/disciplinas, então lenT = 4, lenA = 16, lenA/lenT = 4
    # O incremento de i garante que vamos obter sempre o índice da mesma aula. Definindo a primeira turma/disciplina do nosso exemplo como 1,
    # a próxima aula dessa turma/disciplina é a 5 = 1 + 4 = t + 1*lenT, a terceira seria a 9 = 1 + 8 = t + 2 * lenT
    A_t.append([t + (i * lenT) for i in range(int(lenA/lenT))])
# print(A_t) # lista de listas
# print(A_t[0]) # uma lista específica
# print(A_t[0][1]) # um termo de uma lista específica

# A variável A_tt segue a mesma ideia de A_t, com a diferença de que as listas de A_tt não incluem os índices das aulas sem horário definido
A_tt = [[a for a in A_t[t] if start_a[a] != 0] for t in range(lenT)]
# print(A_tt)

# A variável A_s é uma lista onde cada elemento é uma lista de aulas de uma mesma turma/disciplina que são seguidas uma da outra
# Ex: se uma turma/disciplina possui uma aula na segunda das 10:10 às 11:50 e outra das 14:20 às 16:00, os índices dessas aulas estão juntos
# em uma lista de A_s, e essa será usada para garantir que ambas estejam na mesma sala
# Uma importante suposição ao criar essa lista é que não existem turmas/disciplinas com três aulas seguidas em um mesmo dia
A_s = []
# Para cada turma/disciplina de A_t (assumindo que, no máximo, existam turmas/disciplinas com duas aulas seguidas)
for t in A_t:
    # Se o dia das aulas é o mesmo, e é diferente de 0, ou seja, está definido
    if dia_a[t[0]] == dia_a[t[1]] and dia_a[t[0]] != 0:
        # Verifico se o fim da primeira aula somado a um intervalo é maior que o começo da segunda aula
        # Ex: Usando o exemplo anterior, o fim da primeira aula é às 11:50, que é traduzido para 11.83.
        # 11.83 + 2 + 0.17 + 0.33 = 14.33, que é o valor traduzido do ínicio da segunda aula dado por 14:20
        # Ex: Se, ao invés disso, fossem duas aulas no horário da manhã, teríamos 9.83 (valor traduzido de 09:50) como fim da primeira aula,
        # logo, 9.83 + 2 + 0.17 + 0.33 = 12.33, que é maior que 10.17 (valor traduzido de 10:10, o início da segunda aula)
        # Os valores desta soma levam em conta as 2 horas e meia entre 11:50 e 14:20, o maior intervalo de tempo entre duas aulas seguidas
        if end_a[t[0]] + 2 + 10/60 + 20/60 >= start_a[t[1]]:
            # Sabendo que as aulas são seguidas, faço uma lista com as aulas que possuem horário definido
            seguido = [x for x in t if start_a[x] != 0]
#         print(seguido)
            # Se a lista possui mais de um horário, então é uma lista com o índice de duas aulas que são seguidas uma da outra
            if len(seguido) > 1:
                # Portanto, adiciono essa lista em A_s
                A_s.append(seguido)

# print("A_s =", A_s)

# A variável A_c é uma lista onde cada elemento é uma lista das turmas/disciplinas que são ministradas para um determinado curso 'c' do instituto.
A_c = []
for c in range(lenC):
    # A ideia é semelhante à criação das listas anteriores, utilizando uma conta "esperta" para simbolizar o índice correto,
    # com a condição de colocar na lista as turmas/disciplinas corretas (Y_tc = 1).
    A_c.append([t + (i * lenT) for i in range(int(lenA/lenT)) for t in range(lenT) if Y_tc[t,c] == 1])

# print("A_c =", A_c[0])

# A variável eta_as é um dicionário em formato de matriz para identificar quais aulas cabem em determinadas salas, ou seja
# eta_as = 1 se a sala s pode alocar a aula a, e é 0 caso contrário
# O cálculo usando 'a % lenT' retorna um valor que varia traduz para um índice da turma/disciplina a qual a aula 'a' pertence
# Ex: se lenT = 4, temos que 0 % 4 = 0; 1 % 4 = 1; 2 % 4 = 2; 3 % 4 = 3; 4 % 4 = 0, 5 % 4 = 1; ...
# Logo, como imaginamos, a quinta aula (índice 4, já que começamos do 0) deveria pertencer a turma/disciplina 0, e, de fato,
# 0 % 4 = 4 % 4 = 0
eta_as = {(a, s): 1 if tam_t[int((a % lenT ))] <= cap_s[s] \
          else 0 for a in range(lenA) for s in range(lenS)}
# print(eta_as) # dicionário com pares (a,s) com valor 1 se s consegue alocar a aula a
# print(eta_as[2,8]) # valor específico de um par

# A variável theta_aal é um dicionário em formato de matriz para identificar quais aulas possuem conflito de horário, ou seja,
# theta_aal = 1 quando as aulas 'a' e 'al' possuem conflito de horário
# O conflito é detectado quando, para o mesmo dia, o ínicio da aula 'a' é estritamente menor que o fim da aula 'al'
# ao mesmo tempo que o início de 'al' é estritamente menor que o final de 'a'
# Ex: Uma aula 'a' dada de segunda das 14:20 até às 17:10 e outra 'al' dada na segunda das 16:20 às 18:00 obviamente têm conflito de horário
# Utilizando os valores traduzidos, podemos verificar que 14.33 < 18 e 16.33 < 17.17
# Agora, se 'a' fosse das 14:20 às 16:00, teríamos ainda que 14.33 < 18, mas teríamos que 16.33 > 16, logo, não é considerado conflito
theta_aal = {(a, al): 1 if (dia_a[a] == dia_a[al] and (start_a[a] < end_a[al] and start_a[al] < end_a[a])) \
             else 0 for a in range(lenA) for al in range(lenA)}

# print(theta_aal)

# A variável uso_as é um dicionário em formato de matriz para contabilizar o quanto de espaço vazio uma aula deixa em uma determinada sala
# Ex: se uma aula 'a' tem 30 alunos, ela ocupa 67% de uma sala 's' com 45 lugares (deixando 33% da sala vazia),
# mas 100% de uma sala 's' com 30 lugares (deixando 0% da sala vazia). Quando menor o valor de uso_as, melhor.
uso_as = {(a, s): 100 * (1 - (tam_t[int((a % lenT))]/cap_s[s])) for a in range(lenA) for s in range(lenS)}

# print(uso_as)

# A variável dis é um dicionário em formato de matriz para contabilizar a distância (arbitrária) de ir de uma sala 's' até uma sala 'sl'.
# Ex: A distância de uma sala do bloco 3 até uma sala do bloco 5 é de 6 unidades de distância, enquanto a distância de uma sala do bloco 3
# até uma sala do bloco 4 é de 1 unidade de distância.

# dis = {(s, sl): salas.iloc[s, sl+3] for s in range(salas.shape[0]) for sl in range(salas.shape[1]-3)}
dis = {(s, sl): salas.loc[s, sl] for s in range(len(salas)) for sl in salas.columns[3:-1]}
# print("dis =", dis)

pref = salas['Preferencialmente Vazia'].tolist()

"""## Dados para fixar os laboratórios e aulas com sala definida, como LEM"""

# A variável labs é uma lista com todas as turmas/disciplinas que precisam de laboratório, identificadas pela lista tal_t
# Conceitualmente, para os laboratórios, essa lista é como se fosse o T
labs = [t for t in T if tal_t[t] == 1]
# print(labs) # retorna o índice da disciplina

# A variável salas_labs é uma lista das salas de laboratório
# Conceitualmente, para os laboratórios, essa lista é como se fosse o S
salas_labs = [i for i in range(len(salas['Laboratório'])) if salas.loc[i, 'Laboratório'] == "Sim"]
# print(salas_labs)

# A variável ind_labs é uma lista que indica quais aulas de uma turma/disciplina deverá ser em um laboratório
# Ex: Se a terceira aula da disciplina de laboratório 0 é a de laboratório, então o primeiro elemento de ind_labs
# seria uma lista com apenas o índice 3. Caso a primeira e segunda aula da disciplina de laboratório 0 fossem de laboratório,
# então o primeiro elemento de ind_labs seria a lista [1,2]
ind_labs = []
# Para cada turma/disciplina que precisa de uma sala de laboratório disponível
for l in labs:
    # Adiciono os valores da célula separados por vírgula, ou seja, se na célula está escrito 'Sim,1,2',
    # a lista adicionada é ['Sim', '1', '2']
    ind_labs.append(df.loc[l, 'Utilizará laboratório? (sim ou não)'].split(','))
    # Removo o 'Sim' da última lista adicionada, então no nosso exemplo, a lista adicionada agora é dada por ['1', '2']
    ind_labs[-1].remove("Sim")
    # Por fim, converto os elementos dessa lista para serem valores inteiros
    ind_labs[-1] = [int(item) for item in ind_labs[-1]]

# print(ind_labs) # lista de listas, pra saber os horários de cada disciplina

# A variável aula_labs é uma lista com os índices de todas as aulas que devem ser ministradas em laboratório
aula_labs = [(labs[t] + (lenT * (i-1))) for t in range(len(labs)) for i in ind_labs[t]]
# print(aula_labs)

# A variável lab_tal é uma lista que funciona da mesma forma que a variável tal_t, mas usando o índice da aula, e não o da turma/disciplina
# Defino todos os seus valores como 0 inicialmente, ou seja, admito que todas as aulas não são de laboratório
lab_tal = [0 for _ in range(lenA)]
# Para cada aula que é de laboratório, altero o índice dela para 1 em lab_tal
for a in aula_labs:
    lab_tal[a] = 1

# print(lab_tal)

# A variável sala_fixa é uma lista de 1's e 0's, onde cada elemento dela remete ao índice de uma aula. Se o i-ésimo termo da lista é 1,
# então a i-ésima aula possui uma sala fixada. Se o valor é 0, ela não possui sala fixada
# Ex: Se a aula 37 possui uma sala fixa, então sala_fixa[37] = 1 (lembrando do uso da aula 0 neste caso)
# sala_fixa = [1 if (df.loc[a % lenT, 'Sala'] != 0 and start_a[a] != 0) else 0 for a in range(lenA)]
sala_fixa = []
for a in range(lenA):
    sala_valor = str(int(df.loc[a % lenT, 'Sala']))
    if ', ' in sala_valor:
        if not pd.isna(df.loc[int(a / lenT), 'Horário ' + str(int(a / lenT) + 1)]):
            if len(sala_valor.split(', ')) >= (int(a / lenT) + 1):
                sala_fixa.append(sala_valor.split(', ')[int(a / lenT)])
            else:
                sala_fixa.append('0')
            # sala_fixa.append(sala_valor.split(', ')[int(a / lenT)])
    elif not pd.isna(df.loc[int(a / lenT), 'Horário ' + str(int(a / lenT) + 1)]):
        sala_fixa.append(sala_valor)
    else:
        sala_fixa.append('0')
# print(sala_fixa)

sala_proibida = {}
for a in range(lenA):
    
    if not pd.isna(df.loc[int(a % lenT), 'Proibir Horário ' + str(int(a / lenT) + 1)]):

        cell = str(df.loc[int(a % lenT), 'Proibir Horário ' + str(int(a / lenT) + 1)])
        
        if ',' in cell:
            sala_proibida.update({a : cell.split(', ')})
            for sala in cell.split(', '):
                s = salas[salas['Sala'] == sala].index[0]
                eta_as[a,s] = 0
        else:
            sala_proibida.update({a : cell})
            s = salas[salas['Sala'] == cell].index[0]
            eta_as[a,s] = 0
        


"""## Modelo Principal"""

# Criação do Modelo.
model = Model("Alocação de aulas", solver_name="CBC")

# Variáveis de decisão.
# x_as é uma variável binário que ganha o valor 1 se a aula 'a' é alocada à sala 's', e ganha o valor 0 no caso contrário.
# Ela está na forma de um dicionário na forma de matriz para facilitar o código, simulando uma matriz de variáveis x00, x01, x02,..., xnm.
x_as = {(a, s): model.add_var(var_type=BINARY) for a in range(lenA) for s in range(lenS)}
# A variável peso_x é o quanto a variável x_as afeta o modelo, ou seja, o valor de peso_x descreve a importância de x_as no modelo.
peso_x = int(sys.argv[2])


# y_t é uma variável inteira que contabiliza o número de trocas de sala de uma turma/disciplina.
# Ex: Se há uma disciplina com três aulas na semana, todas em salas diferentes, então y_t teria o valor 2 (já que houveram duas trocas).
# Ela está na forma de uma lista para facilitar o código, simulando um vetor de variáveis y0, y1, y2,..., yt.
y_t = [model.add_var(var_type=INTEGER, lb=0) for t in range(len(T))]
# A variável peso_y é o quanto a variável y_t afeta o modelo, ou seja, o valor de peso_y descreve a importância de y_t no modelo.
peso_y = int(sys.argv[3])

# c_st é uma variável binária que ganha o valor 1 se a sala 's' é utilizada pela turma/disciplina 't', e ganha o valor 0 no caso contrário.
# Como a variável x_as, o uso do dicionário na forma de matriz é para facilitar o código, simulando uma matriz de variáveis c00, c01,..., cmt.
# Caso esta variável esteja sendo usada, a interpretação de y_t é alterada para ser o número de salas usadas pela turma/disciplina 't'.
c_st = {(s, t): model.add_var(var_type=BINARY) for s in range(lenS) for t in range(lenT)}

obj = peso_x * xsum(uso_as[a,s] * x_as[a,s] for a in range(lenA) for s in range(lenS)) + peso_y*xsum(y_t[t] for t in range(lenT))

if sys.argv[4]:
    # w_cs é uma variável binária que ganha o valor 1 se o curso 'c' tem ao menos uma aula na sala 's', e ganha 0 caso contrário.
    # Ela está na forma de um dicionário na forma de matriz para facilitar o código, simulando uma matriz de variáveis w00, w01,...,wkm
    w_cs = {(c, s): model.add_var(var_type=BINARY) for c in range(lenC) for s in range(lenS)}
    
    
    # v_cssl é uma variável binária que ganha o valor 1 se o curso 'c' tem ao menos uma aula na sala 's' e na sala 'sl', e ganha 0 caso contrário.
    # Ela está na forma de um dicionário na forma de uma matriz tridimensional para facilitar o código, simulando uma matriz de variáveis
    # v000, v001,..., v00m, v010, v011,..., vkmm
    v_cssl = {(c, s, sl): model.add_var(var_type=BINARY) for c in range(lenC) for s in range(lenS) for sl in range(lenS) if s != sl}
    # A variável peso_v é o quanto a variável v_cssl afeta o modelo, ou seja, o valor de peso_v descreve a importância de v_cssl no modelo.
    peso_v = int(sys.argv[4])

    obj += peso_v * xsum(dis[s,sl] * v_cssl[c,s,sl] for c in range(lenC) for s in range(lenS) for sl in range(lenS) if s != sl)
if sys.argv[5] and sys.argv[6]:
    # Variável de superlotação.
    # z_as é uma variável binária que ganha o valor 1 se a aula 'a', ao ser alocada à sala 's', ultrapassa uma certa quantia do espaço.
    # Ex: Se o fator de superlotação for 0.85, então a variável ganhará o valor 1 se a aula 'a' ocupar mais de 85% do espaço disponível da sala 's'.
    # Essa variável possui dois propósitos: acomodar melhor uma aula para melhorar o conforto dos alunos, e considerar o possível
    # aumento de inscritos na segunda interação de matrícula e no período de requerimento.
    z_as = {(a, s): model.add_var(var_type=BINARY) for a in range(lenA) for s in range(lenS)}
    # A variável peso_z é o quanto a variável z_as afeta o modelo, ou seja, o valor de peso_z descreve a importância de z_as no modelo.
    peso_z = int(sys.argv[5])
    alpha = float(sys.argv[6])

    obj += peso_z * xsum(z_as[a, s] for a in range(lenA) for s in range(lenS))
if sys.argv[7]:
    peso_pref = int(sys.argv[7])

    obj += peso_pref * xsum(pref[s] * x_as[a,s] for a in range(lenA) for s in range(lenS))
# Função Objetivo.
# Queremos minimizar o espaço vazio das salas, descrito pela somatória de (uso_as * x_as), que contabiliza o uso da sala 's' pela aula 'a'.
# Além disso, queremos também minimizar o número de trocas de sala, descrito pela somatória de y_t, que contabiliza
# quantas trocas de sala foram feitas pela turma/disciplina 't'.
# Caso a variável c_st esteja sendo usada, por ela ser uma variável de "verificação", ela não precisa ser contabilizada na função objetivo.
# Caso a variável c_st esteja sendo usada, a interpretação de y_t muda, mas sua influência na função objetivo não é alterada.
# Pelo mesmo motivo de c_st não estar contabilizada na função objetivo, a variável w_cs também não está.
# model.objective = minimize(peso_x * xsum(uso_as[a,s] * x_as[a,s] for a in range(lenA) for s in range(lenS)) + \
#                            peso_v * xsum(dis[s,sl] * v_cssl[c,s,sl] for c in range(lenC) for s in range(lenS) for sl in range(lenS) if s != sl) + \
#                            peso_z * xsum(z_as[a, s] for a in range(lenA) for s in range(lenS)) + \
#                            peso_pref * xsum(pref[s] * x_as[a,s] for a in range(lenA) for s in range(lenS)) + \
#                           peso_y*xsum(y_t[t] for t in range(lenT)))
model.objective = minimize(obj)



# Restrições
# Para toda aula que não tem um horário ou número de matriculados definido, faço com que ela não seja alocada em nenhuma sala.
for a in range(lenA):
    if start_a[a] == 0 or tam_t[a % lenT] == 0:
        model += xsum(x_as[a,s] for s in range(lenS)) == 0

# Para toda aula que tem um horário e número de matriculados definido, faço com que ela seja alocada em alguma sala.
for a in range(lenA):
    if start_a[a] != 0 and tam_t[a % lenT] != 0:
        # Se a aula possuir uma sala fixada, garanto que ela será fixada naquela sala.
        if sala_fixa[a] != '0':
            # A variável fixa possui o valor da sala onde a sala 'a' está fixada.
            # if ', ' in df.loc[a % lenT, 'Sala']:
            #     fixa = df.loc[a % lenT, 'Sala'].split(', ')
            # fixa = df.loc[a % lenT, 'Sala']
            # # Caso a aula seja ministrada no LEM, eu a desconsidero do modelo, atribuindo o valor 0 para a variável em todas as salas.
            # if fixa == '6-307':
            #     model += xsum(x_as[a,s] for s in range(lenS)) == 0
            # # Caso contrário ela esteja fixada em uma sala comum.
            # else:
            #     s = salas['Sala'].tolist().index(fixa)
            #     # Garanto que a aula 'a' poderá ser alocada em apenas uma sala entre todas as disponíveis.
            #     model += xsum(x_as[a,s] for s in range(lenS)) == 1
            #     # E garanto que a sala alocada pela aula 'a' é a que ela está fixada.
            #     model += x_as[a,s] == 1
            model += xsum(x_as[a,s] for s in range(lenS)) == 1
            aux_s = salas['Sala'].tolist().index(sala_fixa[a])
            model += x_as[a,aux_s] == 1
        # Se a aula 'a' não está fixada em uma sala, verifico se ela é de laboratório.
        elif lab_tal[a] == 0: # Se a aula não é de laboratório, garanto que ela não seja alocada em um laboratório.
            # Garanto que a aula 'a' poderá ser alocada em apenas uma sala entre todas as disponíveis.
            model += xsum(x_as[a,s] for s in range(lenS)) == 1
            # E garanto que a aula 'a' não poderá ser alocada em nenhuma sala de laboratório.
            model += xsum(x_as[a,s] for s in salas_labs) == 0
        else: # Se ela é de laboratório, garanto que ela só pode ser alocada em um laboratório
            # Garanto que a aula 'a' poderá ser alocada em alguma sala de laboratório.
            model += xsum(x_as[a,s] for s in salas_labs) == 1
            # E garanto que a aula 'a' poderá ser alocada em apenas uma sala entre todas as disponíveis.
            model += xsum(x_as[a,s] for s in range(lenS)) == 1

        # if a in sala_proibida.keys():
        #     proibir_sala = sala_proibida.get(a)
        #     print(proibir_sala)
        #     if len(proibir_sala) > 1:
        #         # proibir_sala = proibir_sala.split(', ')
        #         aux_s = [salas['Sala'].tolist().index(proibir_sala[s]) for s in range(len(proibir_sala))]
        #         model += xsum(x_as[a,s] for s in aux_s) == 0
        #     else:
        #         s = salas['Sala'].tolist().index(proibir_sala)
        #         model += x_as[a,s] == 0
                
            # print(proibir_sala)
            # aux_s = [salas['Sala'].tolist().index(proibir_sala[s]) for s in range(len(proibir_sala))]
            # model += xsum(x_as[a,s] for s in aux_s) == 0


# (3.3) - A sala precisa ser capaz de receber todos os inscritos da aula.
# Essa restrição garante que uma aula 'a' só pode ser alocada em uma sala 's' que consegue suportá-la, e isso é verificado
# utilizando a variável eta_as, que possui o valor 1 se 's' suporta 'a', e 0 caso contrário.
# Para toda aula 'a'.
for a in range(lenA):
    # Para toda aula 's'.
    for s in range(lenS):
        # Garanto que a aula 'a' deva ser alocada em uma sala 's' que a suporta.
        model += x_as[a,s] <= eta_as[a,s]

# (3.4) - Aulas de mesmo horário não podem estar alocadas na mesma sala
# Essa restrição garante que as aulas com conflito de horário sejam alocadas em salas diferentes.
# Para cada sala 'a'.
for a in range(lenA):
    # Para cada sala 'al'.
    for al in range(lenA):
        # Verifico se as aulas 'a' e 'al' possuem conflito de horário.
        if theta_aal[a, al] == 1:
            # Se elas possuem conflito de horário, então garanto que as duas não possam ser alocadas para a mesma sala.
            for s in range(lenS):
                model += x_as[a,s] + x_as[al,s] <= 1
            # Caso ambas as disciplinas sejam de laboratório, também é necessário considerar o conflito de horários entre as
            # salas de laboratório que podem ser conjuntas, isto é, se uma aula for alocada na sala 6-303, ela terá que exibir
            # conflito com uma aula que acontece no mesmo horário nas salas 6-303/6-304
            if lab_tal[a] == 1 and lab_tal[al] == 1:
                # Restringe alocação envolvendo salas conjuntas.
                # Se uma aula está em 6-303 ou 6-304, a outra não pode estar em 6-303/6-304.
                model += x_as[a, salas['Sala'].to_list().index('6-303/6-304')] + \
                x_as[al, salas['Sala'].to_list().index('6-303')] <= 1
                model += x_as[a, salas['Sala'].to_list().index('6-303/6-304')] + \
                x_as[al, salas['Sala'].to_list().index('6-304')] <= 1
                model += x_as[al, salas['Sala'].to_list().index('6-303/6-304')] + \
                x_as[a, salas['Sala'].to_list().index('6-303')] <= 1
                model += x_as[al, salas['Sala'].to_list().index('6-303/6-304')] + \
                x_as[a, salas['Sala'].to_list().index('6-304')] <= 1

                # Restringe alocação envolvendo salas conjuntas.
                # Se uma aula está em 6-305 ou 6-306, a outra não pode estar em 6-305/6-306.
                model += x_as[a, salas['Sala'].to_list().index('6-305/6-306')] + \
                x_as[al, salas['Sala'].to_list().index('6-305')] <= 1
                model += x_as[a, salas['Sala'].to_list().index('6-305/6-306')] + \
                x_as[al, salas['Sala'].to_list().index('6-306')] <= 1
                model += x_as[al, salas['Sala'].to_list().index('6-305/6-306')] + \
                x_as[a, salas['Sala'].to_list().index('6-305')] <= 1
                model += x_as[al, salas['Sala'].to_list().index('6-305/6-306')] + \
                x_as[a, salas['Sala'].to_list().index('6-306')] <= 1

# nr = 0
# (3.5) - Controla o número de trocas de salas por
# Para cada turma/disciplina 't'.
# for t in range(lenT):
#     # Crio uma lista com as possíveis salas que comportam as aulas da turma/disciplina 't'.
#     salas_possiveis = list(dict.fromkeys([s for s in range(lenS) for a in A_tt[t] if eta_as[a,s] == 1]))
#     # Para cada possível combinação de salas alocadas para as aulas da turma/disciplina 't', tento manter o valor de y_t no menor possível.
#     for subS in [list(perm) for perm in list(permutations(salas_possiveis, len(A_tt[t])))]:
#         model += xsum(x_as[A_tt[t][n], subS[n]] for n in range(len(A_tt[t]))) <= 1 + y_t[t]
        # nr += 1
# print(nr)

# Abordagem com variável de contagem
# nr = 0
# Para cada turma/disciplina 't'.
for t in range(lenT):
    # model += len(A_tt[t]) >= y_t[t]
    # Para cada sala 's'.
    for s in range(lenS):
        # Adiciono uma restrição que verifica se a sala 's' foi utilizada pela turma/disciplina 't'.
        # Isso é feito através do valor atribuído de c_st, pois, quando ela possui o valor 0, a somatória da esquerda precisa ser
        # obrigatoriamente 0, ou seja, eu garanto que a sala 's' não foi utilizada pela turma/disciplina 't'.
        # Caso ela tenha o valor 1, então há espaço para que uma aula de 't' seja alocada na sala 's', e eu levo em conta o caso de
        # mais de uma aula de 't' ser alocada na mesma sala, até o número real de aulas da turma/disciplina 't'.
        model += xsum(x_as[a, s] for a in A_tt[t]) <= len(A_tt[t]) * c_st[s, t]
    #     nr += 1
    # Com as restrições de verificação concluídas e adicionadas, coloco uma restrição que garante que o valor de y_t reflita
    # o número de salas diferentes usadas pela turma/disciplina 't'.
    model += y_t[t] >= xsum(c_st[s, t] for s in range(lenS))
#     nr += 1
# print(nr)

# Para cada turma/disciplina com horários seguidos um do outro, garanto que ambas sejam alocadas na mesma sala.
# Novamente, assumo que não tem aulas seguidas em mais de 2 horários.
for t in A_s:
    for s in range(lenS):
        model += x_as[t[0],s] == x_as[t[1],s]


# Restrição de superlotação de uma sala.
# Para cada aula 'a'.
if sys.argv[5] and sys.argv[6]:
    for a in range(len(A)):
        # Para cada sala 's'.
        for s in range(len(S)):
            # Coloco uma restrição que verifica se uma aula ocupa mais de uma porcentagem da sala.
            # Isso é verificado quando o lado esquerdo, que descreve a ocupação total de uma aula 'a' em uma sala 's',
            # ultrapassa o valor de alpha * cap_s[s], que descreve a porcentagem ocupada. Se o valor for ultrapassado,
            # a variável z_as recebe o valor 1, portanto o lado direito passa a ter um valor a mais que balanceia a desigualdade.
            # Ex: Suponha que alpha seja 0.85, que a aula 'a' tenha 40 alunos e a sala 's' possua 45 lugares.
            # 85% de 45 é 38.25, que é menor que 40, logo, z_as recebe o valor 1 e o lado direito passa a ser 38.25 + 45,
            # mantendo a restrição verdadeira, mas o valor de z_as será contabilizado na função objetivo e uma penalidade será aplicada.
            # Por conta dessa penalidade, o modelo tentará evitar fazer esse tipo de alocação.
            model += tam_t[int((a % lenT ))] * x_as[a, s] <= alpha * cap_s[s] + z_as[a, s] * cap_s[s]

if sys.argv[4]:
    # (3.13) - Relação entre w_cs e x_as
    # Restrição que estabelece a relação entre w_cs e x_as, isto é, que identifica se o curso 'c' terá uma aula alocada na sala 's'.
    # Para cada sala 's'.
    for s in range(lenS):
        # Para cada curso 'c'.
        for c in range(lenC):
            # Para cada aula do curso 'c'.
            for a in A_c[c]:
                # Adiciono a restrição que relaciona as duas variáveis. Como 'a' é uma aula ministrada para o curso 'c',
                # quando x_as = 1, então o curso 'c' possui uma aula na sala 's', e a variável w_cs é obrigada a ter o valor 1 neste caso.
                model += x_as[a,s] <= w_cs[c,s]
    
    # (3.14) - Ligação das variáveis w_cs e vcsl
    # Restrição que estabelece a relação entre w_cs e v_cssl, isto é, que identifica se o curso 'c' terá uma aula
    # alocada na sala 's' e outra na sala 'sl'.
    # Para cada curso 'c'.
    for c in range(lenC):
        # Para cada sala 's'.
        for s in range(lenS):
            # Para cada sala 'sl'
            for sl in range(lenS):
                # Verifico se 's' e 'sl' são a mesma sala.
                if s != sl:
                    # Caso não sejam, adiciono as restrições de relação. Quando w_cs = 1 e w_csl = 1, a segunda restrição garante que
                    # v_cssl ganhe o valor 1. No caso de que ao menos uma entre w_cs e w_csl tem o valor 0, a primeira restrição
                    # garante que v_cssl também seja 0.
                    # Em outras palavras, as restrições garantem que v_cssl = 1 apenas quando w_cs = 1 e w_csl = 1, que
                    # significa que o curso 'c' possui ao menos uma aula na sala 's' e uma na sala 'sl'.
                    model += 2 * v_cssl[c,s,sl] <= w_cs[c,s] + w_cs[c,sl]
                    model += v_cssl[c,s,sl] >= w_cs[c,s] + w_cs[c,sl] - 1

# Defino a tolerância do ótimo com algum valor, isto é, defino uma distância máxima que eu tolero entre uma solução factível e uma solução ótima.
model.opt_tol = 0.1
# Desabilito as saídas de execução do modelo.
# set_solver_log(False)
model.verbose = 0
# Começo a cronometrar o tempo gasto na execução do modelo.
start = time.time()
# O modelo começa a fazer a alocação, com tempo limite de 7200 segundos (2 horas) de tempo limite.
model.optimize(max_seconds=7200)
# Terminado a execução do modelo, paro o cronômetro e calculo o tempo utilizado.
end = time.time()
exec = end - start
print(f"Tempo de execução: {exec}")

# Escrevo qual o tipo de solução obtida, como ótima, factível, infactível, etc.
print(f"Status do modelo: {model.status}")

# A variável aulas serve para contar quantas aulas foram alocadas pelo modelo. Note que as aulas do LEM não são contabilizadas aqui.
aulas = 0
# A variável ocupacao serve para calcular a ocupação total de todas as aulas alocadas.
ocupacao = 0
# Para cada aula 'a'.
for a in range(lenA):
    # Para cada sala 's'.
    for s in range(lenS):
        # Se o valor de x_as for maior que 0.5, quer dizer que a aula 'a' foi alocada na sala 's'.
        if x_as[a,s].x >= 0.5:
            # Contabilizo ela na variável aulas, e adiciono a ocupação da aula 'a' na sala 's'
            aulas += 1
            ocupacao += uso_as[a,s]

# A variável trocas contabiliza as escolhas do modelo à respeito da variável y_t.
trocas = 0
# Para cada turma/disciplina 't'.
for t in range(lenT):
    # Se o valor de y_t for maior que 0.5, quer dizer que a turma/disciplina:
    # 1) teve uma ou mais trocas de sala, se a interpretação de y_t for o número de trocas de sala feitas pela turma/disciplina 't'.
    # 2) teve uma ou mais salas utilizadas, se a interpretação de y_t for o número de salas utilizadas pela turma/disciplina 't'.
    if y_t[t].x >= 0.5:
        # Imrpimo o valor de y_t e contabilizo o ocorrido na variável trocas.
        # print(y_t[t].x)
        trocas += 1
#         print(f"Houve troca pra turma/disciplina {t}")

# Salvando a solução em um arquivo .txt
# Seguindo a mesma ideia para contar contabilizar os resultados anteriores, salvo os valores das variáveis importantes em um arquivo .txt.
# with open("X da solução - m2.2.txt", "w") as f:
#     for a in range(lenA):
#         for s in range(lenS):
#             if x_as[a, s].x > 0.5:  # Salvo apenas as variáveis relevantes
#                 f.write(f"{a},{s},{x_as[a, s].x}\n")  # Salvo no formato 'a,s,valor'

# with open("Y da solução - m2.2.txt", "w") as f:
#     for t in range(lenT):
#         if y_t[t].x > 0.5:
#             f.write(f"{t},{y_t[t].x}\n")

# Imprimo as informações coletadas após o término da execução do modelo.
# print(trocas)
# print(aulas)
print(f"Valor da solução: {model.objective_value}")
print(f"Valor do GAP da solução: {model.gap:.2%}")
print(f"Valor das salas ocupadas: {ocupacao}.")

# print(alocacoes)
# print(teste)

"""## Salvamento dos dados"""

# Com o modelo executado e a solução obtida, vou passar
# a salvar os dados de maneiras específicas, fazer certas verificações, visualizações e relatórios com os dados obtidos.

# Crio uma variável para conter o diretório da pasta que irá conter os arquivos gerados.
pasta_dados = os.path.join(os.getcwd(), "Saídas da Interface", "Saídas do Modelo")

# Crio listas para guardar os dados importantes das aulas, como o código da disciplina, o horário da aula, o número de inscritos, etc.
codigos = []
horarios = []
inscritos = []
salas_alocadas = []
nomes = []
docentes = []
curso_aula = []
ano_dados = []
nusp = []

# Para cada aula 'a'.
for a in range(lenA):
    # Salvo o índice da turma/disciplina dela para diminuir o número de ações do código.
    index = int(a % (lenT))
    # Também identifico qual coluna de horários do dataframe corresponde a aula 'a', isto é, qual coluna de horário 'a' pertence.
    coluna_horario = "Horário" + " " + str(1 + int(a / lenT))
    # Se a aula 'a' é ministrada no LEM e possui um horário definido
    if df.loc[index, 'Sala'] == '6-307' and not (pd.isna(df.loc[index, coluna_horario])):
        # Salvo o código da disciplina que 'a' pertence.
        codigos.append(df['Disciplina (código)'][index]) # deveria apendar apenas os códigos de matérias com horário ok
        # Salvo o horário da aula.
        horarios.append(df[coluna_horario][index])
        # Salvo o nome completo da disciplina que 'a' pertence.
        nomes.append(df['Disciplina (nome completo)'][index])
        # Salvo o nome do docente que irá ministrar a disciplina que 'a' pertence.
        docentes.append(df['Docente (nome completo sem abreviações)'][index])
        # Salvo o número de inscritos da disciplina que 'a' pertence.
        inscritos.append(df['Vagas por disciplina'][index])
        # Salvo a sala onde a aula 'a' foi alocada.
        salas_alocadas.append('6-307')
        # Salvo os cursos para os quais a disciplina que 'a' pertence é ministrada.
        curso_aula.append(df['Curso(s)'][index])
        nusp.append(df['NUSP'][index])
        ano_dados.append(df['Ano dos dados'][index])

    else:
        # Para cada sala 's'.
        for s in range(lenS):
            # Verifico se 'a' foi alocada em 's'.
            if x_as[a,s].x >= 0.5:
                # Salvo o código da disciplina que 'a' pertence.
                codigos.append(df['Disciplina (código)'][index]) # deveria apendar apenas os códigos de matérias com horário ok
                # Salvo o horário da aula.
                horarios.append(df[coluna_horario][index])
                # Salvo o nome completo da disciplina que 'a' pertence.
                nomes.append(df['Disciplina (nome completo)'][index])
                # Salvo o nome do docente que irá ministrar a disciplina que 'a' pertence.
                docentes.append(df['Docente (nome completo sem abreviações)'][index])
                # Salvo o número de inscritos da disciplina que 'a' pertence.
                inscritos.append(df['Vagas por disciplina'][index])
                # Salvo a sala onde a aula 'a' foi alocada.
                salas_alocadas.append(salas['Sala'][s])
                # Salvo os cursos para os quais a disciplina que 'a' pertence é ministrada.
                curso_aula.append(df['Curso(s)'][index])
                nusp.append(df['NUSP'][index])
                ano_dados.append(df['Ano dos dados'][index])


# Imprimo o tamanho das listas apenas para verificar que não houve nenhum problema estranho.
# Note que, aqui, as disciplinas do LEM estão contabilizadas no cálculo.
# print(len(codigos))
# print(len(horarios))
# print(len(inscritos))
# print(len(salas_alocadas))

# A variável dados_solucao é um dicionário contendo as listas que acabamos de criar, e essa variável será
# usada para criar um novo dataframe que será salvo no formato de uma planilha do excel.
dados_solucao = {
    'Disciplina': codigos,
    'Nomes': nomes,
    'Cursos': curso_aula,
    'Horário': horarios,
    'Sala': salas_alocadas,
    'Inscritos': inscritos,
    'Docentes': docentes,
    'NUSP': nusp,
    'Ano dos dados': ano_dados
}

# Converte os dados para um DataFrame.
dataframe = pd.DataFrame(dados_solucao)

# Caminho do novo arquivo Excel a ser criado.
# Esta planilha é uma visualização técnica de como as aulas foram alocadas, mostrando a disciplina em questão, o horário da aula daquela
# turma/disciplina. Note que as repetições aparentes das linhas se dá por conta dos diferentes horários das turmas/disciplinas.
full_name = "Dados da solução do Modelo.xlsx"
file_path = os.path.join(pasta_dados, full_name)


try:
    # Crio um novo arquivo Excel e escrevo os dados.
    with pd.ExcelWriter(file_path, engine='openpyxl') as writer:
        dataframe.to_excel(writer, sheet_name='Resultados', index=False)

    print(f"Novo arquivo '{full_name}' criado e dados salvos com sucesso!")
except PermissionError as e:
        if e.errno == 13:
            print(f"O arquivo '{full_name}' está aberto em algum programa (como o Excel). Feche o arquivo e tente novamente.")
            traceback.print_exc(file=sys.stderr)
            sys.exit(2)
        else:
            print(f"Ocorreu um erro inesperado ao criar o arquivo '{full_name}': {e}")
            traceback.print_exc(file=sys.stderr)
            sys.exit(1)
except Exception as e:
    print(f"Ocorreu um erro inesperado ao criar o arquivo '{full_name}': {e}")
    traceback.print_exc(file=sys.stderr)
    sys.exit(1)

"""## Conversão de tabela"""

# Utilizando a planilha que acabou de ser criada, criaremos uma segunda planilha para ser enviada para o sistema da intranet, automaticamente
# computando as decisões feitas à respeito da alocação.

# Leio o arquivo
# file_path = "dados_solucao - m1.2.xlsx"
sti = pd.read_excel(file_path)

# Defino uma função para extrair o horário das aulas na planilha.
def extrair_horarios(horario):
    # Remove espaços extras e deixa minúsculo para uniformizar.
    horario = horario.strip().lower()

    # Expressão regular para identificar o padrão: dia da semana e dois horários.
    pattern = r"(\bseg(?:unda)?\b|\bter(?:ça)?\b|\bqua(?:rta)?\b|\bqui(?:nta)?\b|\bsex(?:ta)?\b|\bs[áa]b(?:ado)?\b|\bdom(?:ingo)?\b)\s*-?\s*(\d{2}:\d{2})\s*[/-]?\s*(\d{2}:\d{2})"

    # Tenta encontrar correspondências com a expressão regular.
    match = re.search(pattern, horario)

    if match:
        dia = match.group(1).capitalize()  # Dia da semana.
        horario_inicio = match.group(2)    # Horário de início.
        horario_fim = match.group(3)       # Horário de fim.
        # Retorna os valores como formato padrão.
        return f"{dia} - {horario_inicio}", f"{dia} - {horario_fim}"
    else:
        return None, None

# Aplica a função à coluna 'Horário' e cria novas colunas 'Hora de Início' e 'Hora de Fim'.
sti['Hora de Início'], sti['Hora de Fim'] = zip(*sti['Horário'].apply(extrair_horarios))

# Anoto as salas correspondentes com as aulas.
Sala = []
# Para cada célula da coluna 'Sala' da planilha
for i in sti['Sala']:
    # Se ela for uma sala comum, adiciono-a na lista de sala
    if i != '6-305/6-306' and i != '6-303/6-304':
        Sala.append(i)
    # Se ela for a sala conjunta '6-305/6-306', salvo ela apenas como '6-305', seguindo o padrão da planilha do STI.
    elif i == '6-305/6-306':
        Sala.append('6-305')
    # Se ela for a sala conjunta '6-303/6-304', salvo ela apenas como '6-303', seguindo o padrão da planilha do STI.
    else:
        Sala.append('6-303')
# print(Sala)

# Novamente, crio um dicionário com os dados obtidos e organizados.
# Note que o tipo de 'Aula', apresentado na coluna de mesmo nome, sempre é "Aula" por ser o único tipo que estamos alocando.
# Note também que, para discernir entre qual sala de laboratório estará sendo usada (entre a sala única e a conjunta),
# utilizamos os valores das células da coluna 'Sala' da planilha original.
dados_organizados = {
    'Sala': Sala,
    'Disciplina': sti['Disciplina'],
    'Descrição': sti['Nomes'],
    'Aula': ["Aula" for i in range(len(sti['Sala']))],
    'Dia e hora início': sti['Hora de Início'],
    'Dia e hora fim': sti['Hora de Fim'],
    'Docente': sti['NUSP'],
    'Compartilhada com outra sala?': ["S" if (sti['Sala'][i] == '6-305/6-306' or sti['Sala'][i] == '6-303/6-304') \
                                      else "N" for i in range(len(sti['Sala']))]
}

# Converto o dicionário para um dataframe.
sti_planilha = pd.DataFrame(dados_organizados)

# Caminho do novo arquivo Excel a ser criado.
# file_path = "C:/Users/gabri/Estágio/Códigos/sti_planilha - m1.2.xlsx"
full_name = "Planilha do STI dada pelo Modelo.csv"
file_path = os.path.join(pasta_dados, full_name)


# Crio um novo arquivo Excel e escrevo os dados.
# with pd.ExcelWriter(file_path1, engine='openpyxl') as writer:
#     sti_planilha.to_csv(writer, sheet_name='Resultados', index=False, sep=';', encoding='latin-1')
try:
    sti_planilha.to_csv(file_path, index=False, sep=';', encoding='latin-1')
    print(f"Novo arquivo '{full_name}' criado e dados salvos com sucesso!")
except PermissionError as e:
    if e.errno == 13:
        print(f"O arquivo '{full_name}' está aberto em algum programa (como o Excel). Feche o arquivo e tente novamente.")
        traceback.print_exc(file=sys.stderr)
        sys.exit(2)
    else:
        print(f"Ocorreu um erro inesperado ao criar o arquivo '{full_name}': {e}")
        traceback.print_exc(file=sys.stderr)
        sys.exit(1)
except Exception as e:
    print(f"Ocorreu um erro inesperado ao criar o arquivo '{full_name}': {e}")
    traceback.print_exc(file=sys.stderr)
    sys.exit(1)



for sala in sti_planilha['Sala'].unique():
    sti_planilha_aux = sti_planilha[sti_planilha['Sala'] == sala]
    # print(len(df_aux))
    full_name = f"Planilha do STI dada pelo Modelo - {sala}.csv"

    file_path = os.path.join(pasta_dados, full_name)

    try:        
        sti_planilha_aux.to_csv(file_path, index=False, sep=';', encoding='latin-1')
        print(f"Novo arquivo '{full_name}' criado e dados salvos com sucesso!")
    except PermissionError as e:
        if e.errno == 13:
            print(f"O arquivo '{full_name}' está aberto em algum programa (como o Excel). Feche o arquivo e tente novamente.")
            traceback.print_exc(file=sys.stderr)
            sys.exit(2)
        else:
            print(f"Ocorreu um erro inesperado ao criar o arquivo '{full_name}': {e}")
            traceback.print_exc(file=sys.stderr)
            sys.exit(1)
    except Exception as e:
        print(f"Ocorreu um erro inesperado ao criar o arquivo '{full_name}': {e}")
        traceback.print_exc(file=sys.stderr)
        sys.exit(1)


"""## Factibilidade e Verificação"""

# Via de regra, se o modelo for infactível, é porque não tem como alocar todas as aulas nas salas.
# Com isso em mente, se em um primeiro momento o modelo rodar e retornar uma solução possível, mas após
# uma mudança de horário de uma disciplina/adição de turma não houver retorno,
# então as mudanças NÃO PODEM acontecer.

# O modelo deve retornar apenas soluções factíveis, já que as restrições são bem colocadas
# Para fazer uma melhor verificação, vamos montar um código que examina a saída e aponta quais disciplinas
# não foram alocadas. Estes casos provavelmente são referentes a erros de horários que não foram computados.
# Importante notar que a saída envolve disciplinas com 0 alunos, mas se uma disciplina não tem alunos, ela
# não deveria estar na planilha, afinal, não tem motivo para alocar uma sala para 0 pessoas.

# Traço o caminho até a planilha feita para o STI.
# file_path = "C:/Users/gabri/Estágio/Códigos/sti_planilha - m1.2.xlsx"
# file_path = "sti_planilha - m2.2.xlsx"
sti_planilha = pd.read_csv(os.path.join(pasta_dados, "Planilha do STI dada pelo Modelo.csv"),
                            on_bad_lines='skip', sep=';', encoding='latin-1')

# Crio uma variável no formato de lista com todas as turmas/disciplinas cujas aulas foram alocadas.
alocadas = sti_planilha['Disciplina'].tolist()
# Crio uma variável no formato de lista com todas as turmas/disciplinas que deveriam ser alocadas.
disciplinas = df['Disciplina (código)'].tolist()

# Para cada turma/disciplina 't' na lista de turmas/disciplinas que deveriam ser alocadas.
for t in disciplinas:
    # Se ela não fazer parte da lista de turmas/disciplinas alocadas pelo modelo, escrevo um aviso para o usuário.
    if t not in alocadas:
        print(f"A disciplina {t} não foi alocada. Verifique os horários e o número de vagas, pode haver algum erro de digitação.")

"""## Visualização de Planilha

### Códigos e funções gerais para as visualizações
"""

# Os próximos códigos são feitos para criar arquivos de planilha bem semelhantes,
# então fiz uma pequena coletânea de funções que são recorrentemente usadas.

# Leio novamente a planilha contendo a solução do modelo.
# dfv = pd.read_excel('C:/Users/gabri/Estágio/Códigos/dados_solucao - m1.2.xlsx')
dfv = pd.read_excel(os.path.join(pasta_dados, "Dados da solução do Modelo.xlsx"))

# Ordena o DataFrame com base na coluna desejada, no caso, 'Sala'.
dfv = dfv.sort_values(by='Sala')

# Cria uma lista dos valores únicos da coluna ordenada, isto é, uma lista das salas utilizadas na solução.
salas1 = dfv['Sala'].unique().tolist()

# Configurar horário inicial e final, isto é, o intervalo dos horários que serão colocados na planilha para a visualização.
start_time = datetime.strptime("07:00", "%H:%M")
end_time = datetime.strptime("23:30", "%H:%M")

# Crio uma lista para conter os valores do intervalo de horários.
horarios = []
# Crio uma variável com o horário inicial.
current_time = start_time
# Enquanto o horário inicial não for maior que o horário final, isto é, enquanto houver valores para serem colocados no intervalo.
while current_time <= end_time:
    # Adiciono o horário atual na lista de horários.
    horarios.append(current_time.strftime("%H:%M"))
    # Faço um acréscimo de 30 minutos no horário atual.
    current_time += timedelta(minutes=30)

# print(horarios)

# Função para padronizar o horário
def padronizar_horario_intranet(horario):
    # Para padronizar e facilitar a leitura dos horários, retiro espaços do horário.
    if ' ' in horario:
        horario = str(horario).replace(' ', '')
    # Para padronizar e facilitar a leitura dos horários, substituo 'h' por ':', caso tenha no horário.
    if 'h' in horario:
        horario = str(horario).replace('h', ':')
    # Separo o dia do horário da aula.
    dia, intervalo = horario.split('-')
    # Separo o começo e o fim da aula.
    start, end = intervalo.split('/')
    # Traduzo o horário para um objeto de data, ou seja, crio um objeto com propriedades e métodos dedicados à manipulação de horários do dia.
    start_dt = datetime.strptime(start, "%H:%M")
    end_dt = datetime.strptime(end, "%H:%M")
    # horario_dt = datetime.strptime(h, "%H:%M")

    # Começo uma análise para ver como o horário fica mais adequado.
    # Se o horário de início da disciplina é menor que 18, ou seja, 8:10,10:10,14:20 e 16:20, coloco os minutos em 0.
    if start_dt.hour < 18:
        start_dt = start_dt.replace(minute=0)
    # Caso contrário, isto é, 18, 19 e 21, mantém normal.

    # Se o horário de fim da aula é menor ou igual que 18, ou seja, 9:50, 11:50, 16 e 18
    if end_dt.hour <= 18:
        # Se os minutos do horário de fim da aula são inferiores a 30.
        if end_dt.minute < 30:
            # Arredondo o horário para a hora anterior, com 30 minutos.
            # Ex: 18:00 se torna 17:30.
            end_dt = end_dt.replace(minute=30,hour=end_dt.hour - 1)
        # Se os minutos do horário de fim são superiores a 30.
        elif end_dt.minute > 30:
            # Apenas deixo os minutos do horário como 30.
            # Ex: 09:50 se torna 09:30
            end_dt = end_dt.replace(minute=30)
    # Se o horário de fim da aula é maior que 18, ou seja, 19, 20:40 e 22:40
    else:
        # Se os minutos do horário de fim são inferiores a 30, mas superiores a 0.
        if end_dt.minute < 30 and end_dt.minute > 0:
            # Apenas deixo os minutos do horário como 0.
            # Ex: 19:10 se torna 19:00
            end_dt = end_dt.replace(minute=0)
        # Se os minutos do horário de fim são superiores a 30.
        elif end_dt.minute > 30:
            # Apenas deixo os minutos do horário como 30.
            # Ex: 20:40 se torna 20:30
            end_dt = end_dt.replace(minute=30)
        # Se os minutos forem exatamente 0, eu considero que a aula acaba meia hora antes do denotado.
        # Ex: fim às 19:00 se torna 18:30 para evitar problemas com disciplinas que começam às 19:00
        else:
            end_dt = end_dt.replace(minute=30,hour=end_dt.hour - 1)
    # start_dt.replace(hour=start_dt.hour, minute=start_dt.minute).s
    # end_dt.replace(hour=end_dt.hour, minute=end_dt.minute)
    # return str(f'{dia} - {horario_ajustado.strftime("%H:%M")}')
    # Retorno o novo horário traduzido.
    return str(f'{dia} - {start_dt.strftime("%H:%M")}/{end_dt.strftime("%H:%M")}')

# Crio uma variável com a quantidade de colunas necessárias para colocar todos os horários do intervalo.
sala_colunas = len(horarios)
# Lista com os nomes dos dias da semana que serão usados na visualização.
dias_semana = ["Segunda", "Terça", "Quarta", "Quinta", "Sexta", "Sábado"]

# Função para preencher a planilha com os nomes das disciplinas.
def preencher_planilha(start_row, start_column, end_row, end_column, start, sala, dias_semana, horarios, aula, disciplina, ws, aulas):
    # Defino um preenchimento verde para preencher as células com o nome das disciplinas.
    green_fill = PatternFill(start_color="99CC00", end_color="99CC00", fill_type="solid")

    # Defino um estilo de borda para colocar nas células.
    thin_border = Border(
        left=Side(style="thin"),
        right=Side(style="thin"),
        top=Side(style="thin"),
        bottom=Side(style="thin")
    )

#     sala = "Sala 101"
    # Mesclo as células na posição correta para colocar o número/nome da sala.
    ws.merge_cells(start_row=start_row, start_column=start_column, end_row=end_row, end_column=end_column)
    # Adiciono o número/nome da sala na célula mesclada.
    ws.cell(row=start_row, column=start_column).value = sala
    # Defino o alinhamento do texto da célula mesclada para deixar o número/nome da sala no centro da célula.
    ws.cell(row=start_row, column=start_column).alignment = Alignment(horizontal="center", vertical="center")
    # Por conta da célula mesclada funcionar de forma diferente de uma célula normal, é necessário aplicar o estilo da borda
    # em todas as células que foram mescladas.
    for col in range(1, end_column):
        ws.cell(row=start_row, column=col+1).border = thin_border

    # Preencho a primeira coluna com dias da semana.
    for i, dia in enumerate(dias_semana, start=start):
        ws.cell(row=i, column=start_column-1).value = dia
        ws.cell(row=i, column=start_column-1).border = thin_border

    # Preencho o horário nas colunas das células que foram mescladas, semelhante a um cabeçalho.
    for j, horario in enumerate(horarios, start=start_column):
        ws.cell(row=start_row+1, column=j).value = horario
        ws.cell(row=start_row+1, column=j).alignment = Alignment(horizontal="center", vertical="center")
        ws.cell(row=start_row+1, column=j).border = thin_border

    # Para todas as linhas da tabela.
    for row in range(start, start + len(dias_semana)):
        # Para todas as colunas da tabela.
        for col in range(start_column, start_column + len(horarios)):
            # Aplico a borda.
            ws.cell(row=row, column=col).border = thin_border
    # print(horarios)

    # Preenchimento das aulas nas planilhas.
    # Para cada horário de aula na lista de aulas da sala
    for h in aula:
        # print(h)
        # Separo o dia e o intervalo da aula.
        dia_h, int_h = h.split(' - ')
        # Separo o horário de fim e de início da aula.
        start_h, end_h = int_h.split('/')
        # print(type(start_h), end_h)
        # Para cada dia da semana.
        for i, dia in enumerate(dias_semana, start=start):
            # Verifico se o dia em questão é o mesmo que o da aula sendo analisada.
            if ws.cell(row=i, column=start_column-1).value == dia_h:
                # Se for, salvo o índice das colunas de início e fim do intervalo da aula, isto é,
                # identifico os índices das células que serão mescladas para colocar o nome da turma/disciplina da aula.
                # Ex: uma aula de Terça das 08:10 às 09:50 é considerada como das 08:00 às 09:30,
                # então as células mescladas são as da linha de Terça, começando na coluna das 08:00 até a coluna das 09:30.
                index_start = horarios.index(start_h)
                index_end = horarios.index(end_h)

                # Mesclo as células necessárias.
                ws.merge_cells(start_row=i,start_column=index_start+2, end_row=i, end_column=index_end+2)
                # Defino uma variável para simbolizar a célula do topo esquerdo da célula mesclada (que é a que deve ser alterada, neste caso).
                merged_cell = ws.cell(row=i,column=index_start+2)
                # Escrevo o nome da turma/disciplina da aula em questão, aplico o preenchimento verde, e o alinhamento de centro.
                merged_cell.value = disciplina[aula.index(h)]
                merged_cell.fill = green_fill
                merged_cell.alignment = Alignment(horizontal="center", vertical="center")

                # Contabilizo a aula colocada na planilha.
                aulas += 1
    # Retorno o número de aulas colocadas na planilha dessa forma.
    return aulas

# Função que define a largura das colunas da planilha.
def ajusta_largura(ws):
    # Para cada coluna na planilha.
    for col in ws.columns:
        # Defino uma variável de comprimento máximo
        max_length = 0
        # Verifico se a primeira célula da coluna é uma célula mesclada.
        if type(col[0]) == openpyxl.cell.cell.MergedCell:
            # Se for, obtenho a letra da coluna pela célula abaixo, pois uma célula mesclada não possui o método necessário para obtê-la.
            column = col[1].column_letter  # Obtém a letra da coluna
        else:
            # Caso contrário, obtenho a letra da coluna pela primeira célula mesmo.
            column = col[0].column_letter

        # Para cada célula da coluna.
        for cell in col:
            # Utilizo o método try-catch para ignorar erros ao analisar uma célula mesclada, já que ela funciona de forma diferente.
            try:
                # Verifico se o comprimento do conteúdo da célula é maior que meu comprimento máximo.
                if len(str(cell.value)) > max_length:
                    # Em caso positivo, atualizo o comprimento máximo.
                    max_length = len(str(cell.value))
            except:
                pass
        # Com o comprimento máximo, atualizo a largura das colunas da planilha para serem de um tamanho próximo ao mais alto.
        ws.column_dimensions[column].width = (max_length) * 1.1

"""### Visualização Completa (Todas as aulas e salas)"""

# Cria o workbook e a sheet, isto é, um objeto de planilha do Excel com a planilha ativa.
wb = Workbook()
ws = wb.active
ws.title = "Horário de Aulas"

# Defino as linhas e colunas de início e fim para a primeira tabela da planilha, isto é, para preencher os dados da primeira sala.
start_row = 1 # Linha de início.
start_column = 2 # Coluna de início.
end_row = 1 # Linha de término.
end_column = 1 + sala_colunas # Coluna de término.
start = start_row + 2 # Linha de início para listar os dias da semana.
space_between = 3 # Número de linhas entre a tabela de uma sala para a de outra sala.

# A variável aulas é um contador de quantas aulas foram colocadas na planilha, facilitando a verificação.
aulas = 0

# Para cada sala utilizada na solução.
for sala in salas1:
    # A variável df_filtrado é um dataframe com as linhas de dados do dataframe da solução, cuja coluna é a mesma que a sala.
    # Em outras palavras, é um dataframe com as aulas que foram alocadas na sala atual.
    df_filtrado = dfv[dfv['Sala'] == sala]

    # A variável aula é uma lista dos horários das aulas após serem padronizados.
    aula = df_filtrado['Horário'].apply(lambda x: padronizar_horario_intranet(x)).tolist()

    # A variável disciplina é uma lista do código das disciplinas cujas aulas foram alocadas na sala atual.
    disciplina = df_filtrado['Disciplina'].tolist()

    # Chamo a função que preenche a planilha, mandando os parâmetros necessários, e retornando o número de aulas alocadas na planilha.
    aulas = preencher_planilha(start_row, start_column, end_row, end_column, start, sala, dias_semana, horarios, aula, disciplina, ws, aulas)

    # Feito isso, ttualizo meus dados de criação, isto é, as coordenadas de onde a tabela da sala seguinte será colocada na planilha.
    start_row = start_row + 2 + len(dias_semana) + space_between
    end_row = start_row
    start = start_row + 2

# Depois de todas as aulas terem sido alocadas, ajusto a largura das colunas da planilha.
ajusta_largura(ws)

# Por fim, salva o arquivo.
# Por fim, salva o arquivo.
full_name = f"Visualização completa da Solução.xlsx"

file_path = os.path.join(pasta_dados, full_name)

wb.save(file_path)
print(f"Arquivo '{full_name}' salvo com sucesso!")
print("Número de aulas alocadas:", aulas)

"""### Visualização por Curso"""

# Cria o workbook, isto é, um objeto de planilha do Excel.
wb = Workbook()

# Para cada curso do ICMC
for c in curriculos:
    # Crio uma planilha com o nome do curso.
    ws = wb.create_sheet(title=c)

    # Defino as linhas e colunas de início e fim para a primeira tabela da planilha, isto é, para preencher os dados da primeira sala.
    start_row = 1 # Linha de início.
    start_column = 2 # Coluna de início.
    end_row = 1 # Linha de término.
    end_column = 1 + sala_colunas # Coluna de término.
    start = start_row + 2 # Linha de início para listar os dias da semana.
    space_between = 3 # Número de linhas entre a tabela de uma sala para a de outra sala.

    # A variável aulas é um contador de quantas aulas foram colocadas na planilha, facilitando a verificação.
    aulas = 0

    # A variável df_filtrado, neste caso, é um dataframe com um filtro de curso.
    # Em outras palavras, é um dataframe com as aulas que são ministradas para o curso atual.
    df_filtrado = dfv[dfv['Cursos'].str.contains(c, na=False)]

    # Cria uma lista dos valores únicos da coluna ordenada, isto é, uma lista das salas utilizadas na solução filtrando por curso.
    salas1 = df_filtrado['Sala'].unique().tolist()

    # Para cada sala utilizada na solução.
    for sala in salas1:
        # A variável df_filtrado_aux é um dataframe com as linhas de dados do dataframe filtrado, cuja coluna é a mesma que a sala.
        # Em outras palavras, é um dataframe com as aulas que foram alocadas na sala atual, e que são ministradas para o curso atual.
        df_filtrado_aux = df_filtrado[df_filtrado['Sala'] == sala]

        # A variável aula é uma lista dos horários das aulas filtradas após serem padronizados.
        aula = df_filtrado_aux['Horário'].apply(lambda x: padronizar_horario_intranet(x)).tolist().copy()

        # A variável disciplina é uma lista do código das disciplinas cujas aulas foram alocadas na sala atual.
        disciplina = df_filtrado_aux['Disciplina'].tolist()

        # Chamo a função que preenche a planilha, mandando os parâmetros necessários, e retornando o número de aulas alocadas na planilha.
        aulas = preencher_planilha(start_row, start_column, end_row, end_column, start, sala, dias_semana, horarios, aula, disciplina, ws, aulas)

        # Feito isso, atualizo meus dados de criação, isto é, as coordenadas de onde a tabela da sala seguinte será colocada na planilha.
        start_row = start_row + 2 + len(dias_semana) + space_between
        end_row = start_row
        start = start_row + 2

    # Depois de todas as aulas terem sido alocadas, ajusto a largura das colunas da planilha.
    ajusta_largura(ws)
    print(f"Número de aulas alocadas do curso {c}: {aulas}")

# Retiro a primeira planilha do arquivo, pois ela está vazia e não precisamos dela.
wb.remove(wb.active)
# Por fim, salvo o arquivo.
# Por fim, salva o arquivo.
full_name = f"Visualização por curso.xlsx"

file_path = os.path.join(pasta_dados, full_name)

try:
    wb.save(file_path)
    print(f"Arquivo '{full_name}' salvo com sucesso!")
except PermissionError as e:
    if e.errno == 13:
        print(f"O arquivo '{full_name}' está aberto em algum programa (como o Excel). Feche o arquivo e tente novamente.")
        traceback.print_exc(file=sys.stderr)
        sys.exit(2)
    else:
        print(f"Ocorreu um erro inesperado ao criar o arquivo '{full_name}': {e}")
        traceback.print_exc(file=sys.stderr)
        sys.exit(1)
except Exception as e:
    print(f"Ocorreu um erro inesperado ao criar o arquivo '{full_name}': {e}")
    traceback.print_exc(file=sys.stderr)
    sys.exit(1)

"""### Visualização por Departamento"""

# Cria o workbook, isto é, um objeto de planilha do Excel.
wb = Workbook()

# Crio uma lista dos departamentos do ICMC, além de considerar disciplinas de outros departamentos que precisam de alocação.
departamentos = ['SME', 'SMA', 'SCC', 'SSC', 'Outras']

# Para cada departamento da lista.
for d in departamentos:
    # Crio uma planilha com o nome do departamento.
    ws = wb.create_sheet(title=d)

    # Defino as linhas e colunas de início e fim para a primeira tabela da planilha, isto é, para preencher os dados da primeira sala.
    start_row = 1
    start_column = 2
    end_row = 1
    end_column = 1 + sala_colunas
    start = start_row + 2
    space_between = 3

    # A variável aulas é um contador de quantas aulas foram colocadas na planilha, facilitando a verificação.
    aulas = 0

    # Verifico se o departamento atual não é do ICMC
    if d == 'Outras':
        # Caso o departamento atual não seja nenhum departamento do ICMC, eu crio um filtro especial com todas as linhas das aulas
        # que não são dos departamentos do ICMC.
        filtro = ~(
            dfv['Disciplina'].str.startswith('SME', na=False) |
            dfv['Disciplina'].str.startswith('SMA', na=False) |
            dfv['Disciplina'].str.startswith('SCC', na=False) |
            dfv['Disciplina'].str.startswith('SSC', na=False)
        )
        # Após isso, aplico o filtro no dataframe para deixar os dados salvos na variável df_filtrado.
        df_filtrado = dfv[filtro]
    else:
        # Caso o departamento atual seja um dos do ICMC, adiciono os dados à variável df_filtrado.
        # Neste caso, ela é um dataframe com um filtro de departamento.
        df_filtrado = dfv[dfv['Disciplina'].str.startswith(d, na=False)]

    # Cria uma lista dos valores únicos da coluna ordenada, isto é, uma lista das salas utilizadas na solução filtrando por departamento.
    salas1 = df_filtrado['Sala'].unique().tolist()

    # Para cada sala utilizada na solução.
    for sala in salas1:
        # A variável df_filtrado_aux é um dataframe com as linhas de dados do dataframe filtrado, cuja coluna é a mesma que a sala.
        # Em outras palavras, é um dataframe com as aulas que foram alocadas na sala atual, e que são oferecidas pelo departamento atual.
        df_filtrado_aux = df_filtrado[df_filtrado['Sala'] == sala]

        # A variável aula é uma lista dos horários das aulas filtradas após serem padronizados.
        aula = df_filtrado_aux['Horário'].apply(lambda x: padronizar_horario_intranet(x)).tolist().copy()

        # A variável disciplina é uma lista do código das disciplinas cujas aulas foram alocadas na sala atual.
        disciplina = df_filtrado_aux['Disciplina'].tolist()

        # Chamo a função que preenche a planilha, mandando os parâmetros necessários, e retornando o número de aulas alocadas na planilha.
        aulas = preencher_planilha(start_row, start_column, end_row, end_column, start, sala, dias_semana, horarios, aula, disciplina, ws, aulas)

        # Feito isso, atualizo meus dados de criação, isto é, as coordenadas de onde a tabela da sala seguinte será colocada na planilha.
        start_row = start_row + 2 + len(dias_semana) + space_between
        end_row = start_row
        start = start_row + 2

    # Depois de todas as aulas terem sido alocadas, ajusto a largura das colunas da planilha.
    ajusta_largura(ws)
    print(f"Número de aulas alocadas do departamento {d}: {aulas}")

# Retiro a primeira planilha do arquivo, pois ela está vazia e não precisamos dela.
wb.remove(wb.active)
# Por fim, salvo o arquivo.
full_name = f"Visualização por departamento.xlsx"

file_path = os.path.join(pasta_dados, full_name)

try:
    wb.save(file_path)
    print(f"Arquivo '{full_name}' salvo com sucesso!")
except PermissionError as e:
    if e.errno == 13:
        print(f"O arquivo '{full_name}' está aberto em algum programa (como o Excel). Feche o arquivo e tente novamente.")
        traceback.print_exc(file=sys.stderr)
        sys.exit(2)
    else:
        print(f"Ocorreu um erro inesperado ao criar o arquivo '{full_name}': {e}")
        traceback.print_exc(file=sys.stderr)
        sys.exit(1)
except Exception as e:
    print(f"Ocorreu um erro inesperado ao criar o arquivo '{full_name}': {e}")
    traceback.print_exc(file=sys.stderr)
    sys.exit(1)

"""## Planilha de Distribuição"""

# Cria uma paleta de cores para utilizar como preenchimento.
cores = [
    "FF5733",  # Laranja brilhante
    "33FF57",  # Verde brilhante
    "3357FF",  # Azul forte
    "F3FF33",  # Amarelo
    "FF33A1",  # Rosa forte
    "FF8C33",  # Laranja queimado
    "A133FF",  # Roxo
    "33FFF3",  # Ciano

]

# A variável dict é um dicionário na forma de matriz que é inicialmente repleta de 0's.
# Cada valor dela identifica o número de aulas em uma determinada sala que um determinado curso tem, ou seja,
# para cada curso 'c' e sala 's', o par (c,s) mostra o número de aulas que o curso 'c' possui em 's'.
dict = {(c,s): 0 for c in range(lenC) for s in range(lenS)}

# A variável naulas_s é uma lista que contém o número de aulas total de cada sala.
naulas_s = []

# Para cada sala 's'.
for s in range(lenS):
    # Defino uma variável que conta o número de aulas de cada sala.
    naulas = 0
    # Para cada aula 'a'.
    for a in range(lenA):
        # Verifico se a aula 'a' foi alocada na sala 's'.
        if x_as[a,s].x >= 0.5:
            # Em caso positivo, obtenho a turma/disciplina para a qual a aula 'a' pertence.
            t = int(a % lenT)
            # Contabilizo a aula na variável contadora.
            naulas += 1
            # Para curso 'c'.
            for c in range(lenC):
                # Atualizo o valor de dict correspondente a contagem de aulas que o curso 'c' possui na sala 's'.
                dict.update({(c,s): dict[c,s] + Y_tc[t,c]})

    # Adiciono o número de aulas alocadas na sala 's' na lista naulas_s.
    naulas_s.append(naulas)

# A variável curso é uma lista contendo os índices dos cursos do ICMC.
curso = [t[0] for t in list(dict.keys())]
# A variável room é uma lista contendo os índices dos salas do ICMC.
room = [t[1] for t in list(dict.keys())]


# Cria o workbook, isto é, um objeto de planilha do Excel.
wb = Workbook()
ws = wb.active
ws.title = "Distribuição de Cursos"

# Começo a montara tabela colocando o nome das salas na primeira coluna da planilha.
for row in room:
    ws.cell(row=row+2,column=1).value = salas.loc[row, 'Sala']

# Feito isso, adiciono o nome dos cursos do ICMC na primeira linha da planilha.
for col in curso:
    ws.cell(row=1,column=col+2).value = curriculos[col]

# Para cada curso na lista de cursos, que serão vistos como as colunas da planilha.
for col in curso:
    # Para cada sala na lista de salas, que serão vistas como as linhas da planilha.
    for row in room:
        # Defino o valor da célula na linha e coluna atual (sala e curso atual, respectivamente) como o valor equivalente de dict.
        ws.cell(row=row+2,column=col+2).value = dict[col,row]

        # Defino o valor mínimo de uma barra de progresso como 0.
        min_obj = FormatObject(type="num", val=0)

        # Verifico se o número de aulas alocadas na sala 'row' é 0.
        if naulas_s[row] == 0:
            # Se for, defino o valor máximo de uma barra de progresso como 1, apenas para visualização.
            max_obj = FormatObject(type="num", val=1)
        else:
            # Se não for, defino o valor máximo de uma barra de progresso como o esse número.
            max_obj = FormatObject(type="num", val=naulas_s[row])

        # A variável cor recebe uma das cores da paleta criada anteriormente. O cálculo para determinar isso não é muito importante,
        # ele só foi feito assim para garantir que as cores não se repetiriam muito próximas umas das outras.
        cor = cores[int(row % lenC)]

        # Defino, então, a barra de progresso, utilizando os valor mínimo e máximo definidos anteriormente, e definimos a cor da mesma.
        data_bar = DataBar(cfvo=[min_obj, max_obj], color=cor, showValue="None")

        # Defino uma regra para colocar em uma linha da planilha, representando uma sala.
        rule = Rule(type="dataBar", dataBar=data_bar)

        # Adiciona a barra de progresso na linha correspondente.
        # Note que a "linha" é considerada como a célula da segunda coluna (coluna B) da planilha, até a célula da mesma linha
        # com a coluna sendo a do último curso da lista de cursos.
        ws.conditional_formatting.add(f"B{str(row+2)}:{chr(64+lenC+1)}{str(row+2)}", rule)

# Com as barras de progresso no lugar certo, adiciono uma coluna com o número de aulas de cada sala após a coluna do último curso.
ws.cell(row=1,column=int(len(curso)/lenS)+2).value = 'Nº Aulas'
# Para cada sala na lista de salas.
for row in room:
    # Coloco o número de aulas alocadas naquela sala.
    ws.cell(row=row+2,column=int(len(curso)/lenS)+2).value = naulas_s[row]

# Logo abaixo da última sala adicionada, eu coloco o valor da ocupação total e do tempo de execução do modelo em segundos.
ws.cell(row=lenS+2,column=1).value = ocupacao
ws.cell(row=lenS+3,column=1).value = exec

# Por fim, salvo o arquivo.
full_name = f"Distribuição de Cursos.xlsx"

file_path = os.path.join(pasta_dados, full_name)

try:
    wb.save(file_path)
    print(f"Arquivo '{full_name}' salvo com sucesso!")
except PermissionError as e:
    if e.errno == 13:
        print(f"O arquivo '{full_name}' está aberto em algum programa (como o Excel). Feche o arquivo e tente novamente.")
        traceback.print_exc(file=sys.stderr)
        sys.exit(2)
    else:
        print(f"Ocorreu um erro inesperado ao criar o arquivo '{full_name}': {e}")
        traceback.print_exc(file=sys.stderr)
        sys.exit(1)
except Exception as e:
    print(f"Ocorreu um erro inesperado ao criar o arquivo '{full_name}': {e}")
    traceback.print_exc(file=sys.stderr)
    sys.exit(1)

