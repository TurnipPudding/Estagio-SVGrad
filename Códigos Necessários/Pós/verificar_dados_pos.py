# -*- coding: utf-8 -*-
"""Verificar Dados.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1yW1OhB187SMqKc-ZCqy2SnoXpOk8769i
"""



"""## Import das bibliotecas"""

# !pip install mip
# Imports das bibliotecas e funções utilizadas
import pandas as pd # Leitura de dados
# import time # Cálculo de tempo
# from mip import Model, xsum, minimize, BINARY, INTEGER, CONTINUOUS, OptimizationStatus # Biblioteca com linguagem de modelagem
import re
import os
import sys # Implementação de saídas de erro
import traceback # Implementação de inspeção para auxiliar nas saídas de erro.
from itertools import permutations # Função para criar uma lista de permutações
from datetime import datetime, timedelta # Funções para a leitura de horários de aula
import networkx as nx # Biblioteca para utilizar redes de grafos.
# import openpyxl # Biblioteca para a elaboração de planilhas mais detalhadas
# # Métodos e funções para auxiliar na criação de planilhas mais elaboradas
# from openpyxl import Workbook
# from openpyxl.styles import PatternFill, Alignment, Border, Side
# from openpyxl.utils import get_column_letter
# from openpyxl import load_workbook
# from openpyxl.formatting.rule import DataBar, FormatObject, Rule

"""## Leitura dos dados"""

sheets = ["CCMC", "PPGMAT", "MECAI", "PIPGES"] # Planilhas a serem lidas no arquivo com os dados de cada departamento
# Diferentes arquivos de teste que foram utilizados
# file_path = 'C:/Users/gabri/Estágio/Dados/Dados_das_salas_copia.xlsx'
# file_path = 'C:/Users/gabri/Estágio/Dados/Dados_das_salas_atualizado_copia.xlsx'
# file_path = 'C:/Users/gabri/Estágio/Dados/Dados_das_salas_atualizado_copia_com_fixadas.xlsx'
# file_path = 'C:/Users/gabri/Estágio/Dados/Dados das salas semigual ao 202401.xlsx'
# file_path = 'C:/Users/gabri/Estágio/Dados/Dados das salas 2025 copia.xlsx'
# file_path = 'C:/Users/gabri/Estágio/Dados/Dados das salas 2025 pior caso.xlsx'
# file_path = sys.argv[1]

# # Criação e mescla do dataframe (dados das aulas)
# df = pd.read_excel(file_path, sheet_name=sheets)
# df = pd.concat(df.values(), ignore_index=True)

# df = pd.read_excel('C:/Users/gabri/Estágio/Códigos/Demonstração/Saídas da Interface/Planilhas de Dados/Teste pra pós sem online sem espelho.xlsx', sheet_name=sheets)
# df = pd.concat(df.values(), ignore_index=True)
df = pd.read_excel('C:/Users/gabri/Estágio/Códigos/Demonstração/Saídas da Interface/Planilhas de Dados/Teste pra pós sem online.xlsx', sheet_name=sheets)
df = pd.concat(df.values(), ignore_index=True)
for idx, row in df.iterrows():
    # print(f"Row {idx}: {df.loc[idx, 'Disciplina (código)']} - {df.loc[idx, 'Observações']}")
    if 'Espelho' in df.loc[idx, 'Observações']:
        # print("a")
        df = df.drop(index=[idx])

df = df.drop_duplicates(subset='Disciplina (código)', keep='first').reset_index(drop=True)

# for idx, row in df.iterrows():
#     print(f"Row {idx}: {df.loc[idx, 'Disciplina (código)']} - {df.loc[idx, 'Observações']}")
# df = df.rename(columns={"Sala (a definir)": "Sala"})
# print(df.columns)
# print(df)
# Dataframe com os dados das salas
# salas = pd.read_excel(file_path, sheet_name="Salas")
salas = pd.read_excel("C:/Users/gabri/Estágio/Códigos/Demonstração/Files/Interface/Planilha das salas.xlsx", sheet_name="Salas")
# print(salas)
# Lista da capacidade de cada sala do dataframe
cap_s = salas['Lugares'].tolist()
# print(cap_s)
# Lista do tamanho de cada disciplina (número de inscritos)
tam_t = df['Vagas por disciplina'].tolist()
# print(tam_t)

# Dataframe com os dados dos horários livros
# df_livres = pd.read_excel(sys.argv[9])
df_livres = pd.read_excel('C:/Users/gabri/Estágio/Códigos/Demonstração/Saídas da Interface/Planilhas de Dados/PlanLivre.xlsx')
print('Base de Dados lida.')

"""## Tratamento dos Dados"""

# Função para converter horário no formato 'HH:MM' para valor decimal em horas
def horario_para_decimal(horario):
    # Se, por algum acaso, houver um horário definido como 20h40, ele é convertido para 20:40
    if 'h' in horario:
        horario = horario.replace('h',':')
    # Separo e identifico os componentes daquele horário, ou seja, salvo o valor de horas e o de minutos
    horas, minutos = map(int, horario.split(':'))
    # Retorno um valor numérico daquele horário seguindo a ideia de "porcentagem" de hora.
    # Ex: 40 minutos são dois terços de uma hora (40/60 = 2/3), logo, 20:40 pode ser traduzido como 20 + 40/60 = 20.67
    return horas + minutos / 60

# Função para processar a célula no formato 'Dia - HH:MM/HH:MM'
def processar_horario(celula):
#     print(celula)
    # Verifico se a célula que está sendo analisada possui um horário definido (se há algo escrito nela e separado por um traço "-")
    if isinstance(celula, str) and "-" in celula:
        # Deleto qualquer espaço " " da célula para garantir uma leitura organizada,
        # já que algumas vezes pode haver mais de um espaço, ou a ausência dos mesmos
        celula = str(celula).replace(' ', '')
        # print(celula)
        # Separo e salvo o dia da semana o qual a aula é dada, e o horário do dia que ela é ministrada
        dia, horarios = celula.split('-')
        # Separo o horário de início e de término daquela aula
        inicio, fim = horarios.split('/')
        # Salvo o horário do ínicio e do fim daquela aula
        start_a = horario_para_decimal(inicio)
        end_a = horario_para_decimal(fim)
        # Retorno o dia e os horários daquela aula
        return dia, start_a, end_a
    else:
        # Se a célula é vazia ou não possui o traço "-", é uma célula irregular com horário não definido, logo, retorno valor 0
        return 0, 0, 0

# Lista das colunas de horários
colunas_horarios = ['Horário 1', 'Horário 2', 'Horário 3', 'Horário 4']
result = []
# Processar cada coluna de horários
# Para cada coluna de horários
for coluna in colunas_horarios:
    # Aplico o processamento e tradução do horário
    resultados = df[coluna].apply(processar_horario).to_list()
    # Adiciono numa lista os horários traduzidos de cada coluna
    result.extend(resultados)

# Crio um dataframe com os dados padronizados de todas as aulas
A = pd.DataFrame(result, columns=['Dia', 'start_a', 'end_a'])
# Salvo as colunas do dataframe em listas separadas
dia_a = A['Dia'].to_list()
start_a = A['start_a'].to_list()
end_a = A['end_a'].to_list()
# print(A)
# print(len(A))
# print(start_a)

# Para cada célula vazia na coluna 'Sala' do dataframe principal, eu coloco o valor da célula como 0
for s in range(len(df['Sala'])):
    if pd.isna(df.loc[s, 'Sala']):
        df.loc[s, 'Sala'] = 0

# if sys.argv[7]:
#     # Variável com o número suposto de alunos da pós.
#     qtd_pos = int(sys.argv[7])
#     for d in range(len(tam_t)):
#         # print(f"Valor de tam_t: {tam_t[d]}")
#         # print(f"Valor do dataframe: {df.loc[d, 'Vagas por disciplina']}")
#         if not pd.isna(df.loc[d, 'Observações']):
#             if 'Espelho' in df.loc[d, 'Observações'] or 'espelho' in df.loc[d, 'Observações']:
#                 print(
#                     f"Número de inscritos na disciplina {df.loc[d, 'Disciplina (código)']} (espelhada com a pós): {df.loc[d, 'Vagas por disciplina']}"
#                     f"\nAdicionando número de inscritos da pós fornecido pelo usuário."
#                 )
#                 # print(df.loc[d, 'Vagas por disciplina'])
#                 # print(tam_t[d])
#                 tam_t[d] += qtd_pos
#                 df.loc[d, 'Vagas por disciplina'] += qtd_pos
#                 print(
#                     f"Número de inscritos na disciplina {df.loc[d, 'Disciplina (código)']} (espelhada com a pós): {df.loc[d, 'Vagas por disciplina']}"
#                 )
#                 # print(tam_t[d])

# Descomentar depois

# for d in range(len(tam_t)):
#     if pd.isna(df.loc[d, 'Turma']):
#         df.loc[d, 'Turma'] = 1

"""## Dados de Entrada"""

# Faço uma lista de índices de cada turma/disciplina do dataframe principal, então a primeira disciplina é 0, a segunda 1, etc.
T = range(len(df['Disciplina (código)']))
# print(T[38]) # retorna um índice que equivale à posição de uma disciplina na lista
# print(df['Disciplina (código)'][T[38]]) # retorna a sigla da disciplina (o índice equivale a linha - 2)

# Faço uma lista de índices de cada sala do dataframe principal, então a primeira sala é 0, a segunda 1, etc.
S = range(len(salas['Sala']))
# print(salas['Sala'][S[2]]) # retorna uma sala

# Faço uma lista de quais salas são de laboratório (salvo como índices)
sigma_s = [1 if salas['Laboratório'][s] == 'Sim' else 0 for s in S]
# print(sigma_s) # sigma_s = 1 se a sala s eh de laboratório

# Faço uma lista de quais turmas/disciplinas requisitaram aula em laboratório
tal_t = [0 if df['Utilizará laboratório? (sim ou não)'][t] == 'Não' else 1 for t in T]
# print(tal_t) # tal_t = 1 se a turma/disciplina t precisar de laboratório

# Para não precisar chamar o mesmo método que calcula o comprimento das listas mais importantes, eu salvo eles em variáveis
lenT = len(T)
lenA = len(A)
lenS = len(S)

# Lista dos cursos, ou currículos, do ICMC
curriculos = ['BMACC', 'BMA', 'LMA', 'MAT-NG', 'BECD', 'BCC', 'BSI', 'BCDados']
# Faço o mesmo esquema de salvar o comprimento da lista de cursos
lenC = len(curriculos)
# Crio uma dicionário em formato de matriz para identificar quais turmas/disciplinas são ministradas para cada curso do instituto
# Inicio todos os valores da matriz como 0 para atualizá-los

# Descomentar depois

# Y_tc = {(t,c): 0 for t in range(lenT) for c in range(lenC)}
# # Para cada turma/disciplina
# for t in range(lenT):
#     # Analiso a célula de curso daquela turma/disciplina
#     celula = df.loc[t, 'Curso(s)']
#     # Se houver uma vírgula na célula, provavelmente é por ter mais de um curso que possui essa turma/disciplina
#     if ',' in celula:
#         # print(df['Curso(s)'][int(a % lenT)].split(', '))
#         # Para cada ', ' na célula, esperasse que haja um outro curso, ou seja, se a célula for 'BMACC, BMA, LMA',
#         # o valor da variável 'c' será 'BMACC', 'BMA' e 'LMA'
#         for c in celula.split(', '):
#             # Se aquela curso está na lista dos cursos do instituto
#             if c in curriculos:
#                 # Altero o valor da minha matriz, identificando que aquela turma/disciplina é ministrada para algum curso do ICMC
#                 Y_tc.update({(t,curriculos.index(c)): 1})
#     else:
#         # Se há um único curso para o qual aquela turma/disciplina é ministrada, verifico se é um dos cursos do ICMC
#         if celula in curriculos:
#             # Altero o valor da minha matriz, identificando que aquela turma/disciplina é ministrada para algum curso do ICMC
#             Y_tc.update({(t,curriculos.index(celula)): 1})

# print(Y_tc)

"""## Dados de Preprocessamento"""

# A variável A_t é uma lista onde cada elemento é uma lista dos índices das aulas de uma determinada turma/disciplina
# Ex: Se A_t[0] é dada por [0, 1, 2], então as aulas 0, 1 e 2 são da turma/disciplina 0
A_t = []
# Para cada turma/disciplina
for t in range(lenT):
    # Adiciono uma lista com os índices de cada aula daquela turma/disciplina
    # O cálculo feito trabalha no fato de que lenA = n * lenT, pois lenT é o número de turmas/disciplinas,
    # e LenA é o número de turmas/disciplinas multiplicado pelo número de colunas de horários.
    # Ex: Suponha que tenhamos 4 colunas de horário e 4 turmas/disciplinas, então lenT = 4, lenA = 16, lenA/lenT = 4
    # O incremento de i garante que vamos obter sempre o índice da mesma aula. Definindo a primeira turma/disciplina do nosso exemplo como 1,
    # a próxima aula dessa turma/disciplina é a 5 = 1 + 4 = t + 1*lenT, a terceira seria a 9 = 1 + 8 = t + 2 * lenT
    A_t.append([t + (i * lenT) for i in range(int(lenA/lenT))])
# print(A_t) # lista de listas
# print(A_t[0]) # uma lista específica
# print(A_t[0][1]) # um termo de uma lista específica

# A variável A_tt segue a mesma ideia de A_t, com a diferença de que as listas de A_tt não incluem os índices das aulas sem horário definido
A_tt = [[a for a in A_t[t] if start_a[a] != 0] for t in range(lenT)]
# print(A_tt)

# A variável A_s é uma lista onde cada elemento é uma lista de aulas de uma mesma turma/disciplina que são seguidas uma da outra
# Ex: se uma turma/disciplina possui uma aula na segunda das 10:10 às 11:50 e outra das 14:20 às 16:00, os índices dessas aulas estão juntos
# em uma lista de A_s, e essa será usada para garantir que ambas estejam na mesma sala
# Uma importante suposição ao criar essa lista é que não existem turmas/disciplinas com três aulas seguidas em um mesmo dia
A_s = []
# Para cada turma/disciplina de A_t (assumindo que, no máximo, existam turmas/disciplinas com duas aulas seguidas)
for t in A_t:
    # Se o dia das aulas é o mesmo, e é diferente de 0, ou seja, está definido
    if dia_a[t[0]] == dia_a[t[1]] and dia_a[t[0]] != 0:
        # Verifico se o fim da primeira aula somado a um intervalo é maior que o começo da segunda aula
        # Ex: Usando o exemplo anterior, o fim da primeira aula é às 11:50, que é traduzido para 11.83.
        # 11.83 + 2 + 0.17 + 0.33 = 14.33, que é o valor traduzido do ínicio da segunda aula dado por 14:20
        # Ex: Se, ao invés disso, fossem duas aulas no horário da manhã, teríamos 9.83 (valor traduzido de 09:50) como fim da primeira aula,
        # logo, 9.83 + 2 + 0.17 + 0.33 = 12.33, que é maior que 10.17 (valor traduzido de 10:10, o início da segunda aula)
        # Os valores desta soma levam em conta as 2 horas e meia entre 11:50 e 14:20, o maior intervalo de tempo entre duas aulas seguidas
        if end_a[t[0]] + 2 + 10/60 + 20/60 >= start_a[t[1]]:
            # Sabendo que as aulas são seguidas, faço uma lista com as aulas que possuem horário definido
            seguido = [x for x in t if start_a[x] != 0]
#         print(seguido)
            # Se a lista possui mais de um horário, então é uma lista com o índice de duas aulas que são seguidas uma da outra
            if len(seguido) > 1:
                # Portanto, adiciono essa lista em A_s
                A_s.append(seguido)

# print("A_s =", A_s)

# A variável A_c é uma lista onde cada elemento é uma lista das turmas/disciplinas que são ministradas para um determinado curso 'c' do instituto.

# Descomentar depois
# A_c = []
# for c in range(lenC):
#     # A ideia é semelhante à criação das listas anteriores, utilizando uma conta "esperta" para simbolizar o índice correto,
#     # com a condição de colocar na lista as turmas/disciplinas corretas (Y_tc = 1).
#     A_c.append([t + (i * lenT) for i in range(int(lenA/lenT)) for t in range(lenT) if Y_tc[t,c] == 1])

# print("A_c =", A_c[0])

# A variável eta_as é um dicionário em formato de matriz para identificar quais aulas cabem em determinadas salas, ou seja
# eta_as = 1 se a sala s pode alocar a aula a, e é 0 caso contrário
# O cálculo usando 'a % lenT' retorna um valor que varia traduz para um índice da turma/disciplina a qual a aula 'a' pertence
# Ex: se lenT = 4, temos que 0 % 4 = 0; 1 % 4 = 1; 2 % 4 = 2; 3 % 4 = 3; 4 % 4 = 0, 5 % 4 = 1; ...
# Logo, como imaginamos, a quinta aula (índice 4, já que começamos do 0) deveria pertencer a turma/disciplina 0, e, de fato,
# 0 % 4 = 4 % 4 = 0
eta_as = {(a, s): 1 if tam_t[int((a % lenT ))] <= cap_s[s] \
          else 0 for a in range(lenA) for s in range(lenS)}
# print(eta_as) # dicionário com pares (a,s) com valor 1 se s consegue alocar a aula a
# print(eta_as[2,8]) # valor específico de um par

# A variável theta_aal é um dicionário em formato de matriz para identificar quais aulas possuem conflito de horário, ou seja,
# theta_aal = 1 quando as aulas 'a' e 'al' possuem conflito de horário
# O conflito é detectado quando, para o mesmo dia, o ínicio da aula 'a' é estritamente menor que o fim da aula 'al'
# ao mesmo tempo que o início de 'al' é estritamente menor que o final de 'a'
# Ex: Uma aula 'a' dada de segunda das 14:20 até às 17:10 e outra 'al' dada na segunda das 16:20 às 18:00 obviamente têm conflito de horário
# Utilizando os valores traduzidos, podemos verificar que 14.33 < 18 e 16.33 < 17.17
# Agora, se 'a' fosse das 14:20 às 16:00, teríamos ainda que 14.33 < 18, mas teríamos que 16.33 > 16, logo, não é considerado conflito
theta_aal = {(a, al): 1 if (dia_a[a] == dia_a[al] and (start_a[a] < end_a[al] and start_a[al] < end_a[a])) \
             else 0 for a in range(lenA) for al in range(lenA)}

# print(theta_aal)

# A variável uso_as é um dicionário em formato de matriz para contabilizar o quanto de espaço vazio uma aula deixa em uma determinada sala
# Ex: se uma aula 'a' tem 30 alunos, ela ocupa 67% de uma sala 's' com 45 lugares (deixando 33% da sala vazia),
# mas 100% de uma sala 's' com 30 lugares (deixando 0% da sala vazia). Quando menor o valor de uso_as, melhor.
uso_as = {(a, s): 100 * (1 - (tam_t[int((a % lenT))]/cap_s[s])) for a in range(lenA) for s in range(lenS)}

# print(uso_as)

# A variável dis é um dicionário em formato de matriz para contabilizar a distância (arbitrária) de ir de uma sala 's' até uma sala 'sl'.
# Ex: A distância de uma sala do bloco 3 até uma sala do bloco 5 é de 6 unidades de distância, enquanto a distância de uma sala do bloco 3
# até uma sala do bloco 4 é de 1 unidade de distância.
# dis = {(s, sl): salas.iloc[s, sl+3] for s in range(salas.shape[0]) for sl in range(salas.shape[1]-3)}
dis = {(s, sl): salas.loc[s, sl] for s in range(len(salas)) for sl in salas.columns[3:-1]}
# print("dis =", dis)

pref = salas['Preferencialmente Vazia'].tolist()

"""## Dados para fixar os laboratórios e aulas com sala definida, como LEM"""

# A variável labs é uma lista com todas as turmas/disciplinas que precisam de laboratório, identificadas pela lista tal_t
# Conceitualmente, para os laboratórios, essa lista é como se fosse o T
labs = [t for t in T if tal_t[t] == 1]
# print(labs) # retorna o índice da disciplina

# A variável salas_labs é uma lista das salas de laboratório
# Conceitualmente, para os laboratórios, essa lista é como se fosse o S
salas_labs = [i for i in range(len(salas['Laboratório'])) if salas.loc[i, 'Laboratório'] == "Sim"]
# print(salas_labs)

# A variável ind_labs é uma lista que indica quais aulas de uma turma/disciplina deverá ser em um laboratório
# Ex: Se a terceira aula da disciplina de laboratório 0 é a de laboratório, então o primeiro elemento de ind_labs
# seria uma lista com apenas o índice 3. Caso a primeira e segunda aula da disciplina de laboratório 0 fossem de laboratório,
# então o primeiro elemento de ind_labs seria a lista [1,2]
ind_labs = []
# Para cada turma/disciplina que precisa de uma sala de laboratório disponível
for l in labs:
    # Adiciono os valores da célula separados por vírgula, ou seja, se na célula está escrito 'Sim,1,2',
    # a lista adicionada é ['Sim', '1', '2']
    ind_labs.append(df.loc[l, 'Utilizará laboratório? (sim ou não)'].split(','))
    # Removo o 'Sim' da última lista adicionada, então no nosso exemplo, a lista adicionada agora é dada por ['1', '2']
    ind_labs[-1].remove("Sim")
    # Por fim, converto os elementos dessa lista para serem valores inteiros
    ind_labs[-1] = [int(item) for item in ind_labs[-1]]

# print(ind_labs) # lista de listas, pra saber os horários de cada disciplina

# A variável aula_labs é uma lista com os índices de todas as aulas que devem ser ministradas em laboratório
aula_labs = [(labs[t] + (lenT * (i-1))) for t in range(len(labs)) for i in ind_labs[t]]
# print(aula_labs)

# A variável lab_tal é uma lista que funciona da mesma forma que a variável tal_t, mas usando o índice da aula, e não o da turma/disciplina
# Defino todos os seus valores como 0 inicialmente, ou seja, admito que todas as aulas não são de laboratório
lab_tal = [0 for _ in range(lenA)]
# Para cada aula que é de laboratório, altero o índice dela para 1 em lab_tal
for a in aula_labs:
    lab_tal[a] = 1

# print(lab_tal)

# A variável sala_fixa é uma lista de 1's e 0's, onde cada elemento dela remete ao índice de uma aula. Se o i-ésimo termo da lista é 1,
# então a i-ésima aula possui uma sala fixada. Se o valor é 0, ela não possui sala fixada
# Ex: Se a aula 37 possui uma sala fixa, então sala_fixa[37] = 1 (lembrando do uso da aula 0 neste caso)
# sala_fixa = [1 if (df.loc[a % lenT, 'Sala'] != 0 and start_a[a] != 0) else 0 for a in range(lenA)]
sala_fixa = []
for a in range(lenA):
    sala_valor = str(int(df.loc[a % lenT, 'Sala']))
    if ', ' in sala_valor:
        if not pd.isna(df.loc[int(a / lenT), 'Horário ' + str(int(a / lenT) + 1)]):
            if len(sala_valor.split(', ')) >= (int(a / lenT) + 1):
                sala_fixa.append(sala_valor.split(', ')[int(a / lenT)])
            else:
                sala_fixa.append('0')
            # sala_fixa.append(sala_valor.split(', ')[int(a / lenT)])
    elif not pd.isna(df.loc[int(a / lenT), 'Horário ' + str(int(a / lenT) + 1)]):
        sala_fixa.append(sala_valor)
    else:
        sala_fixa.append('0')


# Descomentar depois

# sala_proibida = {}
# for a in range(lenA):
    
#     if not pd.isna(df.loc[int(a % lenT), 'Proibir Horário ' + str(int(a / lenT) + 1)]):

#         cell = str(df.loc[int(a % lenT), 'Proibir Horário ' + str(int(a / lenT) + 1)])
        
#         if ',' in cell:
#             sala_proibida.update({a : cell.split(', ')})
#             for sala in cell.split(', '):
#                 s = salas[salas['Sala'] == sala].index[0]
#                 eta_as[a,s] = 0
#         else:
#             sala_proibida.update({a : cell})
#             s = salas[salas['Sala'] == cell].index[0]
#             eta_as[a,s] = 0

# for s in range(lenS):
#     print(f"Aula {df.loc[0, 'Disciplina (código)']}, Sala {salas.loc[s, 'Sala']}: {eta_as[(0, s)]}")

# Preciso usar o dataframe df_livres para verificar os horários livres de cada sala
# No df_livres, cada linha tem uma sala, e essa sala tem um index no eta_as.
# Além disso, na mesma linha, há um dia da semana e um horário vago.
# Então, para cada linha do df_livres, eu preciso verificar se o horário daquela sala está livre

# verify = [False for _ in range(lenA)] # Lista para verificar se o horário está livre
# for idx, row in df_livres.iterrows():
#     sala = row['Sala']
#     dia = row['Dia da semana']
#     inicio_str, fim_str = str(row['Horário vago']).split(' - ')
#     inicio = horario_para_decimal(inicio_str.strip())
#     fim = horario_para_decimal(fim_str.strip())
    
#     # Verifico se a sala está livre para cada aula
#     for a in range(lenA):
#         # Se o dia da aula for o mesmo que o dia do horário livre
#         # e o horário da aula não estiver completamente dentro do horário livre,
#         if dia_a[a] == dia and \
#         not verify[a] and \
#         not (start_a[a] >= inicio and \
#              end_a[a] <= fim):
#             # Verifico se a aula caberia na sala
#             s = salas[salas['Sala'] == sala].index[0]
#             if eta_as[(a, s)] == 1:
#                 # Se a aula caberia na sala, marco como 0 (não cabe),
#                 # pois o horário não está livre para aquela aula
#                 eta_as[(a, s)] = 0
#                 print(f"Aula {df.loc[int(a % lenT), 'Disciplina (código)']}, Sala {salas.loc[s, 'Sala']}: {eta_as[(a, s)]}")
#                 print(f"Horário {dia} - {inicio} a {fim} não está livre para a aula de ínicio {start_a[a]} e fim {end_a[a]}.")


for s in range(lenS):
    # print(eta_as[(0, s)])
    df_livres_f = df_livres[df_livres['Sala'] == salas.loc[s, 'Sala']]
    lista_v = [False for _ in range(lenA)]  # Lista para verificar se o horário está livre
    for idx, row in df_livres_f.iterrows():
        dia = row['Dia da semana']
        inicio_str, fim_str = str(row['Horário vago']).split(' - ')
        inicio = horario_para_decimal(inicio_str.strip())
        fim = horario_para_decimal(fim_str.strip())
        
        # Verifico se a sala está livre para cada aula
        for a in range(lenA):
            if eta_as[(a, s)] == 1:
                if dia_a[a] == dia and start_a[a] >= inicio and end_a[a] <= fim:
                    # Se o dia da aula for o mesmo que o dia do horário livre
                    # e o horário da aula estiver completamente dentro do horário livre,
                    # marco como True (está livre)
                    lista_v[a] = True
                    # print(f"Aula {df.loc[int(a % lenT), 'Disciplina (código)']}, Sala {salas.loc[s, 'Sala']}: {eta_as[(a, s)]}")
                    # print(f"Horário {dia} - {inicio} a {fim} está livre para a aula de ínicio {start_a[a]} e fim {end_a[a]}.")
    for a in range(lenA):
        if not lista_v[a]:
            # Se o horário não está livre para a aula, marco como 0 (não cabe),
            # pois o horário não está livre para aquela aula
            eta_as[(a, s)] = 0
            # print(f"Aula {df.loc[int(a % lenT), 'Disciplina (código)']}, Sala {salas.loc[s, 'Sala']}: {eta_as[(a, s)]}")
            # print(f"Horário {dia} - {inicio} a {fim} não está livre para a aula de ínicio {start_a[a]} e fim {end_a[a]}.")

# Verificando se algum valor de eta_as é 1, ou seja, se alguma aula cabe em alguma sala
# if any(value == 1 for value in eta_as.values()):
#     print("Há pelo menos uma aula que cabe em alguma sala.")
# for s in range(lenS):
#     print(f"Aula {df.loc[0, 'Disciplina (código)']}, Sala {salas.loc[s, 'Sala']}: {eta_as[(0, s)]}")

"""## Verificação dos Dados

### Funções Auxiliares
"""

def verificar_horarios_de_conflito(grupos_de_conflitos, salas_de_aulas):
    # Para cada grupo de conflito
    for grupo in grupos_de_conflitos:
        # Eu separo as aulas conflitantes em grupos baseados em quais salas elas cabem
        # E também separo as salas que suportam os grupos correspondentes
        grupo30 = [] # Aulas com até 30 alunos
        salas30 = []
        grupo45 = [] # Aulas com 31 a 45 alunos
        salas45 = []
        grupo73 = [] # Aulas com 46 a 73 alunos
        salas73 = []
        grupo77 = [] # Aulas com 74 a 77 alunos
        salas77 = []
        grupo80 = [] # Aulas com mais de 78 alunos
        salas80 = []

        # Vou definir algumas listas com os índices de algumas salas que comportam essas categorias.
        lista4 = salas.index[salas['Sala'].isin(['5-102', '3-102', '3-103', '3-104'])].tolist()
        lista3 = salas.index[salas['Sala'].isin(['3-009', '3-010', '3-011', '3-012', '5-002'])].tolist()
        lista2 = salas.index[salas['Sala'].isin(['5-103', '5-104'])].tolist()
        lista1 = salas.index[salas['Sala'].isin(['5-001', '5-003', '5-004', '5-101'])].tolist()
        lista0 = salas.index[salas['Sala'].isin(['4-001', '4-003', '4-005'])].tolist()

        # A variável verificar_fixadas é um contador de quantas aulas já foram fixadas anteriormente
        # para não contar como possíveis salas para as demais aulas.
        # Ex: Se eu tenho fixado duas salas grandes, elas não devem aparecer como 'vazias' na hora de alocar uma aula menor.
        # Se tem uma sala de 74 a 77 lugares fixadas, então, da segunda posição em diante, o vetor ganha o valor 1.
        # verificar_fixadas = [0,0,0,0,0]
        # A variável verificar_salas_fixadas é uma Lista das listas de salas fixadas pelas aulas.
        # Ex: Se duas aulas foram alocadas em salas grandes, então a primeira sublista contém quais dessas salas foram alocadas.
        # Isso ajudará nos momentos em que uma aula pequena for fixada em uma sala grande, pois na hora de verificar a
        # demanda de salas grandes, o código contabiliza essa fixação, ou seja, se eu tiver três aulas que precisam de salas grandes
        # e uma aula pequena fixada em uma sala grande, mas tenho apenas três salas grandes, o código perceberá esse conflito e mandará
        # um aviso ao usuário de que alguma aula foi alocada em uma sala requisitada por outras aulas.
        verificar_salas_fixadas = [[],[],[],[],[]]

        # Para cada aula no grupo em análise
        for aula in grupo:
            # Verifico em qual categoria a aula se enquadra, adicionando-a no grupo e salvando as salas que comportam a aula.
            if tam_t[int(aula % lenT)] <= 30:
                grupo30.append(aula)
                salas30.extend([s for s in salas_de_aulas[grupos_de_conflitos.index(grupo)] if eta_as[aula,s] == 1])
                salas30 = list(dict.fromkeys(salas30))
                last_entered = 4
            elif tam_t[int(aula % lenT)] <= 45 and tam_t[int(aula % lenT)] > 30:
                grupo45.append(aula)
                salas45.extend([s for s in salas_de_aulas[grupos_de_conflitos.index(grupo)] if eta_as[aula,s] == 1])
                salas45 = list(dict.fromkeys(salas45))
                last_entered = 3
            elif tam_t[int(aula % lenT)] <= 73 and tam_t[int(aula % lenT)] > 45:
                grupo73.append(aula)
                salas73.extend([s for s in salas_de_aulas[grupos_de_conflitos.index(grupo)] if eta_as[aula,s] == 1])
                salas73 = list(dict.fromkeys(salas73))
                last_entered = 2
            elif tam_t[int(aula % lenT)] <= 77 and tam_t[int(aula % lenT)] > 73:
                grupo77.append(aula)
                salas77.extend([s for s in salas_de_aulas[grupos_de_conflitos.index(grupo)] if eta_as[aula,s] == 1])
                salas77 = list(dict.fromkeys(salas77))
                last_entered = 1
            elif tam_t[int(aula % lenT)] <= 124 and tam_t[int(aula % lenT)] > 77:
                grupo80.append(aula)
                salas80.extend([s for s in salas_de_aulas[grupos_de_conflitos.index(grupo)] if eta_as[aula,s] == 1])
                salas80 = list(dict.fromkeys(salas80))
                last_entered = 0
            else:
                # Se eu não consegui colocar aquela aula em nenhuma das salas disponíveis, novamente notifico o erro.
                print(f"Não há sala capaz de comportar a disciplina {df.loc[aula % lenT, 'Disciplina (código)']}.")
                # print("System exit 6.\n")
                # sys.exit()
                custom_exit()
            # Se a aula possui uma sala fixada, preciso editar a lista de verificação.
            if sala_fixa[aula] != '0':
                # Se a aula é no LEM, então ela nem deveria contar para o número de "salas usadas",
                # então considero um preenchimento a menos, ou seja, de [0,0,0,0,0] para [-1,-1,-1,-1,-1].
                # if df.loc[int(aula % lenT), 'Sala'] == '6-307':
                # if sala_fixa[aula] == '6-307':
                #     verificar_fixadas[last_entered:] = [x - 1 for x in verificar_fixadas[last_entered:]]
                # Se a aula não for no LEM, eu verifico qual a sala fixada para aquela aula e qual categoria ela se enquadra.
                # Ex: Se a aula foi fixada em alguma sala do bloco 4, o índice da sala será um entre 5,6 ou 7. Além disso,
                # como são salas do grupo com mais de 80 lugares, então preciso considerar que ela não estará disponível
                # para o restante do grupo.
                # elif salas[salas['Sala'] == str(df.loc[int(aula % lenT), 'Sala'])].index[0] in lista0:
                # elif salas[salas['Sala'] == sala_fixa[aula]].index[0] in lista0:
                if salas[salas['Sala'] == sala_fixa[aula]].index[0] in lista0:
                    # Se a sala fixada é uma das do bloco 4, aumento o valor dos elementos da lista verificar_fixadas desde o índice
                    # equivalente ao grupo80, ou seja, de [0,0,0,0,0] para [1,1,1,1,1].
                    # verificar_fixadas[0:] = [x + 1 for x in verificar_fixadas[0:]]
                    # Também adiciono o índice da sala fixada na lista de mesmo índice do último grupo que a aula foi colocada, ou seja,
                    # se uma aula que pertence ao grupo77 foi fixada em uma sala do bloco 4, eu adiciono a sala na segunda posição da
                    # lista verificar_salas_fixadas, então de [[],[],[],[],[]] foi para [[],[5],[],[],[]].
                    # verificar_salas_fixadas[last_entered].append(salas[salas['Sala'] == str(df.loc[int(aula % lenT), 'Sala'])].index[0])
                    verificar_salas_fixadas[last_entered].append(salas[salas['Sala'] == sala_fixa[aula]].index[0])
                # As demais condições são equivalentes no raciocínio.
                # elif salas[salas['Sala'] == str(df.loc[int(aula % lenT), 'Sala'])].index[0] in lista1:
                elif salas[salas['Sala'] == sala_fixa[aula]].index[0] in lista1:
                    # verificar_fixadas[1:] = [x + 1 for x in verificar_fixadas[1:]]
                    # verificar_salas_fixadas[last_entered].append(salas[salas['Sala'] == str(df.loc[int(aula % lenT), 'Sala'])].index[0])
                    verificar_salas_fixadas[last_entered].append(salas[salas['Sala'] == sala_fixa[aula]].index[0])
                # elif salas[salas['Sala'] == str(df.loc[int(aula % lenT), 'Sala'])].index[0] in lista2:
                elif salas[salas['Sala'] == sala_fixa[aula]].index[0] in lista2:
                    # verificar_fixadas[2:] = [x + 1 for x in verificar_fixadas[2:]]
                    # verificar_salas_fixadas[last_entered].append(salas[salas['Sala'] == str(df.loc[int(aula % lenT), 'Sala'])].index[0])
                    verificar_salas_fixadas[last_entered].append(salas[salas['Sala'] == sala_fixa[aula]].index[0])
                # elif salas[salas['Sala'] == str(df.loc[int(aula % lenT), 'Sala'])].index[0] in lista3:
                elif salas[salas['Sala'] == sala_fixa[aula]].index[0] in lista3:
                    # verificar_fixadas[3:] = [x + 1 for x in verificar_fixadas[3:]]
                    # verificar_salas_fixadas[last_entered].append(salas[salas['Sala'] == str(df.loc[int(aula % lenT), 'Sala'])].index[0])
                    verificar_salas_fixadas[last_entered].append(salas[salas['Sala'] == sala_fixa[aula]].index[0])
                # elif salas[salas['Sala'] == str(df.loc[int(aula % lenT), 'Sala'])].index[0] in lista4:
                elif salas[salas['Sala'] == sala_fixa[aula]].index[0] in lista4:
                    # verificar_fixadas[4:] = [x + 1 for x in verificar_fixadas[4:]]
                    # verificar_salas_fixadas[last_entered].append(salas[salas['Sala'] == str(df.loc[int(aula % lenT), 'Sala'])].index[0])
                    verificar_salas_fixadas[last_entered].append(salas[salas['Sala'] == sala_fixa[aula]].index[0])





        # Formados os subgrupos de aulas conflitantes separados, vou analisar a existência de aulas disponíveis para este grupo.
        # Ex: Se eu tenho 3 aulas de mesmo horário, mas apenas 2 salas disponíveis para alocá-las, há um problema com o grupo.
        verificar_aulas = [grupo80, grupo77, grupo73, grupo45, grupo30]
        verificar_salas = [salas80, salas77, salas73, salas45, salas30]
        # print(verificar_aulas)
        # print(verificar_salas)
        # Para cada lista em verificar_salas_fixadas, isto é, para cada lista de salas fixadas
        for i,grupo1 in enumerate(verificar_salas_fixadas):
            # Salvo as salas repetidas, isto é, se houver duas aulas da mesma categoria de tamanho fixadas na mesma sala, a sala é salva
            # na variável salas_repetidas.
            # Ex: Suponha que existam duas aulas com cerca de 40 alunos que possuem conflito de horário,
            # e ambas foram fixadas na sala 3-009, então há um óbvio problema de que duas aulas estão fixadas no mesmo horário.
            salas_repetidas = [s for s in grupo1 if grupo1.count(s) > 1]
            # Se este caso for verdadeiro, isto é, duas aulas da mesma categoria estarem alocadas na mesma sala,
            # envio uma mensagem de erro, aponto quais aulas estão causando problema, e interrompo o código.
            if salas_repetidas:
                aula_repetida = [df.loc[int(aula % lenT), 'Disciplina (código)'] for aula in verificar_aulas[i]]
                aux = [a for a in aula_repetida if aula_repetida.count(a) > 1]
                if not aux:
                    print(f"Há aulas com conflito de horário que estão fixadas na mesma sala.")
                    print(f"Em particular, essas disciplinas que parecem estar dando problema:")
                    for aula in verificar_aulas[i]:
                        print(f"Aula {aula}, {df['Disciplina (código)'][int(aula % lenT)]}")
                    print("O grupo inteiro das aulas e disciplinas causando problema é esse:")
                    for grupinho in verificar_aulas:
                        for aula in grupinho:
                            print(f"Aula {aula}, {df['Disciplina (código)'][int(aula % lenT)]}")
                    # print("System exit 7.\n")
                    # sys.exit()
                    custom_exit()

            # Caso não tenham salas fixadas para uma mesma categoria, passo a verificar se o mesmo não acontece com categorias diferentes.
            # Ex: Suponha que existam duas aulas com conflito de horário, que foram fixadas em uma mesma sala do bloco 5,
            # uma com 70 alunos e outra com 40 alunos. Há um claro problema na situação, quase que o mesmo anterior.
            # Portanto, para cada lista em verificar_salas_fixadas, isto é, para cada lista de salas fixadas
            for j,grupo2 in enumerate(verificar_salas_fixadas):
                # Verifico se, para categorias diferentes, há aulas fixadas na mesma sala.
                if i != j and set(grupo1) & set(grupo2):
                    # Se este caso for verdadeiro, isto é, duas aulas de categorias diferentes estarem alocadas na mesma sala,
                    # envio uma mensagem de erro, aponto quais aulas estão causando problema, e interrompo o código.
                    print(
                        f"Há aulas com conflito de horário que estão fixadas na mesma sala."
                    )
                    print(f"Em particular, essas disciplinas que parecem estar dando problema:")

                    for aula in verificar_aulas[i]:
                        print(f"Aula {aula}, {df['Disciplina (código)'][int(aula % lenT)]}")
                    for aula in verificar_aulas[j]:
                        print(f"Aula {aula}, {df['Disciplina (código)'][int(aula % lenT)]}")

                    print("O grupo inteiro das aulas e disciplinas causando problema é esse:")
                    for grupinho in verificar_aulas:
                        for aula in grupinho:
                            print(f"Aula {aula}, {df['Disciplina (código)'][int(aula % lenT)]}")
                    # print("System exit 8.\n")
                    # sys.exit()
                    custom_exit()

        aux_verificar_aulas = verificar_aulas.copy()
        aux_verificar_salas = verificar_salas.copy()
        for i in range(len(verificar_aulas)):
            grupo = aux_verificar_aulas[i].copy()
            # if 4 in grupo:
            #     print(grupo)
            for aula in grupo:
                if sala_fixa[aula] != '0':
                    sala_fixada = salas.index[salas['Sala'] == sala_fixa[aula]].tolist()[0]
                    for s in aux_verificar_salas:
                        if sala_fixada in s:
                            s.remove(sala_fixada)
                    grupo.remove(aula)
            aux_verificar_aulas[i] = grupo
            
        
        aulas_alocadas = 0
        for g in range(len(verificar_aulas)):
            if len(aux_verificar_aulas[g]) > len(aux_verificar_salas[g]) - aulas_alocadas and len(aux_verificar_aulas[g]):
                print(
                    f"Há muitas aulas com conflito de horário no seguinte grupo, "
                    f"então uma troca de horários pode ser necessária, ou a diminuição do número de vagas da disciplina."
                    f"\nVerifique se alguma dessas disciplinas não foi proibida de ser alocada em uma sala específica, "
                    f"pois a proibição de uma pode afetar a alocação de outra."
                )
                print("Em particular, essas disciplinas que parecem estar dando problema:")
                for aula in verificar_aulas[g]:
                    print(f"Aula {aula}, {df['Disciplina (código)'][int(aula % lenT)]}")
                print("O grupo inteiro das aulas e disciplinas causando problema é esse:")
                for grupinho in verificar_aulas:
                    for aula in grupinho:
                        print(f"Aula {aula}, {df['Disciplina (código)'][int(aula % lenT)]}")
                # print("System exit 9.\n")
                # sys.exit()
                custom_exit()
            aulas_alocadas += len(aux_verificar_aulas[g])
        # Se não há aulas com conflito de horário fixadas em uma mesma sala, o próximo passo é verificar a existência de aulas
        # suficientes para um determinado grupo de conflitos.
        # A variável aulas_alocadas é um contador para "simular" as aulas alocadas. O funcionamento dessa etapa é puramente matemático,
        # analisando a alocação das aulas maiores para as menores. Intuitivamente, colocamos as aulas maiores nas salas maiores que
        # conseguem comportar as aulas menores. Com isso, no momento de alocar as salas menores, precisamos excluir as salas maiores
        # que "já foram alocadas", e estas são contabilizadas com a variável aulas_alocadas.
        aulas_alocadas = 0
        # Para cada categoria de tamanho na lista verificar_aulas.
        # for g in range(len(verificar_aulas)):
        #     # Verifico se o número de aulas de uma categoria, subtraído do número de aulas dessa categoria com sala já fixada,
        #     # é maior que o número de salas disponíveis para aquela categoria, subtraindo o número de salas já alocadas e o
        #     # número de aulas já fixadas, além de ignorar quando uma categoria é vazia.
        #     # Se esse for o caso, quer dizer que há mais aulas para serem alocadas do que salas disponíveis para serem alocadas.
        #     if len(verificar_aulas[g]) - len(verificar_salas_fixadas[g]) \
        #     > len(verificar_salas[g]) - aulas_alocadas - verificar_fixadas[g] \
        #     and len(verificar_aulas[g]) != 0:
        #         print("aulas", verificar_aulas[g])
        #         print("salas", len(verificar_salas[g]))
        #         print("salas - aulas", aulas_alocadas)
        #         print("fixadas", verificar_fixadas[g])
        #         print(f"conta {len(verificar_aulas[g])} - {len(verificar_salas_fixadas[g])} > {len(verificar_salas[g])} - {aulas_alocadas} - {verificar_fixadas[g]}")
        #         # Se este caso for verdadeiro, isto é, há mais aulas para serem alocadas do que salas disponíveis para serem alocadas,
        #         # envio uma mensagem de erro, aponto quais aulas estão causando problema, e interrompo o código.
        #         print(f"Há muitas aulas com conflito de horário no seguinte grupo, então uma troca de horários pode ser necessária:")
        #         print("Em particular, essas disciplinas que parecem estar dando problema:")
        #         for aula in verificar_aulas[g]:
        #             print(f"Aula {aula}, {df['Disciplina (código)'][int(aula % lenT)]}")
        #         print("O grupo inteiro das aulas e disciplinas causando problema é esse:")
        #         for grupinho in verificar_aulas:
        #             for aula in grupinho:
        #                 print(f"Aula {aula}, {df['Disciplina (código)'][int(aula % lenT)]}")
        #         # print("System exit 9.\n")
        #         # sys.exit()
        #         custom_exit()
        #     # Se é possível alocar as aulas de uma categoria, então contabilizo quantas aulas dessa categoria foram fixadas,
        #     # então aumento o número de aulas_alocadas pelo número de aulas da categoria.
        #     if len(verificar_aulas[g]) != 0:
        #         aulas_alocadas += len(verificar_aulas[g]) - len(verificar_salas_fixadas[g])

def verificar_horarios_de_conflito_lab(grupos_de_conflitos, salas_de_aulas):
    # Para cada grupo de conflito
    for grupo in grupos_de_conflitos:

        # Eu separo as aulas conflitantes em grupos baseados em quais salas elas cabem
        # E também separo as salas que suportam os grupos correspondentes
        grupo30 = [] # Aulas com até 30 alunos
        salas30 = []
        grupo60 = [] # Aulas com 31 a 60 alunos
        salas60 = []

        # Vou definir algumas listas com os índices de algumas salas que comportam essas categorias.
        lista2 = salas.index[salas['Sala'].isin(['1-004'])].tolist()
        lista1 = salas.index[salas['Sala'].isin(['1-004', '6-303', '6-304', '6-305', '6-306'])].tolist()
        lista0 = salas.index[salas['Sala'].isin(['6-303/6-304', '6-305/6-306'])].tolist()

        # A variável verificar_fixadas é um contador de quantas aulas já foram fixadas anteriormente
        # para não contar como possíveis salas para as demais aulas.
        # Ex: Se eu tenho fixado duas salas grandes, elas não devem aparecer como 'vazias' na hora de alocar uma aula menor.
        # Se tem uma sala de 74 a 77 lugares fixadas, então, da segunda posição em diante, o vetor ganha o valor 1.
        # verificar_fixadas = [0,0]
        # A variável verificar_salas_fixadas é uma Lista das listas de salas fixadas pelas aulas.
        # Ex: Se duas aulas foram alocadas em salas grandes, então a primeira sublista contém quais dessas salas foram alocadas.
        # Isso ajudará nos momentos em que uma aula pequena for fixada em uma sala grande, pois na hora de verificar a
        # demanda de salas grandes, o código contabiliza essa fixação, ou seja, se eu tiver três aulas que precisam de salas grandes
        # e uma aula pequena fixada em uma sala grande, mas tenho apenas três salas grandes, o código perceberá esse conflito e mandará
        # um aviso ao usuário de que alguma aula foi alocada em uma sala requisitada por outras aulas.
        verificar_salas_fixadas = [[],[]]

        # Para cada aula no grupo em análise
        for aula in grupo:
            # Verifico em qual categoria a aula se enquadra, adicionando-a no grupo e salvando as salas que comportam a aula.
            if tam_t[int(aula % lenT)] <= 30:
                grupo30.append(aula)
                salas30.extend([s for s in salas_de_aulas[grupos_de_conflitos.index(grupo)] if eta_as[aula,s] == 1])
                salas30 = list(dict.fromkeys(salas30))
                last_entered = 1
            elif tam_t[int(aula % lenT)] <= 60 and tam_t[int(aula % lenT)] > 30:
                grupo60.append(aula)
                salas60.extend([s for s in salas_de_aulas[grupos_de_conflitos.index(grupo)] if eta_as[aula,s] == 1])
                salas60 = list(dict.fromkeys(salas60))
                last_entered = 0
            else:
                # Se eu não consegui colocar aquela aula em nenhuma das salas disponíveis, novamente notifico o erro.
                print(f"Não há sala capaz de comportar a disciplina {df.loc[aula % lenT, 'Disciplina (código)']}.")
                # print("System exit 6.\n")
                # sys.exit()
                custom_exit()
            # Se a aula possui uma sala fixada, preciso editar a lista de verificação.
            if sala_fixa[aula] != '0':
                # Se a aula é de laboratório e foi fixada no LEM, então há algum erro de fixação. O códigonão considera o LEM como uma sala
                # de laboratório, muito menos uma sala normal para alocar outras disciplinas.
                # if df.loc[int(aula % lenT), 'Sala'] == '6-307':
                if sala_fixa[aula] == '6-307':
                    print(
                        f"As aulas de laboratório da disciplina {df.loc[aula % lenT, 'Disciplina (código)']} estão fixadas na sala 6-307"
                        f" , mas o código não considera isso como uma fixação válida. Por favor, considere definir o uso de laboratório como"
                        f" \'Não\', ou desafixe a sala."
                    )
                    custom_exit()
                # Se a aula não for no LEM, eu verifico qual a sala fixada para aquela aula e qual categoria ela se enquadra.
                # Ex: Se a aula foi fixada em alguma sala do bloco 4, o índice da sala será um entre 5,6 ou 7. Além disso,
                # como são salas do grupo com mais de 80 lugares, então preciso considerar que ela não estará disponível
                # para o restante do grupo.
                # elif salas[salas['Sala'] == str(df.loc[int(aula % lenT), 'Sala'])].index[0] in lista0:
                elif salas[salas['Sala'] == sala_fixa[aula]].index[0] in lista0:
                    # Se a sala fixada é um laboratório em conjunto (6-303/6-304), aumento o valor dos elementos da lista verificar_fixadas
                    # desde o índice equivalente ao grupo60, ou seja, de [0,0] para [3,3].
                    # Como o uso da sala 6-303/6-304 conta como uma sala a menos, e por conta dela proibir o uso das salas 6-303 e 6-304
                    # isoladamente, uma fixação conta como 3 salas, ao invés de apenas uma.
                    # verificar_fixadas[0:] = [x + 1 for x in verificar_fixadas[0:]]
                    # Também adiciono o índice da sala fixada na lista de mesmo índice do último grupo que a aula foi colocada, ou seja,
                    # se uma aula que pertence ao grupo77 foi fixada em uma sala do bloco 4, eu adiciono a sala na segunda posição da
                    # lista verificar_salas_fixadas, então de [[],[],[],[],[]] foi para [[],[5],[],[],[]].
                    # verificar_salas_fixadas[last_entered].append(salas[salas['Sala'] == str(df.loc[int(aula % lenT), 'Sala'])].index[0])
                    verificar_salas_fixadas[last_entered].append(salas[salas['Sala'] == sala_fixa[aula]].index[0])
                # As demais condições são equivalentes no raciocínio.
                # elif salas[salas['Sala'] == str(df.loc[int(aula % lenT), 'Sala'])].index[0] in lista1 and \
                # salas[salas['Sala'] == str(df.loc[int(aula % lenT), 'Sala'])].index[0] not in lista2:
                # elif salas[salas['Sala'] == sala_fixa[aula]].index[0] in lista1 and \
                # salas[salas['Sala'] == sala_fixa[aula]].index[0] not in lista2:
                    # Como o uso da sala 6-303 proibe o uso da sala 6-303/6-304, o uso dela conta como 2 salas a menos.
                    # verificar_fixadas[1:] = [x + 1 for x in verificar_fixadas[1:]]
                # elif salas[salas['Sala'] == str(df.loc[int(aula % lenT), 'Sala'])].index[0] in lista1 and \
                # salas[salas['Sala'] == str(df.loc[int(aula % lenT), 'Sala'])].index[0] in lista2:
                # elif salas[salas['Sala'] == sala_fixa[aula]].index[0] in lista1 and \
                # salas[salas['Sala'] == sala_fixa[aula]].index[0] in lista2:
                #     verificar_fixadas[1:] = [x + 1 for x in verificar_fixadas[1:]]
                elif salas[salas['Sala'] == sala_fixa[aula]].index[0] in lista1:
                    verificar_salas_fixadas[last_entered].append(salas[salas['Sala'] == sala_fixa[aula]].index[0])



        # print(f"grupo60: {grupo60}")
        # print(f"sala60: {salas60}")
        # Formados os subgrupos de aulas conflitantes separados, vou analisar a existência de aulas disponíveis para este grupo.
        # Ex: Se eu tenho 3 aulas de mesmo horário, mas apenas 2 salas disponíveis para alocá-las, há um problema com o grupo.
        verificar_aulas = [grupo60, grupo30]
        verificar_salas = [salas60, salas30]
        # print(verificar_aulas)
        # print(verificar_salas)
        # Para cada lista em verificar_salas_fixadas, isto é, para cada lista de salas fixadas
        for i,grupo1 in enumerate(verificar_salas_fixadas):
            # Salvo as salas repetidas, isto é, se houver duas aulas da mesma categoria de tamanho fixadas na mesma sala, a sala é salva
            # na variável salas_repetidas.
            # Ex: Suponha que existam duas aulas com cerca de 40 alunos que possuem conflito de horário,
            # e ambas foram fixadas na sala 3-009, então há um óbvio problema de que duas aulas estão fixadas no mesmo horário.
            salas_repetidas = [s for s in grupo1 if grupo1.count(s) > 1]
            # Se este caso for verdadeiro, isto é, duas aulas da mesma categoria estarem alocadas na mesma sala,
            # envio uma mensagem de erro, aponto quais aulas estão causando problema, e interrompo o código.
            if salas_repetidas:
                aula_repetida = [df.loc[int(aula % lenT), 'Disciplina (código)'] for aula in verificar_aulas[i]]
                aux = [a for a in aula_repetida if aula_repetida.count(a) > 1]
                if not aux:
                    print(f"Há aulas com conflito de horário que estão fixadas na mesma sala.")
                    print(f"Em particular, essas disciplinas que parecem estar dando problema:")
                    for aula in verificar_aulas[i]:
                        print(f"Aula {aula}, {df['Disciplina (código)'][int(aula % lenT)]}")
                    print("O grupo inteiro das aulas e disciplinas causando problema é esse:")
                    for grupinho in verificar_aulas:
                        for aula in grupinho:
                            print(f"Aula {aula}, {df['Disciplina (código)'][int(aula % lenT)]}")
                    # print("System exit 7.\n")
                    # sys.exit()
                    custom_exit()

            # Caso não tenham salas fixadas para uma mesma categoria, passo a verificar se o mesmo não acontece com categorias diferentes.
            # Ex: Suponha que existam duas aulas com conflito de horário, que foram fixadas em uma mesma sala do bloco 5,
            # uma com 70 alunos e outra com 40 alunos. Há um claro problema na situação, quase que o mesmo anterior.
            # Portanto, para cada lista em verificar_salas_fixadas, isto é, para cada lista de salas fixadas
            for j,grupo2 in enumerate(verificar_salas_fixadas):
                # Verifico se, para categorias diferentes, há aulas fixadas na mesma sala.
                if i != j and set(grupo1) & set(grupo2):
                    # Se este caso for verdadeiro, isto é, duas aulas de categorias diferentes estarem alocadas na mesma sala,
                    # envio uma mensagem de erro, aponto quais aulas estão causando problema, e interrompo o código.
                    print(
                        f"Há aulas com conflito de horário que estão fixadas na mesma sala."
                    )
                    print(f"Em particular, essas disciplinas que parecem estar dando problema:")

                    for aula in verificar_aulas[i]:
                        print(f"Aula {aula}, {df['Disciplina (código)'][int(aula % lenT)]}")
                    for aula in verificar_aulas[j]:
                        print(f"Aula {aula}, {df['Disciplina (código)'][int(aula % lenT)]}")

                    print("O grupo inteiro das aulas e disciplinas causando problema é esse:")
                    for grupinho in verificar_aulas:
                        for aula in grupinho:
                            print(f"Aula {aula}, {df['Disciplina (código)'][int(aula % lenT)]}")
                    # print("System exit 8.\n")
                    # sys.exit()
                    custom_exit()

        aux_verificar_aulas = verificar_aulas.copy()
        aux_verificar_salas = verificar_salas.copy()
        for i in range(len(verificar_aulas)):
            grupo = aux_verificar_aulas[i].copy()
            # if 4 in grupo:
            #     print(grupo)
            for aula in grupo:
                if sala_fixa[aula] != '0':
                    sala_fixada = salas.index[salas['Sala'] == sala_fixa[aula]].tolist()[0]
                    for s in aux_verificar_salas:
                        if sala_fixada in s:
                            s.remove(sala_fixada)
                    grupo.remove(aula)
            aux_verificar_aulas[i] = grupo
        aulas_alocadas = 0
        for g in range(len(verificar_aulas)):
            if len(aux_verificar_aulas[g]) > len(aux_verificar_salas[g]) - aulas_alocadas and len(aux_verificar_aulas[g]):
                print(
                    f"Há muitas aulas com conflito de horário no seguinte grupo, "
                    f"então uma troca de horários pode ser necessária, ou a diminuição do número de vagas da disciplina."
                    f"\nVerifique se alguma dessas disciplinas não foi proibida de ser alocada em uma sala específica, "
                    f"pois a proibição de uma pode afetar a alocação de outra."
                )
                print("Em particular, essas disciplinas que parecem estar dando problema:")
                for aula in verificar_aulas[g]:
                    print(f"Aula {aula}, {df['Disciplina (código)'][int(aula % lenT)]}")
                print("O grupo inteiro das aulas e disciplinas causando problema é esse:")
                for grupinho in verificar_aulas:
                    for aula in grupinho:
                        print(f"Aula {aula}, {df['Disciplina (código)'][int(aula % lenT)]}")
                # print("System exit 9.\n")
                # sys.exit()
                custom_exit()
            aulas_alocadas += len(aux_verificar_aulas[g])
        # Se não há aulas com conflito de horário fixadas em uma mesma sala, o próximo passo é verificar a existência de aulas
        # suficientes para um determinado grupo de conflitos.
        # A variável aulas_alocadas é um contador para "simular" as aulas alocadas. O funcionamento dessa etapa é puramente matemático,
        # analisando a alocação das aulas maiores para as menores. Intuitivamente, colocamos as aulas maiores nas salas maiores que
        # conseguem comportar as aulas menores. Com isso, no momento de alocar as salas menores, precisamos excluir as salas maiores
        # que "já foram alocadas", e estas são contabilizadas com a variável aulas_alocadas.
        aulas_alocadas = 0
        # Para cada categoria de tamanho na lista verificar_aulas.
        # for g in range(len(verificar_aulas)):
        #     # Verifico se o número de aulas de uma categoria, subtraído do número de aulas dessa categoria com sala já fixada,
        #     # é maior que o número de salas disponíveis para aquela categoria, subtraindo o número de salas já alocadas e o
        #     # número de aulas já fixadas, além de ignorar quando uma categoria é vazia.
        #     # Se esse for o caso, quer dizer que há mais aulas para serem alocadas do que salas disponíveis para serem alocadas.
        #     if len(verificar_aulas[g]) - len(verificar_salas_fixadas[g]) \
        #     > len(verificar_salas[g]) - aulas_alocadas - verificar_fixadas[g] \
        #     and len(verificar_aulas[g]) != 0:
        #         # print("aulas", verificar_aulas[g])
        #         # print("salas", len(verificar_salas[g]))
        #         # print("salas - aulas", aulas_alocadas)
        #         # print("fixadas", verificar_fixadas[g])
        #         # print(
        #         #     f"conta {len(verificar_aulas[g])} - {len(verificar_salas_fixadas[g]) }"
        #         #     f"> {len(verificar_salas[g])} - {aulas_alocadas} - {verificar_fixadas[g]}"
        #         # )
        #         # Se este caso for verdadeiro, isto é, há mais aulas para serem alocadas do que salas disponíveis para serem alocadas,
        #         # envio uma mensagem de erro, aponto quais aulas estão causando problema, e interrompo o código.
        #         print(f"Há muitas aulas com conflito de horário no seguinte grupo, então uma troca de horários pode ser necessária:")
        #         print("Em particular, essas disciplinas que parecem estar dando problema:")
        #         for aula in verificar_aulas[g]:
        #             print(f"Aula {aula}, {df['Disciplina (código)'][int(aula % lenT)]}")
        #         print("O grupo inteiro das aulas e disciplinas causando problema é esse:")
        #         for grupinho in verificar_aulas:
        #             for aula in grupinho:
        #                 print(f"Aula {aula}, {df['Disciplina (código)'][int(aula % lenT)]}")
        #         # print("System exit 9.\n")
        #         # sys.exit()
        #         custom_exit()
        #     # Se é possível alocar as aulas de uma categoria, então contabilizo quantas aulas dessa categoria foram fixadas,
        #     # então aumento o número de aulas_alocadas pelo número de aulas da categoria.
        #     if len(verificar_aulas) != 0:
        #         aulas_alocadas += len(verificar_aulas[g])


def custom_exit():
    # Obter o último frame da stack trace
    stack = traceback.extract_stack()[-2]  # O -2 pega a linha onde custom_exit foi chamada
    line_number = stack.lineno  # Pega o número da linha
    print(f"System exit da linha {line_number}")
    sys.exit()


# Aqui, trabalharemos com a ideia de uma rede de grafos. Neste caso, cada nó representa uma aula, e dois nós possuem uma aresta/conexão
# se as aulas possuem conflito de horário. Dessa forma, os nós ficam separados em clusters, mas algumas aulas são capazes de conectar dois
# clusters, como aulas das 17 às 19 que conectam o cluster das aulas das 16 às 18 com os das 18 às 20:40, que estão conectados com 
# os das 19 às 20:40. Por conta dessa natureza, na hora de fazer a verificação, haveria muito mais nós do que salas disponíveis.

# Com a ajuda da biblioteca Networkx, é possível fazer um algoritmo que detecta esses nós, e com isso podemos considerar os clusters separados para
# comparar apenas o tamanho dele com o número de salas disponíveis. Em outras palavras, o que queremos fazer, é analisar se, para um 
# determinado horário (cluster), existem salas suficientes para alocar todas as aulas daquele horário.

# Defino uma variável para conter a rede de grafos das aulas.
G = nx.Graph()

# Defino uma lista com todas as arestas dos nós, isto é, monto um grafo das aulas que possuem conflito de horário.
edges = [(a, al) for a in range(lenA) for al in range(lenA) if theta_aal[a, al] == 1 and a != al]

# Adiciono as arestas, e os nós, à rede.
G.add_edges_from(edges)

# Salvo o número original de componentes conexos para comparar com o número após retirar algum nó. Isso identificará os nós pontes.
original_components = list(nx.connected_components(G))
num_original_components = len(original_components)

# Identifico nós que realmente conectam clusters.
articulation_points = list(nx.articulation_points(G))

# Crio uma lista com os nós importantes que conectam clusters.
important_connectors = []

# Para cada nó que é um ponto de articulação:
for node in articulation_points:
    # Faço uma cópia temporária do grafo original.
    G_temp = G.copy()

    # Removo o ponto de articulação do grafo.
    G_temp.remove_node(node)

    # E faço outra lista com os nós conectados após retirar o ponto de articulação.
    new_components = list(nx.connected_components(G_temp))

    # Se o número de componentes aumentar, é um conector real, ou seja, é um nó que conecta dois clusters.
    if len(new_components) > num_original_components:
        important_connectors.append(node)

# Salvo o nome das disciplinas cujas aulas criam pontes (pontos de articulação ) entre clusters.
disciplinas_problematicas = [df.loc[node % lenT, 'Disciplina (código)'] for node in important_connectors]

# A variável grupos_de_conflitos é uma importante lista que irá conter listas de aulas que possuem conflito entre si,
# possibilitando uma análise prévia dos dados caso tenha algo de errado com eles.
grupos_de_conflitos = []

# Para cada aula 'a'
for a in range(lenA):
    # # Verifico se a aula 'a' não tem um horário problemático, isto é, se ela não conecta dois grupos de horário separados em um único.
    if df.loc[a % lenT, 'Disciplina (código)'] not in disciplinas_problematicas:
        # Se ela não tem um horário problemático
        # Verifico se já fiz outras listas de conflitos
        if len(grupos_de_conflitos) > 0:
            # Se há outras listas, crio um contador para verificar a existência da aula nas outras listas
            verificar = 0
            # Para cada outra lista de conflitos
            for grupo in grupos_de_conflitos:
                # Se encontro 'a' numa outra lista, não quero adicioná-la, então contabilizo ela e paro o loop
                if a in grupo:
                    verificar += 1
                    break
            # Se eu não encontrei 'a' numa outra lista, passo para a etapa de adicionar aulas com conflito na lista atual
            if verificar == 0:
                # A lista_a é uma lista de todas as aulas que possuem conflito de horário com a aula 'a'
                lista_a = []
                # Para cada 'al', se theta_aal = 1, adiciono ela na lista
                for al in range(lenA):
                    if theta_aal[a,al] == 1:
                        lista_a.append(al)
        else:
            # Se essa é minha primeira lista de conflitos, só verifico o theta_aal e adiciono as aulas com conflito
            # A lista_a é uma lista de todas as aulas que possuem conflito de horário com a aula 'a'
            lista_a = []
            for al in range(lenA):
                if theta_aal[a,al] == 1:
                    lista_a.append(al)

    # Se a lista de conflitos foi criada corretamente, deve haver ao menos uma aula nela
    if len(lista_a) > 0:
        # Após colocar a lista na lista de grupos de conflito, eu limpo a lista atual e começo a análise da aula seguinte
        grupos_de_conflitos.append(lista_a)
        lista_a = []

# print(grupos_de_conflitos)
# print(A_tt[df['Disciplina (código)'].tolist().index('SSC0142-1')])
# print(A_tt[df['Disciplina (código)'].tolist().index('SSC0109-1')])
# print(A_tt[df['Disciplina (código)'].tolist().index('SCC0222-2')])
# for a in [81, 121, 134, 183, 184, 292]:
#     print(df.loc[a % lenT, 'Disciplina (código)'])

"""### Verificação Geral"""

# Com o grupo "bruto" de aulas com conflitos, vamos analisar de forma mais detalhada cada uma delas
# A variável laboratorios_conflito é uma lista onde cada elemento é uma lista de aulas de laboratório que possuem conflito entre si
laboratorios_conflito = []
# A variável salas_de_aula é uma lista onde cada elemento é uma lista das salas disponíveis para um determinado grupo de aulas com conflito
# Ex: Se há 3 grupos em grupos_de_conflitos, então há 3 listas de salas em salas_de_aula,
# onde cada uma dessas listas equivale a um conjunto de salas que conseguem comportar as aulas do grupo de mesmo índice, ou seja,
# salas_de_aula[0] é a lista de salas que adequam as aulas presentes em grupos_de_conflitos[0]
salas_de_aula = []
# A variável salas_de_laboratorio seguem o mesmo raciocínio, mas apenas para as aulas de laboratório
salas_de_laboratorio = []


# Com essas novas listas criadas, passamos a analisar cada grupo em grupos_de_conflitos
for grupo in grupos_de_conflitos:
    # A variável aula_lab é uma lista que será usada para formar a lista de laboratorios_conflito
    aula_lab = []
    # A variável salas_de_aula_conflito é uma lista que será usada para formar a lista de salas_de_aula
    salas_de_aula_conflito = []
    # A variável salas_de_laboratorio_conflito é uma lista que será usada para formar a lista de salas_de_laboratorio
    salas_de_laboratorio_conflito = []
    # Para cada aula do grupo de conflito que estamos analisando
    for aula in grupo:
        # Verifico se é uma aula de laboratório
        if lab_tal[aula] == 1:
            # print(f"Aula de lab: {df.loc[aula % lenT, 'Disciplina (código)']}")
            # Em caso positivo, verifico se a aula foi fixada em uma sala.
            if sala_fixa[aula] != '0':
                # Verifico se a sala fixada foi um que não seja de laboratório, isto é,
                # a aula de laboratório foi fixada em uma sala que não é de laboratório.
                # if salas['Sala'].tolist().index(df.loc[aula % lenT, 'Sala']) not in salas_labs:
                if salas['Sala'].tolist().index(sala_fixa[aula]) not in salas_labs:
                    # Caso seja o caso, envio uma mensagem de erro e interrompo o código.
                    print(
                        f"Uma aula de laboratório da disciplina {df['Disciplina (código)'][aula % lenT]} foi fixada " \
                        f"em uma sala que não é de laboratório."
                    )
                    custom_exit()
                # elif eta_as[aula, salas['Sala'].tolist().index(df.loc[aula % lenT, 'Sala'])] != 1:
                elif eta_as[aula, salas['Sala'].tolist().index(sala_fixa[aula])] != 1:
                    print(
                        f"As aulas de laboratório da disciplina {df['Disciplina (código)'][aula % lenT]} foram fixadas " \
                        f"em uma sala de laboratório onde elas não cabem."
                        f"\nAlternativamente, a sala fixada também foi proíbida de ser usada por essa aula."
                    )
                    custom_exit()
                # Verifico se a aula foi fixada em uma sala onde outra aula de conflito também foi fixada.
                else:
                    # if df.loc[aula % lenT, 'Sala'] == '6-303/6-304':
                    if sala_fixa[aula] == '6-303/6-304':
                        for aula2 in grupo:
                            if aula != aula2 and sala_fixa[aula2] != '0':
                                if sala_fixa[aula] == sala_fixa[aula2] \
                                or \
                                sala_fixa[aula2] == '6-303' \
                                or \
                                sala_fixa[aula2] == '6-304':
                                # if (df.loc[aula % lenT, 'Sala']) == (df.loc[aula2 % lenT, 'Sala']) \
                                # or \
                                # df.loc[aula2 % lenT, 'Sala'] == '6-303' \
                                # or \
                                # df.loc[aula2 % lenT, 'Sala'] == '6-304':
                                    print(
                                        f"Uma aula de laboratório da disciplina {df['Disciplina (código)'][aula % lenT]} foi fixada " \
                                        f"na mesma sala (ou salas conjuntas) onde uma aula de laboratório da disciplina " \
                                        f"{df['Disciplina (código)'][aula2 % lenT]} foi fixada."
                                    )
                                    custom_exit()
                    # elif df.loc[aula % lenT, 'Sala'] == '6-305/6-306':
                    elif sala_fixa[aula] == '6-305/6-306':
                        for aula2 in grupo:
                            if aula != aula2 and sala_fixa[aula2] != '0':
                                if sala_fixa[aula] == sala_fixa[aula2] \
                                or \
                                sala_fixa[aula2] == '6-305' \
                                or \
                                sala_fixa[aula2] == '6-306':
                                # if (df.loc[aula % lenT, 'Sala']) == (df.loc[aula2 % lenT, 'Sala']) \
                                # or \
                                # df.loc[aula2 % lenT, 'Sala'] == '6-305' \
                                # or \
                                # df.loc[aula2 % lenT, 'Sala'] == '6-306':
                                    print(
                                        f"Uma aula de laboratório da disciplina {df['Disciplina (código)'][aula % lenT]} foi fixada " \
                                        f"na mesma sala (ou salas conjuntas) onde uma aula de laboratório da disciplina " \
                                        f"{df['Disciplina (código)'][aula2 % lenT]} foi fixada."
                                    )
                                    custom_exit()
                    else:
                        for aula2 in grupo:
                            if aula != aula2 and sala_fixa[aula2] == 1:
                                # if (df.loc[aula % lenT, 'Sala']) == (df.loc[aula2 % lenT, 'Sala']):
                                if sala_fixa[aula] == sala_fixa[aula2]:
                                    print(
                                        f"Uma aula de laboratório da disciplina {df['Disciplina (código)'][aula % lenT]} foi fixada " \
                                        f"na mesma sala (ou salas conjuntas) onde uma aula de laboratório da disciplina " \
                                        f"{df['Disciplina (código)'][aula2 % lenT]} foi fixada."
                                    )
                                    custom_exit()

            # if aula == 139:
            #     print(df.loc[aula % lenT, 'Disciplina (código)'])
            # Se a aula não foi fixada, eu a coloco na lista de aulas de laboratório com conflito e a retiro do grupo de conflito,
            # já que as demais aulas não precisam disputar sala com aulas de laboratório, e vice-versa
            # aula_lab.append(grupo.pop(grupo.index(aula)))
            aula_lab.append(aula)
            # grupo.remove(aula)
            # A variável auxiliar 'aux' é uma lista que serve para guardar
            # as salas de laboratórios capazes de acomodar a 'aula' sendo analisada.
            aux = [s for s in salas_labs if eta_as[aula,s] == 1]
            # Se existe ao menos um laboratório na lista capaz de atender a aula, eu salvo a lista.
            if len(aux) > 0:
                # O uso do extend ao invés do uso de append é para evitar mais linhas de iteração para cada elemento da lista auxiliar.
                salas_de_laboratorio_conflito.extend(aux)
            else:
                # Caso contrário, envio uma mensagem de erro e interrompo o código.
                print(
                    f"Alguma(s) aula(s) de laboratório da disciplina {df['Disciplina (código)'][aula % lenT]} " \
                    f"não pode(m) ser(em) alocada(s) por conta do número de alunos."
                    f"\nAlternativamente, a sala fixada também foi proíbida de ser usada por essa aula."
                )
                # print("System exit 2.\n")
                # sys.exit()
                custom_exit()
        # Para o caso de a aula não ser uma aula de laboratório.
        else:
            # Verifico se a aula está fixada em alguma sala.
            if sala_fixa[aula] != '0':
                # Para o caso da aula ter sido alocada em uma sala de laboratório.
                # if df.loc[aula % lenT, 'Sala'] in salas['Sala'].tolist() \
                # and salas['Sala'].tolist().index(df.loc[aula % lenT, 'Sala']) in salas_labs:
                # if sala_fixa[aula] in salas['Sala'].tolist() and salas['Sala'].tolist().index(sala_fixa[aula] in salas_labs):
                if sala_fixa[aula] in salas['Sala'].tolist() and sala_fixa[aula] in salas_labs:
                    # Envio uma mensagem de erro e interrompo o código.
                    # print("a")
                    print(
                        f"A aula da disciplina {df['Disciplina (código)'][aula % lenT]}" \
                        f" não é de laboratório, mas foi alocada em uma sala de laboratório."
                    )

                    custom_exit()
                # elif df.loc[aula % lenT, 'Sala'] != '6-307' and eta_as[aula, salas['Sala'].tolist().index(df.loc[aula % lenT, 'Sala'])] != 1:
                # elif sala_fixa[aula] != '6-307' and eta_as[aula, salas['Sala'].tolist().index(sala_fixa[aula])] != 1:
                elif eta_as[aula, salas['Sala'].tolist().index(sala_fixa[aula])] != 1:
                    print(
                        f"As aulas da disciplina {df['Disciplina (código)'][aula % lenT]} foram fixadas " \
                        f"em uma sala onde elas não cabem."
                        f"\nAlternativamente, a sala fixada também foi proíbida de ser usada por essa aula."
                    )
                    custom_exit()
                # Verifico se a aula foi fixada em uma sala onde outra aula de conflito também foi fixada.
                else:
                    # Verifico as demais aulas do grupo de conflito atual.
                    for aula2 in grupo:
                        # Se houver uma outra aula (aula2) deste grupo que está fixada na mesma sala da aula atual.
                        # if aula != aula2 and theta_aal[aula, aula2] == 1 and \
                        if aula != aula2 and \
                        sala_fixa[aula2] != '0' and \
                        salas['Sala'].tolist().index(sala_fixa[aula]) == salas['Sala'].tolist().index(sala_fixa[aula2]):
                        # sala_fixa[aula2] != '6-307' and \
                        # salas['Sala'].tolist().index(sala_fixa[aula]) == salas['Sala'].tolist().index(sala_fixa[aula2]):
                        # if sala_fixa[aula2] == 1 and \
                        # (df.loc[aula2 % lenT, 'Sala']) != '6-307' and \
                        # salas['Sala'].tolist().index(df.loc[aula % lenT, 'Sala']) == \
                        # salas['Sala'].tolist().index(df.loc[aula2 % lenT, 'Sala']):
                        
                            # Envio uma mensagem de erro e interrompo o código.
                            print(
                                f"Uma aula da disciplina {df['Disciplina (código)'][aula % lenT]} foi fixada " \
                                f"na mesma sala onde uma aula da disciplina {df['Disciplina (código)'][aula2 % lenT]} foi fixada."
                            )
                            custom_exit()
                    # Se a aula não foi fixada no LEM (sala 6-307).
                    # if df.loc[aula % lenT, 'Sala'] != '6-307':
                    # if sala_fixa[aula] != '6-307':
                    #     # Verifico as demais aulas do grupo de conflito atual.
                    #     for aula2 in grupo:
                    #         # Se houver uma outra aula (aula2) deste grupo que está fixada na mesma sala da aula atual.
                    #         # if aula != aula2 and theta_aal[aula, aula2] == 1 and \
                    #         if aula != aula2 and \
                    #         sala_fixa[aula2] != '0' and \
                    #         sala_fixa[aula2] != '6-307' and \
                    #         salas['Sala'].tolist().index(sala_fixa[aula]) == salas['Sala'].tolist().index(sala_fixa[aula2]):
                    #         # if sala_fixa[aula2] == 1 and \
                    #         # (df.loc[aula2 % lenT, 'Sala']) != '6-307' and \
                    #         # salas['Sala'].tolist().index(df.loc[aula % lenT, 'Sala']) == \
                    #         # salas['Sala'].tolist().index(df.loc[aula2 % lenT, 'Sala']):
                            
                    #             # Envio uma mensagem de erro e interrompo o código.
                    #             print(
                    #                 f"Uma aula da disciplina {df['Disciplina (código)'][aula % lenT]} foi fixada " \
                    #                 f"na mesma sala onde uma aula da disciplina {df['Disciplina (código)'][aula2 % lenT]} foi fixada."
                    #             )
                    #             custom_exit()
                    # # Caso a aula esteja fixada no LEM (sala 6-307).
                    # else:
                    #     # Verifico as demais aulas do grupo de conflito atual.
                    #     for aula2 in grupo:
                    #         # Se houver outra aula fixada na 6-307 com conflito de horário.
                    #         if aula != aula2 and \
                    #         sala_fixa[aula2] != '0' and \
                    #         sala_fixa[aula2] == '6-307':
                    #         # sala_fixa[aula2] == 1 and \
                    #         # (df.loc[aula2 % lenT, 'Sala']) == '6-307':
                            
                    #             # Envio uma mensagem de erro e interrompo o código.
                    #             print(
                    #                 f"As disciplinas {df['Disciplina (código)'][aula % lenT]} e "
                    #                 f"{df['Disciplina (código)'][aula2 % lenT]} foram fixadas no LEM, mesmo possuindo conflito de horários."
                    #             )
                    #             custom_exit()

            # Utilizo novamente uma lista auxiliar com as salas que são capazes de atender àquela aula, não contando os laboratórios
            aux = [s for s in range(lenS) if eta_as[aula,s] == 1 and s not in salas_labs]
            # Se existe ao menos uma sala na lista capaz de atender a aula, eu salvo a lista
            if len(aux) > 0:
                # O uso do extend ao invés do uso de append é para evitar mais linhas de iteração para cada elemento da lista auxiliar
                salas_de_aula_conflito.extend(aux)
            else:
                # Caso contrário, envio uma mensagem de erro e interrompo o código.
                print(
                    f"Alguma(s) aula(s) da disciplina {df['Disciplina (código)'][aula % lenT]} "
                    f"não pode(m) ser(em) alocada(s) por conta do número de alunos."
                    f"\nAlternativamente, a sala fixada também foi proíbida de ser usada por essa aula."
                )
                # print("System exit 3.\n")
                # sys.exit()
                custom_exit()
    for aula in grupo:
        if lab_tal[aula] == 1:
            grupo.remove(aula)
    # Nesta etapa, eu verifico quais listas foram construídas com as aulas do grupo sendo analisado.
    # Como na etapa anterior o grupo é atualizado para ficar sem as aulas de laboratório
    # não há a necessidade de alterá-lo aqui.
    # Note também que eu não checo o tamanho de 'salas_de_laboratorio_conflito', pois, se o código chegou até aqui,
    # é garantido pelas condições da etapa anterior que existam laboratórios capazes de comportar as aulas do grupo.
    # Se há elementos tanto em aula_lab quanto salas_de_aula_conflito, isto é, se no grupo haviam aulas normais e aulas de laboratório.
    if len(aula_lab) > 0 and len(salas_de_aula_conflito) > 0:
        # Adiciono a lista de aulas de laboratório na lista adequada.
        laboratorios_conflito.append(aula_lab)
        # Também adiciono as salas de laboratório que podem ser utilizadas para essas aulas.
        # Note que usar o método list(dict.fromkeys(x)) faz com que valores repetidos sejam unificados em um,
        # pois transformar uma lista em um dicionário unifica seus elementos, que depois é convertido novamente em uma lista.

        salas_de_laboratorio.append(list(dict.fromkeys(salas_de_laboratorio_conflito)))
        # O mesmo é feito para as salas de aula normais.
        salas_de_aula.append(list(dict.fromkeys(salas_de_aula_conflito)))

    # Caso haver apenas aulas comuns.
    elif len(salas_de_aula_conflito) > 0 and len(aula_lab) == 0:
        # Apenas adiciono as salas de aula que suportam o grupo.
        salas_de_aula.append(list(dict.fromkeys(salas_de_aula_conflito)))

    # De forma semelhante, caso houvesse apenas laboratórios no grupo de conflitos.
    elif len(salas_de_aula_conflito) == 0 and len(aula_lab) > 0:
        # Adiciono as aulas de laboratório conflitantes.
        laboratorios_conflito.append(aula_lab)
        # Adiciono as salas de laboratório que suportam o grupo.
        salas_de_laboratorio.append(list(dict.fromkeys(salas_de_laboratorio_conflito)))

    # Se nenhum dos casos anteriores é verdade, envio uma mensagem de erro, o grupo de turmas/disciplinas conflitantes, e interrompo o código.
    else:
        print("Alguma(s) das aulas das seguintes disciplinas não podem ser alocadas por conta do número de alunos:")
        for i in grupo:
            print(df['Disciplina (código)'][i])
        # print("System exit 4.\n")
        # sys.exit()
        custom_exit()

# print("Aulas com conflito:", grupos_de_conflitos,"\n")
# print(sum([len(g) for g in grupos_de_conflitos]))
# print("Laboratórios com conflito:", laboratorios_conflito,"\n")
# print(sum([len(g) for g in laboratorios_conflito]))

# print("Salas de aula de cada grupo com conflito", salas_de_aula,"\n")
# print("Laboratórios de cada grupo com conflito", salas_de_laboratorio,"\n")

"""### Verificação por Categorias"""

# Verificação de horários conflitantes.
# Se, por algum motivo, tiver mais grupos conflitantes que de salas para esses grupos, isso deve indicar que
# existem aulas que não estão em conflito com nenhuma outra, mas não conseguem ser alocadas em nenhuma sala.
# Esse erro já deveria ter acontecido na construção desses grupos, então nem deveria chegar aqui.
# Caso chegue neste ponto, envio uma mensagem de erro e interrompo o código.
if len(grupos_de_conflitos) > len(salas_de_aula):
    print("Há um problema entre os conjuntos de aulas conflitantes e as salas disponíveis para estes conjuntos.")
    # print("System exit 5.\n")
    # sys.exit()
    custom_exit()
else:
    # Caso contrário, faço uma análise das aulas que estão em conflito de horário umas com as outras
    verificar_horarios_de_conflito(grupos_de_conflitos, salas_de_aula)

if len(laboratorios_conflito) > len(salas_de_laboratorio):
    print("Há um problema entre os conjuntos de aulas de laboratório conflitantes e os laboratórios disponíveis para estes conjuntos.")
    custom_exit()
else:
    # Caso contrário, faço uma análise das aulas que estão em conflito de horário umas com as outras
    verificar_horarios_de_conflito_lab(laboratorios_conflito, salas_de_laboratorio)


# Se nenhuma das situações de erro foi encontrada, aviso que não há nenhum erro aparente com os dados fornecidos.
print("Aparentemente, não há nenhum conflito de horário, e há salas disponíveis em todos os horários necessários.")